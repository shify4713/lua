-- PreCraft Auto-Crafting Tool (OpenOS 1.6.1, Lua 5.2)
-- Итоговый вариант: разделённое обновление автокрафта, UI и лог‑окна.
-- Основной UI перерисовывается реже (и не обновляется, когда логи активны),
-- что устраняет мерцание и не затирает логовое окно, а логи сохраняются постоянно.
local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode")
local term = require("term")
local gpu = component.gpu
local me = component.me_interface

-- Загрузка библиотеки oc.lua, если отсутствует
local libURL = "https://raw.githubusercontent.com/shify4713/lua/refs/heads/main/g.lib-precraft"
local libPath = "/lib/oc.lua"
if not fs.exists(libPath) then
  shell.execute("wget " .. libURL .. " " .. libPath)
end
local oc = require("oc")

-- Работа с файлом данных
local dataFile = "/home/BD.txt"
if not fs.exists(dataFile) then
  oc.savef(dataFile, {})
end

---------------------- НАСТРОЙКИ ----------------------
local ADM = { ["LiwMorgan"] = true }  -- Доступ только для указанного ника

-- Размер экрана (160×50)
local WIDTH, HEIGHT = 160, 50
gpu.setResolution(WIDTH, HEIGHT)

---------------------- ПАЛИТРА ЦВЕТОВ ----------------------
local BG_MAIN             = 0x1A1A1A  -- Тёмно-серый фон
local CTEXT               = 0xDADADA  -- Светло-серый текст
local COLOR_BUTTON        = 0x4A90E2  -- Синий для кнопок
local COLOR_BUTTON_TEXT   = 0xFFFFFF  -- Белый текст на кнопках
local COLOR_HIGHLIGHT     = 0x3A3A3A  -- Подсветка выбранной строки
local COLOR_LOW           = 0xFF4C4C  -- Красный – недостаточно
local COLOR_MEDIUM        = 0xFFCC00  -- Желтый – промежуточно
local COLOR_HIGH          = 0x00FF66  -- Зелёный – достаточно

local BG_ALT              = 0x2A2A2A  -- Альтернативный фон для четных строк
local COLOR_HEADER_BG     = 0x333333  -- Фон заголовка
local COLOR_LOG_BG        = 0x2D2D2D  -- Фон всплывающей области логов
local COLOR_BUTTON_BORDER = 0x000000  -- Граница кнопок

---------------------- РАЗМЕРЫ UI ----------------------
-- Таблица располагается слева и заполняет почти всю ширину.
local TABLE_X = 2
-- "Полная" ширина строки (без рамки) = 157 символов.
-- Распределение столбцов:
-- Idx: 5, Категория: 15, Req: 12, ME: 12, Craft: 12  → сумма = 56.
-- Остаток (157 – 7 разделителей – 56) для столбца Name = 94.
local TABLE_WIDTH = 157  
local TABLE_HEADER_Y = 4      -- Заголовок таблицы
local TABLE_BODY_START_Y = TABLE_HEADER_Y + 2
local VISIBLE_TABLE_ROWS = 35

---------------------- ГЛОБАЛЫЕ ПЕРЕМЕННЫЕ ----------------------
local dataItems = {}           -- Список предметов
local dataQueue = {}           -- Для автокрафта (ссылка на dataItems)
local scroll = 1               -- Текущая позиция в таблице
local posSelect = nil          -- Выбранная строка таблицы
local craftingActive = false   -- Состояние автокрафта (ON/OFF)
local running = true           -- Флаг работы программы
local maxScroll = 1            -- Максимальное смещение
local content = {}             -- Отфильтрованный/отсортированный список

local sortCriteria = "name"    -- Возможные: "name", "category", "count"
local sortCriteriaDisplay = { name = "Имя", category = "Категория", count = "Количество" }

local craftLogs = {}           -- Массив логов (до 20 записей) – записи сохраняются постоянно
local logsVisible = false      -- Флаг: активно ли логовое окно
local buttons = {}             -- Таблица кнопок

local redrawNeeded = true      -- Флаг необходимости перерисовки основного UI
local logTimerId = nil         -- ID таймера для логового окна (запускается, если логи активны)

-- Forward declaration для drawCustomButton
local drawCustomButton = nil

---------------------- ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ ----------------------
local function padOrTrim(text, width)
  text = tostring(text)
  local len = unicode.len(text)
  if len > width then
    return unicode.sub(text, 1, width)
  else
    return text .. string.rep(" ", width - len)
  end
end

---------------------- ФУНКЦИЯ РИСОВАНИЯ ГРАНИЦЫ ----------------------
local function drawBorder(x, y, w, h, fgColor)
  fgColor = fgColor or CTEXT
  gpu.setForeground(fgColor)
  gpu.set(x, y, "┌" .. string.rep("─", w - 2) .. "┐")
  gpu.set(x, y + h - 1, "└" .. string.rep("─", w - 2) .. "┘")
  for i = y + 1, y + h - 2 do
    gpu.set(x, i, "│")
    gpu.set(x + w - 1, i, "│")
  end
end

---------------------- ФУНКЦИЯ ОТРИСОВКИ КНОПКИ ----------------------
drawCustomButton = function(x, y, w, h, bgColor, textColor, text)
  gpu.setBackground(bgColor)
  gpu.fill(x, y, w, h, " ")
  gpu.setForeground(COLOR_BUTTON_BORDER)
  drawBorder(x, y, w, h, COLOR_BUTTON_BORDER)
  gpu.setForeground(textColor)
  local textPosX = x + math.floor((w - unicode.len(text)) / 2)
  local textPosY = y + math.floor(h / 2)
  gpu.set(textPosX, textPosY, text)
end

---------------------- РИСОВКА СТАТИЧЕСКОГО UI ----------------------
local function drawStaticUI()
  -- Чтобы избежать мерцания основного меню, очистку экрана выполняем только когда окно логов не активно.
  if not logsVisible then
    gpu.setBackground(BG_MAIN)
    gpu.fill(1, 1, WIDTH, HEIGHT, " ")
  end
  
  gpu.setBackground(COLOR_HEADER_BG)
  gpu.fill(1, 1, WIDTH, 3, " ")
  local header = "PreCraft - Автокрафт предметов"
  local sortText = "Сортировка: " .. sortCriteriaDisplay[sortCriteria]
  gpu.setForeground(CTEXT)
  gpu.set(math.floor((WIDTH - unicode.len(header)) / 2), 1, header)
  gpu.set(2, 2, sortText)
  
  local tableHeaderHeight = (TABLE_BODY_START_Y - TABLE_HEADER_Y) + VISIBLE_TABLE_ROWS + 2
  drawBorder(TABLE_X - 1, TABLE_HEADER_Y - 1, TABLE_WIDTH + 2, tableHeaderHeight, COLOR_BUTTON)
  
  local headerStr = "|" .. padOrTrim("Idx", 5) .. "|" ..
                           padOrTrim("Name", 94) .. "|" ..
                           padOrTrim("Категория", 15) .. "|" ..
                           padOrTrim("Req", 12) .. "|" ..
                           padOrTrim("ME", 12) .. "|" ..
                           padOrTrim("Craft", 12) .. "|"
  gpu.setBackground(COLOR_HEADER_BG)
  gpu.setForeground(CTEXT)
  gpu.set(TABLE_X, TABLE_HEADER_Y, headerStr)
  gpu.set(TABLE_X, TABLE_HEADER_Y + 1, string.rep("─", TABLE_WIDTH))
end

---------------------- РИСОВКА ЛОГОВОГО ОКНА ----------------------
local function drawFloatingLogs()
  local overlayWidth = 70
  local overlayHeight = 20
  local overlayX = math.floor((WIDTH - overlayWidth) / 2)
  local overlayY = math.floor((HEIGHT - overlayHeight) / 2)
  drawBorder(overlayX - 1, overlayY - 1, overlayWidth + 2, overlayHeight + 2, COLOR_BUTTON)
  gpu.setBackground(COLOR_LOG_BG)
  gpu.fill(overlayX, overlayY, overlayWidth, overlayHeight, " ")
  local logY = overlayY
  local startIdx = math.max(1, #craftLogs - overlayHeight + 1)
  for i = startIdx, #craftLogs do
    local log = craftLogs[i]
    local logText = log.text
    if unicode.len(logText) > overlayWidth - 2 then
      logText = unicode.sub(logText, 1, overlayWidth - 2)
    end
    gpu.setForeground(log.color)
    gpu.set(overlayX + 1, logY, logText)
    logY = logY + 1
  end
end

---------------------- РИСОВКА ТАБЛИЦЫ ----------------------
local function drawTableItems()
  for row = TABLE_BODY_START_Y, TABLE_BODY_START_Y + VISIBLE_TABLE_ROWS - 1 do
    gpu.setBackground(BG_MAIN)
    gpu.fill(TABLE_X, row, TABLE_WIDTH, 1, " ")
  end
  
  for i = scroll, math.min(#content, scroll + VISIBLE_TABLE_ROWS - 1) do
    local rowPos = TABLE_BODY_START_Y + (i - scroll)
    local record = content[i]
    local item = record.item
    local detail = me.getItemDetail({id = item.id, dmg = item.dmg})
    local currentQty = 0
    if detail and detail.basic() then
      currentQty = detail.basic().qty or 0
    end
    local reqCount = tonumber(item.count) or 0
    local diff = reqCount - currentQty
    local colorText = CTEXT
    if currentQty >= reqCount then
      colorText = COLOR_HIGH
    elseif diff >= math.floor(reqCount * 0.5) then
      colorText = COLOR_LOW
    else
      colorText = COLOR_MEDIUM
    end

    local rowBg = ((i - scroll) % 2 == 0) and BG_MAIN or BG_ALT
    if posSelect and (i == posSelect) then
      rowBg = COLOR_HIGHLIGHT
    end

    gpu.setBackground(rowBg)
    local rowStr = "|" .. padOrTrim(i, 5) ..
                         "|" .. padOrTrim(item.name, 94) ..
                         "|" .. padOrTrim(item.category or "", 15) ..
                         "|" .. padOrTrim(reqCount, 12) ..
                         "|" .. padOrTrim(currentQty, 12) ..
                         "|" .. padOrTrim(item.craftSize or 0, 12) .. "|"
    gpu.setForeground(colorText)
    gpu.set(TABLE_X, rowPos, rowStr)
  end
end

---------------------- РИСОВКА СКРОЛЛБАРА ----------------------
local function drawScrollBar()
  oc.drawscroll(TABLE_X + TABLE_WIDTH, TABLE_BODY_START_Y, 1, VISIBLE_TABLE_ROWS,
                scroll, #content, COLOR_HIGHLIGHT, COLOR_BUTTON)
end

---------------------- РИСОВКА КНОПОК ----------------------
local function drawButtons()
  for i, button in ipairs(buttons) do
    if button.visible then
      local btnText = button.text
      if button.id == "craft" then
        btnText = "Craft: " .. (craftingActive and "ON" or "OFF")
      elseif button.id == "logs" then
        btnText = "Logs: " .. (logsVisible and "ON" or "OFF")
      end
      drawCustomButton(button.x, button.y, button.w, button.h,
                       COLOR_BUTTON, COLOR_BUTTON_TEXT, btnText)
    end
  end
end

---------------------- ПОЛНАЯ ПЕРЕРИСОВКА ----------------------
local function fullRedraw()
  drawStaticUI()
  drawTableItems()
  drawScrollBar()
  drawButtons()
end

---------------------- ЗАПРОС ПЕРЕРИСОВКИ ----------------------
local function requestRedraw()
  redrawNeeded = true
end

---------------------- ОБНОВЛЕНИЕ КОНТЕНТА ТАБЛИЦЫ ----------------------
local function updateContent()
  content = {}
  for i, item in ipairs(dataItems) do
    table.insert(content, { idx = i, item = item })
  end

  if sortCriteria == "name" then
    table.sort(content, function(a, b)
      return (a.item.name or ""):lower() < (b.item.name or ""):lower()
    end)
  elseif sortCriteria == "category" then
    table.sort(content, function(a, b)
      return (a.item.category or ""):lower() < (b.item.category or ""):lower()
    end)
  elseif sortCriteria == "count" then
    table.sort(content, function(a, b)
      return (tonumber(a.item.count) or 0) < (tonumber(b.item.count) or 0)
    end)
  end
  
  maxScroll = math.max(1, #content - VISIBLE_TABLE_ROWS + 1)
  if scroll > maxScroll then scroll = maxScroll end
end

---------------------- ОКНО ВВОДА ДАННЫХ ----------------------
local function inputOverlay(promptMessage)
  local boxW, boxH = 60, 3
  local boxX = math.floor((WIDTH - boxW) / 2)
  local boxY = math.floor((HEIGHT - boxH) / 2)
  drawBorder(boxX - 1, boxY - 1, boxW + 2, boxH + 2, COLOR_BUTTON)
  gpu.setBackground(BG_MAIN)
  gpu.fill(boxX, boxY, boxW, boxH, " ")
  gpu.setForeground(CTEXT)
  gpu.set(boxX + 2, boxY, promptMessage)
  term.setCursor(boxX + 2 + unicode.len(promptMessage) + 1, boxY)
  term.setCursorBlink(true)
  local input = term.read()
  requestRedraw()
  return input:sub(1, -2)
end

---------------------- РАБОТА С ПРЕДМЕТАМИ ----------------------
local function addItem()
  local stack = me.getStackInSlot(1)
  if stack then
    local name = inputOverlay("Введите название:")
    local category = inputOverlay("Введите категорию:")
    local count = tonumber(inputOverlay("Введите требуемое число:"))
    local craftSize = tonumber(inputOverlay("Введите объём крафта:"))
    table.insert(dataItems, {
      name = name,
      category = category,
      id = stack.id,
      dmg = stack.dmg,
      count = count,
      craftSize = craftSize,
      cpu = 262144
    })
    oc.savef(dataFile, dataItems)
    table.insert(craftLogs, { text = "[Add] Добавлен: " .. name, color = COLOR_MEDIUM })
  else
    inputOverlay("Предмет не установлен в 1-й слот! (Нажмите Enter)")
  end
  dataItems = oc.loadf(dataFile) or {}
  updateContent()
  scroll = 1
  posSelect = nil
  requestRedraw()
end

local function removeItem()
  if posSelect then
    local orig = content[posSelect].idx
    table.remove(dataItems, orig)
    oc.savef(dataFile, dataItems)
    table.insert(craftLogs, { text = "[Edit] Удалён: " .. content[posSelect].item.name, color = COLOR_LOW })
    posSelect = nil
    dataItems = oc.loadf(dataFile) or {}
    updateContent()
    requestRedraw()
  end
end

local function editItem()
  if posSelect then
    local idx = content[posSelect].idx
    local item = dataItems[idx]
    local name = inputOverlay("Введите новое имя (текущее: " .. item.name .. "):")
    if name ~= "" then item.name = name end
    local cat = inputOverlay("Введите новую категорию (текущее: " .. (item.category or "") .. "):")
    if cat ~= "" then item.category = cat end
    local countStr = inputOverlay("Введите требуемое число (текущее: " .. item.count .. "):")
    if countStr ~= "" then
      local count = tonumber(countStr)
      if count then item.count = count end
    end
    local craftSizeStr = inputOverlay("Введите объём крафта (текущее: " .. item.craftSize .. "):")
    if craftSizeStr ~= "" then
      local craftSize = tonumber(craftSizeStr)
      if craftSize then item.craftSize = craftSize end
    end
    dataItems[idx] = item
    oc.savef(dataFile, dataItems)
    updateContent()
    table.insert(craftLogs, { text = "[Edit] Изменён: " .. item.name, color = COLOR_MEDIUM })
    posSelect = nil
    requestRedraw()
  end
end

---------------------- АВТО-КРАФТ (256К-хранилище) ----------------------
local function autoCraftCheck()
  for i, item in ipairs(dataQueue) do
    if not item.craft or item.craft.isDone() or item.craft.isCanceled() then
      item.craft = nil
      local detail = me.getItemDetail({id = item.id, dmg = item.dmg})
      if detail then
        local currentQty = 0
        if detail.basic() then 
          currentQty = detail.basic().qty or 0
        end
        local reqCount = tonumber(item.count) or 0
        local delta = reqCount - currentQty
        if delta > 0 then
          local cpus = me.getCpus()
          for _, cpu in ipairs(cpus) do
            if not cpu.busy and cpu.storage == 262144 then
              local craftables = me.getCraftables({name = item.id, damage = item.dmg})
              if craftables.n and craftables.n >= 1 then
                item.craft = craftables[1].request(delta, false, tostring(item.cpu))
                table.insert(craftLogs, { text = "[Craft] " .. item.name .. " x" .. delta, color = COLOR_HIGH })
                break
              else
                table.insert(craftLogs, { text = "[Craft] " .. item.name .. " не имеет рецепта", color = COLOR_LOW })
              end
            end
          end
        end
      end
    end
  end
  requestRedraw()
end

---------------------- ОБРАБОТКА СОБЫТИЙ ----------------------
local function onTouch(_, _, x, y, _, nick)
  if ADM[nick] then
    for i, button in ipairs(buttons) do
      if x >= button.x and x <= (button.x + button.w - 1)
         and y >= button.y and y <= (button.y + button.h - 1) then
          button.action()
          return true
      end
    end
    if x >= TABLE_X and x <= (TABLE_X + TABLE_WIDTH - 1)
       and y >= TABLE_BODY_START_Y and y < (TABLE_BODY_START_Y + VISIBLE_TABLE_ROWS) then
      posSelect = scroll + (y - TABLE_BODY_START_Y)
      requestRedraw()
    end
  end
end

local function onScroll(_, _, _, _, dir, nick)
  if ADM[nick] then
    if dir == 1 and scroll > 1 then
      scroll = scroll - 1
    elseif dir == -1 and scroll < maxScroll then
      scroll = scroll + 1
    end
    requestRedraw()
  end
end

---------------------- ИНИЦИАЛИЗАЦИЯ КНОПОК ----------------------
local function initButtons()
  buttons = {
    {
      id = "craft", visible = true,
      x = 16, y = HEIGHT - 3, w = 16, h = 3,
      text = "Craft: OFF",
      action = function()
        craftingActive = not craftingActive
        requestRedraw()
      end
    },
    {
      id = "add", visible = true,
      x = 34, y = HEIGHT - 3, w = 10, h = 3,
      text = "Add",
      action = addItem
    },
    {
      id = "edit", visible = true,
      x = 46, y = HEIGHT - 3, w = 10, h = 3,
      text = "Edit",
      action = editItem
    },
    {
      id = "remove", visible = true,
      x = 58, y = HEIGHT - 3, w = 12, h = 3,
      text = "Remove",
      action = removeItem
    },
    {
      id = "sort", visible = true,
      x = 72, y = HEIGHT - 3, w = 10, h = 3,
      text = "Sort",
      action = function()
        if sortCriteria == "name" then
          sortCriteria = "category"
        elseif sortCriteria == "category" then
          sortCriteria = "count"
        else
          sortCriteria = "name"
        end
        table.insert(craftLogs, { text = "[Edit] Сортировка по " .. sortCriteriaDisplay[sortCriteria], color = COLOR_MEDIUM })
        updateContent()
        requestRedraw()
      end
    },
    {
      id = "logs", visible = true,
      x = 84, y = HEIGHT - 3, w = 10, h = 3,
      text = "Logs: OFF",
      action = function()
        logsVisible = not logsVisible
        if logsVisible then
          fullRedraw()  -- однократное обновление для отображения логового окна
          logTimerId = event.timer(1.0, function() drawFloatingLogs() end, math.huge)
        else
          if logTimerId then
            event.cancel(logTimerId)
            logTimerId = nil
          end
          fullRedraw()  -- восстановление основного UI
        end
        requestRedraw()
      end
    }
  }
end

---------------------- ИНИЦИАЛИЗАЦИЯ СИСТЕМЫ ----------------------
local touchEvent, scrollEvent
local function LoadSystem()
  dataItems = oc.loadf(dataFile) or {}
  updateContent()
  initButtons()
  touchEvent = event.listen("touch", onTouch)
  scrollEvent = event.listen("scroll", onScroll)
  dataQueue = dataItems
  fullRedraw()
  return true
end

---------------------- РЕЖИМ ОБНОВЛЕНИЯ ЧЕРЕЗ ТАЙМЕРЫ ----------------------
local craftTimer = event.timer(1.0, autoCraftCheck, math.huge)    -- Автокрафт: 1.0 с
local uiTimer = event.timer(0.5, function()
  if not logsVisible and redrawNeeded then
    fullRedraw()
    redrawNeeded = false
  end
end, math.huge)
-- Логовое окно обновляется своим таймером (logTimerId) только когда активно.

---------------------- ГЛАВНЫЙ ЦИКЛ ----------------------
LoadSystem()
while running do
  event.pull(0.5)
end

-- Для завершения (при необходимости) не забудьте отменить таймеры:
-- event.cancel(craftTimer)
-- event.cancel(uiTimer)
-- if logTimerId then event.cancel(logTimerId) end
