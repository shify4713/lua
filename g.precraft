-- PreCraft Auto-Crafting Tool (OpenOS 1.6.1, Lua 5.2)
-- Статичная часть (заголовок, рамки, сортировочная метка) отрисовывается по собыствию.
-- Обновление таблицы (ячейки, скроллбар) выполняется быстро без мерцаний.
-- Каждые 20 сек обновляются количественные данные и запускается автокрафт.

local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode")
local term = require("term")
local gpu = component.gpu
local me = component.me_interface

-- Загрузка библиотеки oc.lua, если отсутствует
local libURL = "https://raw.githubusercontent.com/shify4713/lua/refs/heads/main/g.lib-precraft"
local libPath = "/lib/oc.lua"
if not fs.exists(libPath) then
  shell.execute("wget " .. libURL .. " " .. libPath)
end
local oc = require("oc")

-- Работа с файлом данных
local dataFile = "/home/BD.txt"
if not fs.exists(dataFile) then
  oc.savef(dataFile, {})
end

--------------------------------------------------------------------
-- ГЛОБАЛЫЕ ПЕРЕМЕННЫЕ
--------------------------------------------------------------------
local ADM = { ["LiwMorgan"] = true } -- Только LiwMorgan имеет доступ!
local dataItems = {}         -- Список предметов
local dataQueue = {}         -- Очередь автокрафта (те же данные)
local scroll = 1             -- Текущая позиция таблицы
local posSelect = nil        -- Выбранная строка таблицы
local craftingActive = false -- Режим автокрафта (ON/OFF)
local running = true         -- Флаг работы программы
local maxScroll = 1          -- Максимальное смещение таблицы
local content = {}           -- Отфильтрованный/отсортированный список
local sortCriteria = "name"  -- Возможные: "name", "category", "count"
local sortCriteriaDisplay = { name = "Имя", category = "Категория", count = "Количество" }
local craftLogs = {}         -- Массив логов
local MAX_LOGS = 100         -- Максимальное число логов
local logsVisible = false    -- Флаг отображения логового окна
local buttons = {}           -- Таблица кнопок
local logTimerId = nil       -- ID таймера логового окна
local lastCountUpdate = 0    -- Время последнего обновления количеств
local COUNT_UPDATE_INTERVAL = 20  -- Интервал обновления (сек)
local inputActive = false    -- Флаг блокировки обновлений во время ввода
local cachedCounts = {}      -- Кэш количественных значений

--------------------------------------------------------------------
-- РАЗМЕРЫ UI
--------------------------------------------------------------------
local WIDTH, HEIGHT = 160, 50
gpu.setResolution(WIDTH, HEIGHT)
local TABLE_HEADER_Y = 4                           -- Строка заголовка таблицы
local TABLE_BODY_START_Y = TABLE_HEADER_Y + 2        -- Начало body таблицы
local BUTTONS_HEIGHT = 3                           -- Высота кнопок
local BUTTONS_Y = HEIGHT - BUTTONS_HEIGHT + 1        -- Расположение кнопок (нижняя часть)
local VISIBLE_TABLE_ROWS = BUTTONS_Y - TABLE_BODY_START_Y  -- Кол-во видимых строк
local TABLE_X = 2                                  -- Начало таблицы слева
local TABLE_WIDTH = 157                            -- Полная ширина таблицы

-- Ширины столбцов
local COL_WIDTH_IDX    = 5
local COL_WIDTH_NAME   = 94
local COL_WIDTH_CAT    = 15
local COL_WIDTH_REQ    = 12
local COL_WIDTH_ME     = 12
local COL_WIDTH_CRAFT  = 12

--------------------------------------------------------------------
-- ПАЛИТРА ЦВЕТОВ
--------------------------------------------------------------------
local BG_MAIN             = 0x1A1A1A   -- Тёмно-серый
local CTEXT               = 0xDADADA   -- Светло-серый текст
local COLOR_BUTTON        = 0x4A90E2   -- Синий для кнопок
local COLOR_BUTTON_TEXT   = 0xFFFFFF   -- Белый текст на кнопках
-- Изменяем цвет выделения на ярко-оранжевый:
local COLOR_HIGHLIGHT     = 0xFF4500   -- Новый цвет выделенного предмета
local COLOR_LOW           = 0xFF4C4C   -- Красный для ошибок / недостатка
local COLOR_MEDIUM        = 0xFFCC00   -- Желтый для промежуточного состояния
local COLOR_HIGH          = 0x00FF66   -- Зелёный для позитивного состояния
local BG_ALT              = 0x2A2A2A   -- Альтернативный фон для четных строк
local COLOR_HEADER_BG     = 0x333333   -- Фон заголовка
local COLOR_LOG_BG        = 0x3A3A3A   -- Фон логового окна
local COLOR_BUTTON_BORDER = 0x444444   -- Граница кнопок

--------------------------------------------------------------------
-- ФУНКЦИИ ВЫРАВНЕНИЯ ТЕКСТА
--------------------------------------------------------------------
local function padOrTrim(text, width)
  text = tostring(text)
  local len = unicode.len(text)
  if len > width then
    return unicode.sub(text, 1, width)
  else
    return text .. string.rep(" ", width - len)
  end
end

local function padOrTrimRight(text, width)
  text = tostring(text)
  local len = unicode.len(text)
  if len > width then
    return unicode.sub(text, 1, width)
  else
    return string.rep(" ", width - len) .. text
  end
end

local function padCenter(text, width)
  text = tostring(text)
  local len = unicode.len(text)
  if len >= width then
    return unicode.sub(text, 1, width)
  end
  local left = math.floor((width - len) / 2)
  local right = width - len - left
  return string.rep(" ", left) .. text .. string.rep(" ", right)
end

--------------------------------------------------------------------
-- РИСОВАНИЕ ГРАНИЦЫ
--------------------------------------------------------------------
local function drawBorder(x, y, w, h, fgColor)
  fgColor = fgColor or CTEXT
  gpu.setForeground(fgColor)
  gpu.set(x, y, "┌" .. string.rep("─", w - 2) .. "┐")
  gpu.set(x, y + h - 1, "└" .. string.rep("─", w - 2) .. "┘")
  for i = y + 1, y + h - 2 do
    gpu.set(x, i, "│")
    gpu.set(x + w - 1, i, "│")
  end
end

--------------------------------------------------------------------
-- ОТРИСОВКА КНОПКИ
--------------------------------------------------------------------
local function drawCustomButton(x, y, w, h, bgColor, textColor, text)
  gpu.setBackground(bgColor)
  gpu.fill(x, y, w, h, " ")
  gpu.setForeground(COLOR_BUTTON_BORDER)
  drawBorder(x, y, w, h, COLOR_BUTTON_BORDER)
  gpu.setForeground(textColor)
  local textPosX = x + math.floor((w - unicode.len(text)) / 2)
  local textPosY = y + math.floor(h / 2)
  gpu.set(textPosX, textPosY, text)
end

--------------------------------------------------------------------
-- ОТРИСОВКА КНОПОК (динамическая)
--------------------------------------------------------------------
local function drawButtons()
  for _, button in ipairs(buttons) do
    if button.visible then
      local btnText = button.text
      if button.id == "craft" then
        btnText = "Craft: " .. (craftingActive and "ON" or "OFF")
      elseif button.id == "logs" then
        btnText = "Logs: " .. (logsVisible and "ON" or "OFF")
      end
      drawCustomButton(button.x, button.y, button.w, button.h, COLOR_BUTTON, COLOR_BUTTON_TEXT, btnText)
    end
  end
end

--------------------------------------------------------------------
-- СТАТИЧНЫЙ UI (заголовок, рамка, сортировка)
--------------------------------------------------------------------
local function drawStaticUI()
  gpu.setBackground(COLOR_HEADER_BG)
  gpu.fill(1, 1, WIDTH, 3, " ")
  local header = "PreCraft - Автокрафт предметов"
  local sortText = "Сортировка: " .. sortCriteriaDisplay[sortCriteria]
  gpu.setForeground(CTEXT)
  gpu.set(math.floor((WIDTH - unicode.len(header)) / 2), 1, header)
  gpu.set(2, 2, sortText)
  
  local tableBorderHeight = BUTTONS_Y - (TABLE_HEADER_Y - 1)
  drawBorder(TABLE_X - 1, TABLE_HEADER_Y - 1, TABLE_WIDTH + 2, tableBorderHeight, COLOR_BUTTON)
  
  local headerStr = "|" .. padCenter("Idx", COL_WIDTH_IDX) .. "|" ..
                            padCenter("Name", COL_WIDTH_NAME) .. "|" ..
                            padCenter("Категория", COL_WIDTH_CAT) .. "|" ..
                            padCenter("Req", COL_WIDTH_REQ) .. "|" ..
                            padCenter("ME", COL_WIDTH_ME) .. "|" ..
                            padCenter("Craft", COL_WIDTH_CRAFT) .. "|"
  gpu.setBackground(COLOR_HEADER_BG)
  gpu.setForeground(CTEXT)
  gpu.set(TABLE_X, TABLE_HEADER_Y, headerStr)
  gpu.set(TABLE_X, TABLE_HEADER_Y + 1, string.rep("─", TABLE_WIDTH))
end

local function updateSortLabel()
  local sortText = "Сортировка: " .. sortCriteriaDisplay[sortCriteria]
  gpu.setBackground(COLOR_HEADER_BG)
  gpu.fill(2, 2, 25, 1, " ")
  gpu.setForeground(CTEXT)
  gpu.set(2, 2, sortText)
end

--------------------------------------------------------------------
-- ОБНОВЛЕНИЕ ОБЛАСТЕЙ (таблица и кнопки)
--------------------------------------------------------------------
local function drawTableSection()
  for row = TABLE_BODY_START_Y, BUTTONS_Y - 1 do
    gpu.setBackground(BG_MAIN)
    gpu.fill(TABLE_X, row, TABLE_WIDTH, 1, " ")
  end
  
  for i = scroll, math.min(#content, scroll + VISIBLE_TABLE_ROWS - 1) do
    local rowPos = TABLE_BODY_START_Y + (i - scroll)
    local record = content[i]
    local item = record.item
    local key = item.id .. ":" .. item.dmg
    local currentQty = cachedCounts[key] or 0
    local reqCount = tonumber(item.count) or 0
    local diff = reqCount - currentQty
    local colorText = CTEXT
    if currentQty >= reqCount then
      colorText = COLOR_HIGH
    elseif diff >= math.floor(reqCount * 0.5) then
      colorText = COLOR_LOW
    else
      colorText = COLOR_MEDIUM
    end
    local rowBg = ((i - scroll) % 2 == 0) and BG_MAIN or BG_ALT
    if posSelect and (i == posSelect) then
      rowBg = COLOR_HIGHLIGHT
    end
    gpu.setBackground(rowBg)
    local rowStr = "|" .. padOrTrimRight(i, COL_WIDTH_IDX) .. "|" ..
                         padOrTrim(item.name, COL_WIDTH_NAME) .. "|" ..
                         padOrTrim(item.category or "", COL_WIDTH_CAT) .. "|" ..
                         padOrTrimRight(reqCount, COL_WIDTH_REQ) .. "|" ..
                         padOrTrimRight(currentQty, COL_WIDTH_ME) .. "|" ..
                         padOrTrimRight(item.craftSize or 0, COL_WIDTH_CRAFT) .."|"
    gpu.setForeground(colorText)
    gpu.set(TABLE_X, rowPos, rowStr)
  end
  
  local x = TABLE_X + TABLE_WIDTH
  local y = TABLE_BODY_START_Y
  local height = VISIBLE_TABLE_ROWS
  local total = #content
  local trackColor = COLOR_BUTTON
  local indicatorColor = COLOR_HIGHLIGHT
  gpu.setBackground(trackColor)
  for i = y, y + height - 1 do
    gpu.set(x, i, "│")
  end
  if total > VISIBLE_TABLE_ROWS then
    local barHeight = math.max(1, math.floor(height * height / total))
    local pos = math.floor((scroll - 1) * (height - barHeight) / (total - VISIBLE_TABLE_ROWS)) + y
    gpu.setBackground(indicatorColor)
    for i = pos, pos + barHeight - 1 do
      if i >= y and i < y + height then
        gpu.set(x, i, "█")
      end
    end
  else
    gpu.setBackground(indicatorColor)
    for i = y, y + height - 1 do
      gpu.set(x, i, "█")
    end
  end
end

local function drawButtonSection()
  gpu.setBackground(BG_MAIN)
  gpu.fill(1, BUTTONS_Y, WIDTH, BUTTONS_HEIGHT, " ")
  drawButtons()
end

local function redrawUI()
  if logsVisible then
    -- При отображении логов очищаем экран полностью
    gpu.setBackground(BG_MAIN)
    gpu.fill(1, 1, WIDTH, HEIGHT, " ")
    drawFloatingLogs()
  else
    drawStaticUI()
    drawTableSection()
    drawButtonSection()
  end
end

--------------------------------------------------------------------
-- ОБНОВЛЕНИЕ ДАННЫХ И КЭША
--------------------------------------------------------------------
local function updateContent()
  content = {}
  for i, item in ipairs(dataItems) do
    table.insert(content, { idx = i, item = item })
  end
  if sortCriteria == "name" then
    table.sort(content, function(a, b)
      return (a.item.name or ""):lower() < (b.item.name or ""):lower()
    end)
  elseif sortCriteria == "category" then
    table.sort(content, function(a, b)
      return (a.item.category or ""):lower() < (b.item.category or ""):lower()
    end)
  elseif sortCriteria == "count" then
    table.sort(content, function(a, b)
      return (tonumber(a.item.count) or 0) < (tonumber(b.item.count) or 0)
    end)
  end
  maxScroll = math.max(1, #content - VISIBLE_TABLE_ROWS + 1)
  if scroll > maxScroll then scroll = maxScroll end
end

local function updateCachedCounts()
  for i, item in ipairs(dataItems) do
    local key = item.id .. ":" .. item.dmg
    local detail = me.getItemDetail({ id = item.id, dmg = item.dmg })
    if detail and detail.basic() then
      cachedCounts[key] = detail.basic().qty or 0
    else
      cachedCounts[key] = 0
    end
  end
end

--------------------------------------------------------------------
-- ОКНО ВВОДА
--------------------------------------------------------------------
local function inputOverlay(promptMessage)
  inputActive = true
  local boxW, boxH = 60, 3
  local boxX = math.floor((WIDTH - boxW) / 2)
  local boxY = math.floor((HEIGHT - boxH) / 2)
  drawBorder(boxX - 1, boxY - 1, boxW + 2, boxH + 2, COLOR_BUTTON)
  gpu.setBackground(BG_MAIN)
  gpu.fill(boxX, boxY, boxW, boxH, " ")
  gpu.setForeground(CTEXT)
  gpu.set(boxX + 2, boxY, promptMessage)
  term.setCursor(boxX + 2 + unicode.len(promptMessage) + 1, boxY)
  term.setCursorBlink(true)
  local input = term.read()
  term.setCursorBlink(false)
  inputActive = false
  redrawUI()
  return input:sub(1, -2)
end

--------------------------------------------------------------------
-- РАБОТА С ПРЕДМЕТАМИ
--------------------------------------------------------------------
local function addItem()
  local stack = me.getStackInSlot(1)
  if stack then
    local name = inputOverlay("Введите название:")
    local category = inputOverlay("Введите категорию:")
    local count = tonumber(inputOverlay("Введите требуемое число:"))
    local craftSize = tonumber(inputOverlay("Введите объём крафта:"))
    table.insert(dataItems, {
      name = name,
      category = category,
      id = stack.id,
      dmg = stack.dmg,
      count = count,
      craftSize = craftSize,
      cpu = 262144
    })
    oc.savef(dataFile, dataItems)
    addLog("[Add] Добавлен: " .. name, COLOR_MEDIUM)
  else
    inputOverlay("Предмет не установлен в 1-й слот! (Нажмите Enter)")
  end
  dataItems = oc.loadf(dataFile) or {}
  updateContent()
  scroll = 1
  posSelect = nil
  redrawUI()
end

local function removeItem()
  if posSelect then
    local orig = content[posSelect].idx
    table.remove(dataItems, orig)
    oc.savef(dataFile, dataItems)
    addLog("[Edit] Удалён: " .. content[posSelect].item.name, COLOR_LOW)
    posSelect = nil
    dataItems = oc.loadf(dataFile) or {}
    updateContent()
    redrawUI()
  end
end

local function editItem()
  if posSelect then
    local idx = content[posSelect].idx
    local item = dataItems[idx]
    local name = inputOverlay("Введите новое имя (текущее: " .. item.name .. "):")
    if name ~= "" then item.name = name end
    local cat = inputOverlay("Введите новую категорию (текущее: " .. (item.category or "") .. "):")
    if cat ~= "" then item.category = cat end
    local countStr = inputOverlay("Введите требуемое число (текущее: " .. item.count .. "):")
    if countStr ~= "" then
      local count = tonumber(countStr)
      if count then item.count = count end
    end
    local craftSizeStr = inputOverlay("Введите объём крафта (текущее: " .. item.craftSize .. "):")
    if craftSizeStr ~= "" then
      local craftSize = tonumber(craftSizeStr)
      if craftSize then item.craftSize = craftSize end
    end
    dataItems[idx] = item
    oc.savef(dataFile, dataItems)
    updateContent()
    addLog("[Edit] Изменён: " .. item.name, COLOR_MEDIUM)
    posSelect = nil
    redrawUI()
  end
end

--------------------------------------------------------------------
-- ЛОГИРОВАНИЕ
--------------------------------------------------------------------
local function addLog(msg, color)
  table.insert(craftLogs, { text = msg, color = color })
  if #craftLogs > MAX_LOGS then table.remove(craftLogs, 1) end
end

--------------------------------------------------------------------
-- АВТО-КРАФТ
--------------------------------------------------------------------
local function autoCraftCheck()
  if not craftingActive then return end
  
  local function logIfChanged(item, newMsg, newColor)
    if item.lastMsg ~= newMsg then
      addLog(newMsg, newColor)
      item.lastMsg = newMsg
    end
  end
  
  for i, item in ipairs(dataQueue) do
    if not item.craft or item.craft.isDone() or item.craft.isCanceled() then
      item.craft = nil
      local detail = me.getItemDetail({ id = item.id, dmg = item.dmg })
      if detail then
        local currentQty = (detail.basic() and detail.basic().qty) or 0
        local reqCount = tonumber(item.count) or 0
        local delta = reqCount - currentQty
        if delta > 0 then
          local batch = math.min(delta, tonumber(item.craftSize) or delta)
          local cpus = me.getCpus()
          local foundCPU = false
          for _, cpu in ipairs(cpus) do
            if not cpu.busy and cpu.storage == 262144 then
              local craftables = me.getCraftables({ name = item.id, damage = item.dmg })
              if craftables.n and craftables.n >= 1 then
                item.craft = craftables[1].request(batch, false, tostring(item.cpu))
                logIfChanged(item, "[Craft] Запуск " .. item.name .. " x" .. batch, COLOR_HIGH)
                foundCPU = true
                break
              else
                logIfChanged(item, "[Craft] " .. item.name .. " отсутствует рецепт", COLOR_LOW)
                foundCPU = true
                break
              end
            end
          end
          if not foundCPU then
            logIfChanged(item, "[Craft] Нет свободных CPU для " .. item.name, COLOR_LOW)
          end
        else
          item.lastMsg = nil
        end
      else
        logIfChanged(item, "[Craft] Нет данных по " .. item.name, COLOR_LOW)
      end
    end
  end
end

--------------------------------------------------------------------
-- ОБРАБОТКА СОБЫТИЙ
--------------------------------------------------------------------
local function onTouch(_, _, x, y, _, nick)
  if ADM[nick] then
    for _, button in ipairs(buttons) do
      if x >= button.x and x <= (button.x + button.w - 1) and
         y >= button.y and y <= (button.y + button.h - 1) then
        button.action()
        drawButtonSection()
        return true
      end
    end
    if x >= TABLE_X and x <= (TABLE_X + TABLE_WIDTH - 1) and
       y >= TABLE_BODY_START_Y and y < BUTTONS_Y then
      posSelect = scroll + (y - TABLE_BODY_START_Y)
      drawTableSection()
    end
  end
end

local function onScroll(_, _, _, _, dir, nick)
  if ADM[nick] then
    if dir == 1 and scroll > 1 then
      scroll = scroll - 1
    elseif dir == -1 and scroll < maxScroll then
      scroll = scroll + 1
    end
    drawTableSection()
  end
end

--------------------------------------------------------------------
-- ИНИЦИАЛИЗАЦИЯ КНОПОК
--------------------------------------------------------------------
local function initButtons()
  buttons = {
    {
      id = "craft", visible = true,
      x = 16, y = BUTTONS_Y, w = 16, h = BUTTONS_HEIGHT,
      text = "Craft: OFF",
      action = function()
        craftingActive = not craftingActive
        if craftingActive then
          addLog("[AutoCraft] Режим автокрафта включён", COLOR_MEDIUM)
        else
          addLog("[AutoCraft] Режим автокрафта выключён", COLOR_MEDIUM)
        end
        drawButtonSection()
      end
    },
    {
      id = "add", visible = true,
      x = 34, y = BUTTONS_Y, w = 10, h = BUTTONS_HEIGHT,
      text = "Add",
      action = addItem
    },
    {
      id = "edit", visible = true,
      x = 46, y = BUTTONS_Y, w = 10, h = BUTTONS_HEIGHT,
      text = "Edit",
      action = editItem
    },
    {
      id = "remove", visible = true,
      x = 58, y = BUTTONS_Y, w = 12, h = BUTTONS_HEIGHT,
      text = "Remove",
      action = removeItem
    },
    {
      id = "sort", visible = true,
      x = 72, y = BUTTONS_Y, w = 10, h = BUTTONS_HEIGHT,
      text = "Sort",
      action = function()
        if sortCriteria == "name" then
          sortCriteria = "category"
        elseif sortCriteria == "category" then
          sortCriteria = "count"
        else
          sortCriteria = "name"
        end
        addLog("[Edit] Сортировка по " .. sortCriteriaDisplay[sortCriteria], COLOR_MEDIUM)
        updateContent()
        updateSortLabel()
        drawTableSection()
        drawButtonSection()
      end
    },
    {
      id = "logs", visible = true,
      x = 84, y = BUTTONS_Y, w = 12, h = BUTTONS_HEIGHT,
      text = "Logs: OFF",
      action = function()
        logsVisible = not logsVisible
        if logsVisible then
          if logTimerId then event.cancel(logTimerId) end
          -- Полностью очищаем экран и отображаем логовое окно сразу
          gpu.setBackground(BG_MAIN)
          gpu.fill(1, 1, WIDTH, HEIGHT, " ")
          drawFloatingLogs()
          logTimerId = event.timer(0.2, function() drawFloatingLogs() end, math.huge)
        else
          if logTimerId then event.cancel(logTimerId) logTimerId = nil end
          redrawUI()
        end
      end
    },
  }
end

--------------------------------------------------------------------
-- ЛОГОВОЕ ОКНО
--------------------------------------------------------------------
local function drawFloatingLogs()
  local overlayWidth = 70
  local overlayHeight = 20
  local overlayX = math.floor((WIDTH - overlayWidth) / 2)
  local overlayY = math.floor((HEIGHT - overlayHeight) / 2)
  drawBorder(overlayX - 1, overlayY - 1, overlayWidth + 2, overlayHeight + 2, COLOR_BUTTON)
  gpu.setBackground(COLOR_LOG_BG)
  gpu.fill(overlayX, overlayY, overlayWidth, overlayHeight, " ")
  local logY = overlayY
  local startIdx = math.max(1, #craftLogs - overlayHeight + 1)
  for i = startIdx, #craftLogs do
    local log = craftLogs[i]
    local logText = log.text
    if unicode.len(logText) > overlayWidth - 2 then
      logText = unicode.sub(logText, 1, overlayWidth - 2)
    end
    gpu.setForeground(log.color)
    gpu.set(overlayX + 1, logY, logText)
    logY = logY + 1
  end
end

--------------------------------------------------------------------
-- ИНИЦИАЛИЗАЦИЯ СИСТЕМЫ
--------------------------------------------------------------------
local touchEvent, scrollEvent
local function LoadSystem()
  dataItems = oc.loadf(dataFile) or {}
  updateContent()
  initButtons()
  touchEvent = event.listen("touch", onTouch)
  scrollEvent = event.listen("scroll", onScroll)
  dataQueue = dataItems
  redrawUI()
  updateCachedCounts()
  lastCountUpdate = os.time()
  return true
end

--------------------------------------------------------------------
-- ФОН. ОБНОВЛЕНИЕ (каждые 20 сек для количеств)
--------------------------------------------------------------------
local function checkBackgroundUpdate()
  if inputActive then return end
  local now = os.time()
  if now - lastCountUpdate >= COUNT_UPDATE_INTERVAL then
    updateCachedCounts()
    lastCountUpdate = now
    if not logsVisible then drawTableSection() end
  end
end

local backgroundUpdateTimer = event.timer(1.0, checkBackgroundUpdate, math.huge)
local craftTimer = event.timer(1.0, autoCraftCheck, math.huge)

--------------------------------------------------------------------
-- ГЛАВНЫЙ ЦИКЛ
--------------------------------------------------------------------
LoadSystem()
while running do
  event.pull(0.01)
end
