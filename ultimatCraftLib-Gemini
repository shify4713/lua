--wget -f https://raw.githubusercontent.com/shify4713/lua/main/ultimateOC.lua /lib/ultimateOC.lua
--wget -f https://raw.githubusercontent.com/shify4713/lua/refs/heads/main/autoCraftUltimate.lua /home/autoCraftUltimate.lua
-- ultimateOC.lua - Улучшенная библиотека для визуала OpenComputers
local fs = require("filesystem")
local unicode = require("unicode")
local gpu = require("component").gpu
local serialization = require("serialization") -- Explicitly require for safety

local M = {}

-- Безопасное сохранение таблицы (быстрее и надёжнее)
function M.savef(path, tbl)
    local ok, ser = pcall(serialization.serialize, tbl)
    if not ok then error("Ошибка сериализации: "..tostring(ser)) end
    
    local f, err_open = io.open(path, "w")
    if not f then error("Не могу открыть файл для записи: ".. tostring(err_open)) end
    
    local write_ok, err_write = f:write(ser)
    if not write_ok then
        f:close() -- Attempt to close even on write error
        error("Ошибка записи в файл: " .. tostring(err_write))
    end
    
    local close_ok, err_close = f:close()
    if not close_ok then
        -- Log or handle close error if necessary, though data is likely written
        -- For simplicity, we might not error out here if write was successful.
    end
end

function M.loadf(path)
    if not fs.exists(path) then return {} end -- Return empty table if file doesn't exist
    
    local f, err_open = io.open(path, "r")
    if not f then error("Не могу открыть файл для чтения: ".. tostring(err_open)) end
    
    local data, err_read = f:read("*a")
    if not data and err_read then -- Check if read failed
        f:close()
        error("Ошибка чтения файла: " .. tostring(err_read))
    end
    
    f:close() -- Close file after reading
    
    if data == "" or data == nil then return {} end -- Handle empty file case

    local ok, tbl = pcall(serialization.unserialize, data)
    if not ok then error("Ошибка десериализации: "..tostring(tbl)) end
    
    return tbl or {} -- Ensure a table is returned
end

-- Гибкий фильтр предметов по подстроке (поиск не зависит от регистра)
function M.filterItems(tbl, query)
    if not query or query == "" then return tbl end
    local res = {}
    query = unicode.lower(query)
    for i, item in ipairs(tbl) do
        if item.name and unicode.lower(item.name):find(query, 1, true) then
            table.insert(res, item)
        end
    end
    return res
end

-- Закруглённый прямоугольник c опциональной цветной рамкой
function M.roundRect(x, y, w, h, borderColor, fillColor)
    local currentBg = gpu.getBackground() -- Save current background
    borderColor = borderColor or 0x44475a
    
    -- Заливка
    if fillColor then
        gpu.setBackground(fillColor)
        gpu.fill(x, y, w, h, " ") -- Fill the entire area first
    else -- If no fill color, ensure background is cleared if it's part of a larger draw
        gpu.setBackground(currentBg) -- Or a default clear color
        gpu.fill(x, y, w, h, " ")
    end
    
    -- Рамка
    gpu.setForeground(borderColor)
    if w > 1 and h > 1 then -- Only draw corners and lines if size allows
        gpu.set(x+1, y, string.rep("─", w-2))
        gpu.set(x+1, y+h-1, string.rep("─", w-2))
        for i = y+1, y+h-2 do
            gpu.set(x, i, "│")
            gpu.set(x+w-1, i, "│")
        end
        gpu.set(x, y, "╭")
        gpu.set(x+w-1, y, "╮")
        gpu.set(x, y+h-1, "╰")
        gpu.set(x+w-1, y+h-1, "╯")
    elseif w == 1 and h > 1 then -- Vertical line
         for i = y, y+h-1 do gpu.set(x,i,"│") end
    elseif h == 1 and w > 1 then -- Horizontal line
         for i = x, x+w-1 do gpu.set(i,y,"─") end
    elseif w == 1 and h == 1 then -- Single point
         gpu.set(x,y,"·")
    end
    gpu.setBackground(currentBg) -- Restore original background
end

-- Прогресс-бар (цветной)
function M.progressBar(x, y, w, percent, fg, bg)
    local currentBg = gpu.getBackground()
    fg = fg or 0x50FA7B
    bg = bg or 0x44475a
    
    gpu.setBackground(bg)
    gpu.fill(x, y, w, 1, " ")
    
    local filledWidth = math.max(0, math.floor(w * (percent or 0)))
    if filledWidth > 0 then
        gpu.setBackground(fg)
        gpu.fill(x, y, filledWidth, 1, " ")
    end
    
    gpu.setBackground(currentBg)
end

-- Анимированная кнопка (с закруглением, цветами и "нажатием")
function M.animatedButton(x, y, w, h, text, active, baseColor, hoverColor, textColor)
    local currentBg = gpu.getBackground()
    local currentFg = gpu.getForeground()

    baseColor = baseColor or 0x00BFFF
    hoverColor = hoverColor or 0x1E90FF
    textColor = textColor or 0xFFFFFF
    
    local effectiveColor = active and hoverColor or baseColor
    
    M.roundRect(x, y, w, h, effectiveColor, effectiveColor) -- Use effectiveColor for both border and fill
    
    gpu.setForeground(textColor)
    -- Center text, ensuring it fits
    local textLen = unicode.len(text)
    local textX = x + math.floor((w - textLen) / 2)
    local textY = y + math.floor((h - 1) / 2) -- Assuming single line text
    
    if textX < x + 1 then textX = x + 1 end -- Ensure text doesn't start before button edge
    if textX + textLen > x + w -1 then -- If text is too long, truncate (simple truncation)
        text = unicode.sub(text, 1, math.max(0, (x+w-1) - textX)) .. (textLen > ((x+w-1)-textX) and "…" or "")
    end

    gpu.set(textX, textY, text)
    
    gpu.setBackground(currentBg)
    gpu.setForeground(currentFg)
end

-- Тень под текстом
function M.drawText(x, y, text, color, shadow)
    local currentFg = gpu.getForeground()
    color = color or 0xF8F8F2
    
    if shadow then
        gpu.setForeground(0x282A36) -- Shadow color
        gpu.set(x+1, y+1, text)
    end
    
    gpu.setForeground(color)
    gpu.set(x, y, text)
    gpu.setForeground(currentFg) -- Restore original foreground
end

-- Быстрый логгер: добавляет строку в массив (до 50 записей), без времени
function M.addLog(logsTable, text, lvl)
    lvl = lvl or "INFO"
    -- Время удалено из логов по запросу
    local t = string.format("[%s] %s", lvl, text)
    table.insert(logsTable, t)
    while #logsTable > 50 do table.remove(logsTable, 1) end
end

-- Рисует список логов (на экране)
function M.drawLogs(x, y, logsTable, count, color)
    local currentFg = gpu.getForeground()
    count = count or 10
    color = color or 0x8BE9FD
    local logY = y
    
    -- Calculate how many logs to actually display based on available logs and requested count
    local startIndex = math.max(1, #logsTable - count + 1)
    
    for i = startIndex, #logsTable do
        -- Call M.drawText to ensure consistent text drawing (e.g. if it handles shadows or other effects)
        -- However, the original just set color and called gpu.set. For simplicity and directness:
        gpu.setForeground(color)
        gpu.set(x, logY, logsTable[i])
        logY = logY + 1
    end
    gpu.setForeground(currentFg)
end

-- Быстрый автоматический скролл по массиву (возвращает подсекцию)
function M.scrollArray(tbl, scroll, perPage)
    local res = {}
    perPage = perPage or 20
    -- Ensure scroll is within valid bounds
    scroll = math.max(1, math.min(scroll, math.max(1, #tbl - perPage + 1)))
    
    local endIndex = math.min(#tbl, scroll + perPage - 1)
    for i = scroll, endIndex do
        table.insert(res, tbl[i])
    end
    return res, scroll -- Return the adjusted scroll value as well
end

-- Цветной выделенный элемент (фон+текст)
function M.selectLine(x, y, w, text, selected, color, selColor, textColor)
    local currentBg = gpu.getBackground()
    local currentFg = gpu.getForeground()

    color = color or 0x23262E      -- Default background for non-selected
    selColor = selColor or 0x00BFFF -- Default background for selected
    textColor = textColor or 0xF8F8F2 -- Default text color
    
    gpu.setBackground(selected and selColor or color)
    gpu.setForeground(textColor)
    
    gpu.fill(x, y, w, 1, " ") -- Fill the line with the background color
    
    -- Truncate text if it's too long for the width (add padding of 1 char on left)
    local maxTextWidth = w - 1 
    local displayText = text
    if unicode.len(text) > maxTextWidth then
        displayText = unicode.sub(text, 1, math.max(0, maxTextWidth - 1)) .. "…"
    end
    gpu.set(x+1, y, displayText) -- Draw text with 1 char padding from left
    
    gpu.setBackground(currentBg)
    gpu.setForeground(currentFg)
end

return M
