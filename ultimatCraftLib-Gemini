-- ultimateOC.lua - Улучшенная библиотека для визуала OpenComputers
-- Версия: 1.0.1
-- Автор: shify4713 (пользователь GitHub)

local fs = require("filesystem")
local unicode = require("unicode")
local gpu = component.gpu -- Получаем компонент GPU напрямую

local M = {}

-- Безопасное сохранение таблицы (быстрее и надёжнее)
-- Использует библиотеку serialization для преобразования таблицы в строку
function M.savef(path, tbl)
    local ok, ser = pcall(require("serialization").serialize, tbl)
    if not ok then error("Ошибка сериализации: "..tostring(ser)) end -- Обработка ошибок сериализации
    local f, err = io.open(path, "w") -- Открываем файл для записи
    if not f then error("Не могу открыть файл для записи: "..err) end -- Обработка ошибок открытия файла
    f:write(ser) -- Записываем сериализованные данные
    f:close()    -- Закрываем файл
end

-- Безопасная загрузка таблицы из файла
-- Использует библиотеку serialization для преобразования строки в таблицу
function M.loadf(path)
    if not fs.exists(path) then return {} end -- Если файл не существует, возвращаем пустую таблицу
    local f, err = io.open(path, "r") -- Открываем файл для чтения
    if not f then error("Не могу открыть файл: "..err) end -- Обработка ошибок открытия файла
    local data = f:read("*a") -- Читаем все содержимое файла
    f:close()                 -- Закрываем файл
    local ok, tbl = pcall(require("serialization").unserialize, data) -- Десериализуем данные
    if not ok then error("Ошибка десериализации: "..tostring(tbl)) end -- Обработка ошибок десериализации
    return tbl or {} -- Возвращаем десериализованную таблицу или пустую, если она nil
end

-- Гибкий фильтр предметов по подстроке (поиск не зависит от регистра)
-- Возвращает новую таблицу с отфильтрованными элементами
function M.filterItems(tbl, query)
    if not query or query == "" then return tbl end -- Если запрос пуст, возвращаем исходную таблицу
    local res = {}
    query = unicode.lower(query) -- Преобразуем запрос в нижний регистр для поиска без учета регистра
    for i, item in ipairs(tbl) do
        -- Проверяем, есть ли у элемента поле 'name' и содержит ли оно запрос
        if item.name and unicode.lower(item.name):find(query, 1, true) then
            table.insert(res, item) -- Добавляем элемент в результат
        end
    end
    return res
end

-- Закруглённый прямоугольник c опциональной цветной рамкой
function M.roundRect(x, y, w, h, borderColor, fillColor)
    -- Проверяем доступность GPU
    if not gpu or not gpu.isAvailable or not gpu:isAvailable() then return end

    borderColor = borderColor or 0x44475a -- Цвет рамки по умолчанию
    fillColor = fillColor or 0x1B1D23   -- Цвет заливки по умолчанию

    -- Заливка внутренней части прямоугольника
    if fillColor then
        gpu.setBackground(fillColor)
        gpu.fill(x, y, w, h, " ")
    end

    -- Отрисовка рамки
    gpu.setForeground(borderColor)
    -- Горизонтальные линии
    gpu.set(x+1, y, string.rep("─", w-2))
    gpu.set(x+1, y+h-1, string.rep("─", w-2))
    -- Вертикальные линии
    for i = y+1, y+h-2 do
        gpu.set(x, i, "│")
        gpu.set(x+w-1, i, "│")
    end
    -- Углы
    gpu.set(x, y, "╭")
    gpu.set(x+w-1, y, "╮")
    gpu.set(x, y+h-1, "╰")
    gpu.set(x+w-1, y+h-1, "╯")
end

-- Прогресс-бар (цветной)
function M.progressBar(x, y, w, percent, fg, bg)
    -- Проверяем доступность GPU
    if not gpu or not gpu.isAvailable or not gpu:isAvailable() then return end

    fg = fg or 0x50FA7B -- Цвет переднего плана (заполненная часть) по умолчанию
    bg = bg or 0x44475a -- Цвет заднего плана (пустая часть) по умолчанию

    gpu.setBackground(bg)
    gpu.fill(x, y, w, 1, " ") -- Заливаем весь бар фоновым цветом
    gpu.setBackground(fg)
    gpu.fill(x, y, math.max(0, math.floor(w * percent)), 1, " ") -- Заливаем заполненную часть
    gpu.setBackground(0x1B1D23) -- Возвращаем фоновый цвет по умолчанию
end

-- Анимированная кнопка (с закруглением, цветами и "нажатием")
function M.animatedButton(x, y, w, h, text, active, baseColor, hoverColor, textColor)
    -- Проверяем доступность GPU
    if not gpu or not gpu.isAvailable or not gpu:isAvailable() then return end

    baseColor = baseColor or 0x00BFFF -- Базовый цвет кнопки по умолчанию
    hoverColor = hoverColor or 0x1E90FF -- Цвет кнопки при наведении по умолчанию
    textColor = textColor or 0xFFFFFF   -- Цвет текста кнопки по умолчанию

    local color = active and hoverColor or baseColor -- Выбираем цвет в зависимости от состояния (активна/неактивна)
    M.roundRect(x, y, w, h, color, color) -- Рисуем закругленный прямоугольник (рамка и заливка одним цветом)
    gpu.setForeground(textColor)
    -- Размещаем текст по центру кнопки
    gpu.set(x + math.floor((w-unicode.len(text))/2), y + math.floor(h/2), text)
    gpu.setBackground(0x1B1D23) -- Возвращаем фоновый цвет по умолчанию
end

-- Отрисовка текста с опциональной тенью
function M.drawText(x, y, text, color, shadow)
    -- Проверяем доступность GPU
    if not gpu or not gpu.isAvailable or not gpu:isAvailable() then return end

    color = color or 0xF8F8F2 -- Цвет текста по умолчанию
    if shadow then
        gpu.setForeground(0x282A36) -- Цвет тени
        gpu.set(x+1, y+1, text)     -- Отрисовка тени со смещением
    end
    gpu.setForeground(color) -- Цвет текста
    gpu.set(x, y, text)      -- Отрисовка текста
end

-- Быстрый логгер: добавляет строку в массив (до 50 записей)
-- Добавляет временную метку к каждой записи
function M.addLog(logs, text, lvl)
    lvl = lvl or "INFO" -- Уровень лога по умолчанию
    local now = os.date("!*t", os.time()+3*3600) -- Получаем текущее время (МСК)
    local t = string.format("[%02d:%02d:%02d][%s] %s", now.hour, now.min, now.sec, lvl, text) -- Форматируем строку лога
    table.insert(logs, t) -- Добавляем запись в массив логов
    while #logs > 50 do table.remove(logs, 1) end -- Удаляем старые записи, если их слишком много
end

-- Рисует список логов на экране
function M.drawLogs(x, y, logs, count, color)
    -- Проверяем доступность GPU
    if not gpu or not gpu.isAvailable or not gpu:isAvailable() then return end

    count = count or 10 -- Количество отображаемых записей лога по умолчанию
    color = color or 0x8BE9FD -- Цвет текста лога по умолчанию
    local logY = y
    -- Отрисовываем последние 'count' записей лога
    for i = math.max(1,#logs-count+1), #logs do
        M.drawText(x, logY, logs[i], color)
        logY = logY + 1 -- Переходим на следующую строку
    end
end

-- Быстрый автоматический скролл по массиву
-- Возвращает подмножество массива, соответствующее текущей позиции прокрутки
function M.scrollArray(tbl, scroll, perPage)
    local res = {}
    perPage = perPage or 20 -- Количество элементов на странице по умолчанию
    scroll = math.max(1, math.min(scroll, math.max(1, #tbl-perPage+1))) -- Корректируем позицию прокрутки
    for i=scroll, math.min(#tbl, scroll+perPage-1) do
        res[#res+1] = tbl[i] -- Добавляем элементы в результат
    end
    return res
end

-- Цветной выделенный элемент (фон+текст)
-- Используется для отрисовки строк в списке с выделением
function M.selectLine(x, y, w, text, selected, color, selColor, textColor)
    -- Проверяем доступность GPU
    if not gpu or not gpu.isAvailable or not gpu:isAvailable() then return end

    color = color or 0x23262E     -- Базовый цвет фона по умолчанию
    selColor = selColor or 0x00BFFF -- Цвет фона при выделении по умолчанию
    textColor = textColor or 0xF8F8F2 -- Цвет текста по умолчанию

    gpu.setBackground(selected and selColor or color) -- Выбираем цвет фона
    gpu.setForeground(textColor)                     -- Устанавливаем цвет текста
    gpu.fill(x, y, w, 1, " ")                        -- Заливаем строку фоновым цветом
    gpu.set(x+1, y, text)                            -- Отрисовываем текст
    gpu.setBackground(0x1B1D23)                      -- Возвращаем фоновый цвет по умолчанию
end

return M
