local fs = require("filesystem")
local unicode = require("unicode")
local gpu = require("component").gpu
local serialization = require("serialization") -- ПЕРЕМЕЩЕНО СЮДА: загружается один раз при старте

local M = {}

-- Безопасное сохранение таблицы (быстрее и надёжнее)
function M.savef(path, tbl)
    local ok, ser = pcall(serialization.serialize, tbl) -- Используем уже загруженную библиотеку
    if not ok then error("Ошибка сериализации: "..tostring(ser)) end
    local f, err = io.open(path, "w")
    if not f then error("Не могу открыть файл для записи: "..err) end
    f:write(ser)
    f:close()
end

function M.loadf(path)
    if not fs.exists(path) then return {} end
    local f, err = io.open(path, "r")
    if not f then error("Не могу открыть файл: "..err) end
    local data = f:read("*a")
    f:close()
    local ok, tbl = pcall(serialization.unserialize, data) -- Используем уже загруженную библиотеку
    if not ok then error("Ошибка десериализации: "..tostring(tbl)) end
    return tbl or {}
end

-- Рисует текст с опциональной тенью
function M.drawText(x, y, text, color, shadow)
    local originalBg = gpu.getBackground() -- Сохраняем текущий фон
    color = color or 0xFFFFFF -- По умолчанию белый
    gpu.setForeground(color)
    if shadow then
        -- For shadow, we temporarily set background, then reset it
        gpu.setBackground(0x282A36) -- Цвет тени
        gpu.set(x+1, y+1, text)
        gpu.setBackground(originalBg) -- Restore original background
    end
    -- НЕ устанавливаем фон для основного текста. Вызывающая функция (например, drawItems) отвечает за фон.
    gpu.set(x, y, text)
end

-- Быстрый логгер: добавляет строку в массив (до 50 записей)
-- Информация о времени полностью удалена по запросу пользователя
function M.addLog(logs, text, lvl)
    lvl = lvl or "INFO"
    local t = string.format("[%s] %s", lvl, text)
    table.insert(logs, t)
    while #logs > 50 do table.remove(logs, 1) end
end

-- Рисует список логов (на экране)
function M.drawLogs(x, y, logs, count, color)
    count = count or 10
    color = color or 0x8BE9FD
    local logY = y
    for i = math.max(1,#logs-count+1), #logs do
        M.drawText(x, logY, logs[i], color)
        logY = logY + 1
    end
end

-- Рисует скругленный прямоугольник
function M.roundRect(x, y, w, h, borderColor, bgColor)
    gpu.setBackground(borderColor)
    gpu.fill(x, y, w, h, " ")
    gpu.setBackground(bgColor)
    gpu.fill(x+1, y+1, w-2, h-2, " ")
end

-- Рисует простую кнопку
function M.drawButton(x, y, w, h, text, buttonColor, textColor)
    buttonColor = buttonColor or 0x00BFFF
    textColor = textColor or 0xFFFFFF
    gpu.setBackground(buttonColor)
    gpu.fill(x, y, w, h, " ")
    gpu.setForeground(textColor)
    local textWidth = unicode.len(text)
    local textX = x + math.floor((w - textWidth) / 2)
    local textY = y + math.floor((h - 1) / 2)
    gpu.set(textX, textY, text)
end

-- Анимированная кнопка (упрощена до вызова drawButton для стабильности)
function M.animatedButton(x, y, w, h, text, hover, buttonColor, buttonActiveColor, textColor)
    -- Для стабильности и избежания мерцания, просто рисуем статичную кнопку.
    -- Состояние 'hover' игнорируется.
    M.drawButton(x, y, w, h, text, buttonColor, textColor)
end

-- Рисует полосу прогресса
function M.progressBar(x, y, w, progress)
    progress = math.max(0, math.min(1, progress)) -- Ограничиваем прогресс от 0 до 1
    local filledWidth = math.floor(w * progress)
    gpu.setBackground(0x50FA7B) -- Цвет прогресса
    gpu.fill(x, y, filledWidth, 1, " ")
    gpu.setBackground(0x44475a) -- Цвет фона для оставшейся части
    gpu.fill(x + filledWidth, y, w - filledWidth, 1, " ")
end

return M
