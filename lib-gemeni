-- lib-gemeni.txt
local component = require("component")
local unicode = require("unicode")
local term = require("term")
local fs = require("filesystem")

local g = component.gpu

local ultimateOC = {}

-- Функция для рисования текста с цветом и жирным начертанием
function ultimateOC.drawText(x, y, text, color, bold)
    g.setForeground(color or 0xFFFFFF)
    -- В OpenOS GPU.set не поддерживает напрямую жирный шрифт.
    -- Имитация жирного шрифта через повторное наложение или подчеркивание
    -- может приводить к "грязи" и миганию.
    -- Лучше просто выводить текст. Если нужна "жирность", используем другой цвет или просто выводим текст.
    -- term.setGraphicsMode(term.mode.bold) может работать в некоторых терминалах, но не универсально.
    g.set(x, y, text)
    -- Если всё же хочется какой-то акцент для "жирного", можно сделать так:
    -- if bold then
    --     g.setForeground(color and (color + 0x111111) or 0xFFFFFF) -- Делаем цвет чуть ярче
    --     g.set(x,y,text) -- Перерисовываем тем же текстом, но ярче
    -- end
end

-- Функция для рисования прямоугольника с закруглёнными углами
function ultimateOC.roundRect(x, y, w, h, borderColor, bgColor)
    g.setBackground(bgColor or 0x000000)
    g.fill(x, y, w, h, " ")
    g.setForeground(borderColor or 0xFFFFFF)
    -- Верхняя линия
    g.set(x, y, "╔" .. string.rep("═", w - 2) .. "╗")
    -- Нижняя линия
    g.set(x, y + h - 1, "╚" .. string.rep("═", w - 2) .. "╝")
    -- Боковые линии
    for i = 1, h - 2 do
        g.set(x, y + i, "║")
        g.set(x + w - 1, y + i, "║")
    end
end

-- Функция для анимированной кнопки (изменено: убран setBackground)
function ultimateOC.animatedButton(x, y, w, h, text, hover, bgColor, activeColor, textColor, subText, subTextColor)
    g.setForeground(textColor or 0xFFFFFF)
    local textLen = unicode.len(text)
    local tx = x + math.floor((w - textLen) / 2)
    g.set(tx, y + math.floor(h / 2), text)
    if subText and subText ~= "" then
        local subTextLen = unicode.len(subText)
        local subTx = x + math.floor((w - subTextLen) / 2)
        g.setForeground(subTextColor or textColor or 0xFFFFFF)
        g.set(subTx, y + math.floor(h / 2) + 1, subText)
    end
end

-- Функция для отрисовки логов (ИСПРАВЛЕНО)
function ultimateOC.drawLogs(x, y, logs, lines, color, offset)
    g.setForeground(color or 0x8BE9FD)
    g.setBackground(0x23242b) -- Цвет фона логов
    for i = 1, lines do
        local displayLine = i - 1 -- Индекс строки относительно y
        local idx = #logs - (lines - i) - offset -- Логи идут снизу вверх, последние внизу
        
        -- Очищаем текущую строку перед выводом нового лога
        g.fill(x, y + displayLine, term.current.width - x, 1, " ") 

        if idx > 0 and idx <= #logs then
            local logText = logs[idx] or ""
            g.set(x, y + displayLine, logText)
        end
    end
end

-- Функция для сохранения данных в файл
function ultimateOC.savef(path, data)
    local file = io.open(path, "w")
    if file then
        file:write(textutils.serialize(data))
        file:close()
    end
end

-- Функция для загрузки данных из файла
function ultimateOC.loadf(path)
    local file = io.open(path, "r")
    if not file then return nil end
    local content = file:read("*a")
    file:close()
    local func, err = load("return " .. content)
    if not func then error(err) end
    return func()
end

-- Функция для прогресс-бара
function ultimateOC.progressBar(x, y, w, progress)
    g.setBackground(0x44475a)
    g.fill(x, y, w, 1, " ")
    g.setBackground(0x50FA7B)
    g.fill(x, y, math.floor(w * progress), 1, " ")
END

return ultimateOC
