-- ultimateOC.lua - Улучшенная библиотека для визуала OpenComputers
local fs = require("filesystem")
local unicode = require("unicode")
-- Удаляем: local gpu = require("component").gpu  <-- ВАЖНОЕ ИЗМЕНЕНИЕ
-- Удаляем: local term = require("term")          <-- ВАЖНОЕ ИЗМЕНЕНИЕ

local M = {}

-- Безопасное сохранение таблицы (быстрее и надёжнее)
function M.savef(path, tbl)
    local ok, ser = pcall(require("serialization").serialize, tbl)
    if not ok then error("Ошибка сериализации: "..tostring(ser)) end
    local f, err = io.open(path, "w")
    if not f then error("Не могу открыть файл для записи: "..err) end
    f:write(ser)
    f:close()
end

function M.loadf(path)
    if not fs.exists(path) then return {} end
    local f, err = io.open(path, "r")
    if not f then error("Не могу открыть файл: "..err) end
    local data = f:read("*a")
    f:close()
    local ok, tbl = pcall(require("serialization").unserialize, data)
    if not ok then error("Ошибка десериализации: "..tostring(tbl)) end
    return tbl or {}
end

-- Гибкий фильтр предметов по подстроке (поиск не зависит от регистра)
function M.filterItems(tbl, query)
    if not query or query == "" then return tbl end
    local res = {}
    query = unicode.lower(query)
    for i, item in ipairs(tbl) do
        if item.name and unicode.lower(item.name):find(query, 1, true) then
            table.insert(res, item)
        end
    end
    return res
end

-- Закруглённый прямоугольник c опциональной цветной рамкой
-- Теперь принимает 'gpu' как аргумент
function M.roundRect(gpu_obj, x, y, w, h, borderColor, fillColor)
    borderColor = borderColor or 0x44475a
    fillColor = fillColor or 0x1B1D23
    -- Заливка
    if fillColor then
        gpu_obj.setBackground(fillColor)
        gpu_obj.fill(x, y, w, h, " ")
    end
    -- Рамка
    gpu_obj.setForeground(borderColor)
    gpu_obj.set(x+1, y, string.rep("─", w-2))
    gpu_obj.set(x+1, y+h-1, string.rep("─", w-2))
    for i = y+1, y+h-2 do
        gpu_obj.set(x, i, "│")
        gpu_obj.set(x+w-1, i, "│")
    end
    gpu_obj.set(x, y, "╭")
    gpu_obj.set(x+w-1, y, "╮")
    gpu_obj.set(x, y+h-1, "╰")
    gpu_obj.set(x+w-1, y+h-1, "╯")
end

-- Прогресс-бар (цветной)
-- Теперь принимает 'gpu' как аргумент
function M.progressBar(gpu_obj, x, y, w, percent, fg, bg)
    fg = fg or 0x50FA7B
    bg = bg or 0x44475a
    gpu_obj.setBackground(bg)
    gpu_obj.fill(x, y, w, 1, " ")
    gpu_obj.setBackground(fg)
    gpu_obj.fill(x, y, math.max(0, math.floor(w * percent)), 1, " ")
    gpu_obj.setBackground(0x1B1D23)
end

-- Анимированная кнопка (с закруглением, цветами и "нажатием")
-- Теперь принимает 'gpu' как аргумент
function M.animatedButton(gpu_obj, x, y, w, h, text, active, baseColor, hoverColor, textColor)
    baseColor = baseColor or 0x00BFFF
    hoverColor = hoverColor or 0x1E90FF
    textColor = textColor or 0xFFFFFF
    local color = active and hoverColor or baseColor
    M.roundRect(gpu_obj, x, y, w, h, color, color) -- Передаем gpu_obj в roundRect
    gpu_obj.setForeground(textColor)
    gpu_obj.set(x + math.floor((w-unicode.len(text))/2), y + math.floor(h/2), text)
    gpu_obj.setBackground(0x1B1D23)
end

-- Тень под текстом
-- Теперь принимает 'gpu' как аргумент
function M.drawText(gpu_obj, x, y, text, color, shadow)
    color = color or 0xF8F8F2
    if shadow then
        gpu_obj.setForeground(0x282A36)
        gpu_obj.set(x+1, y+1, text)
    end
    gpu_obj.setForeground(color)
    gpu_obj.set(x, y, text)
end

-- Быстрый логгер: добавляет строку в массив (до 50 записей)
function M.addLog(logs, text, lvl)
    lvl = lvl or "INFO"
    local t = string.format("[%s] %s", lvl, text)
    table.insert(logs, t)
    while #logs > 50 do table.remove(logs, 1) end
end

-- Рисует список логов (на экране)
-- Теперь принимает 'gpu' как аргумент
function M.drawLogs(gpu_obj, x, y, logs, count, color)
    count = count or 10
    color = color or 0x8BE9FD
    local logY = y
    local resX, resY = gpu_obj.getResolution() -- Получаем текущее разрешение GPU

    -- Очищаем область логов перед отрисовкой, чтобы не было "мусора"
    gpu_obj.setBackground(0x23242b) -- Цвет фона
    for i = 0, count-1 do
        gpu_obj.fill(x, y + i, resX - x + 1, 1, " ") -- Очищаем строку от X до конца экрана
    end

    for i = math.max(1,#logs-count+1), #logs do
        M.drawText(gpu_obj, x, logY, logs[i], color)
        logY = logY + 1
    end
end

-- Быстрый автоматический скролл по массиву
function M.scrollArray(tbl, scroll, perPage)
    local res = {}
    perPage = perPage or 20
    scroll = math.max(1, math.min(scroll, math.max(1, #tbl-perPage+1)))
    for i=scroll, math.min(#tbl, scroll+perPage-1) do
        res[#res+1] = tbl[i]
    end
    return res
end

-- Цветной выделенный элемент (фон+текст)
-- Теперь принимает 'gpu' как аргумент
function M.selectLine(gpu_obj, x, y, w, text, selected, color, selColor, textColor)
    color = color or 0x23262E
    selColor = selColor or 0x00BFFF
    textColor = textColor or 0xF8F8F2
    gpu_obj.setBackground(selected and selColor or color)
    gpu_obj.setForeground(textColor)
    gpu_obj.fill(x, y, w, 1, " ")
    gpu_obj.set(x+1, y, text)
    gpu_obj.setBackground(0x1B1D23)
end

return M
