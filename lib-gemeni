-- lib/ultimateOC.lua
local component = require("component")
local unicode = require("unicode")
local term = require("term")
local fs = require("filesystem")

local g = component.gpu

local ultimateOC = {}

-- Функция для рисования текста с цветом и жирным начертанием
function ultimateOC.drawText(x, y, text, color, bold)
    g.setForeground(color or 0xFFFFFF)
    -- Проверяем, что text не nil, чтобы избежать ошибок
    text = tostring(text or "")
    if bold then
        -- Для "жирного" текста в OC, часто используют повторение символов или просто пробелы для увеличения ширины.
        -- Ваш текущий метод 'text .. " "' и 'string.rep(" ", unicode.len(text))' на следующей строке не совсем
        -- делает текст "жирным" в общепринятом смысле, а скорее занимает две строки или добавляет пробелы.
        -- В OpenComputers, "жирный" текст обычно достигается путем вызова `g.set` дважды с небольшим смещением,
        -- или путем использования специального шрифта (если такой установлен и поддерживается).
        -- Для простоты и избежания багов с перекрытием, если вы хотите просто выделить,
        -- можно использовать другой цвет или инвертировать фон/текст.
        -- Если вы хотите визуально утолщить, это часто приводит к проблемам с сеткой символов.
        -- Пока оставим как есть, но учтем, что это не "настоящий" жирный.
        g.set(x, y, text) -- Просто выводим текст
        -- Если вы хотите "жирность" путем смещения, это может быть проблематично для плотного интерфейса
        -- g.set(x + 1, y, text) -- Это может сделать текст "жирнее", но также может сдвинуть его.
    else
        g.set(x, y, text)
    end
end

-- Функция для рисования прямоугольника с закруглёнными углами
function ultimateOC.roundRect(x, y, w, h, borderColor, bgColor)
    g.setBackground(bgColor or 0x000000)
    g.fill(x, y, w, h, " ")
    g.setForeground(borderColor or 0xFFFFFF)
    -- Используем символы для отрисовки рамки. Убедимся, что размеры корректны.
    if w >= 2 and h >= 2 then
        -- Верхняя линия
        g.set(x, y, "╔" .. string.rep("═", w - 2) .. "╗")
        -- Нижняя линия
        g.set(x, y + h - 1, "╚" .. string.rep("═", w - 2) .. "╝")
        -- Боковые линии
        for i = 1, h - 2 do
            g.set(x, y + i, "║")
            g.set(x + w - 1, y + i, "║")
        end
    end
end

-- Функция для анимированной кнопки (уже оптимизирована в предыдущих версиях)
function ultimateOC.animatedButton(x, y, w, h, text, bgColor, textColor, borderColor, subText, subTextColor)
    -- Важно: Эта функция должна перерисовывать *только* область кнопки.
    g.setBackground(bgColor)
    g.fill(x, y, w, h, " ") -- Заливаем фон кнопки
    g.setForeground(borderColor)
    g.set(x, y, "╔" .. string.rep("═", w - 2) .. "╗") -- Верхняя граница
    g.set(x, y + h - 1, "╚" .. string.rep("═", w - 2) .. "╝") -- Нижняя граница
    for i = 1, h - 2 do -- Боковые границы
        g.set(x, y + i, "║")
        g.set(x + w - 1, y + i, "║")
    end

    g.setForeground(textColor)
    local textLen = unicode.len(text)
    local tx = x + math.floor((w - textLen) / 2)
    g.set(tx, y + math.floor(h / 2), text) -- Основной текст по центру

    if subText and subText ~= "" then
        local subTextLen = unicode.len(subText)
        local subTx = x + math.floor((w - subTextLen) / 2)
        g.setForeground(subTextColor or textColor) -- Если subTextColor не задан, используем textColor
        g.set(subTx, y + math.floor(h / 2) + 1, subText) -- Дополнительный текст под основным
    end
end

-- Функция для отрисовки логов
function ultimateOC.drawLogs(x, y, logs, lines, color, offset)
    g.setForeground(color or 0x8BE9FD)
    -- Очищаем область логов перед отрисовкой
    g.setBackground(0x1A1B26) -- Используем фоновый цвет из auto-gemeni.lua
    g.fill(x, y, term.getWidth() - x - 2, lines, " ") -- Очищаем от x до конца экрана, высота 'lines'

    for i = 1, lines do
        local idx = #logs - offset - lines + i
        if idx > 0 and idx <= #logs then
            g.set(x, y + i - 1, logs[idx])
        end
    end
end

-- Функция для сохранения данных в файл
function ultimateOC.savef(path, data)
    local file = io.open(path, "w")
    if file then
        file:write(textutils.serialize(data))
        file:close()
    end
end

-- Функция для загрузки данных из файла
function ultimateOC.loadf(path)
    local file = io.open(path, "r")
    if not file then return nil end
    local content = file:read("*a")
    file:close()
    local func, err = load("return " .. content) -- Исправлено: удалены лишние "..."
    if not func then
        io.stderr:write("Ошибка при загрузке файла " .. path .. ": " .. tostring(err) .. "\n")
        return nil
    end
    local ok, data = pcall(func)
    if not ok then
        io.stderr:write("Ошибка при выполнении загруженного файла " .. path .. ": " .. tostring(data) .. "\n")
        return nil
    end
    return data
end


-- Прогресс-бар
function ultimateOC.progressBar(x, y, w, progress, bgColor, barColor, borderColor)
    g.setBackground(bgColor or 0x2A2E44)
    g.fill(x, y, w, 1, " ") -- Заливаем фон прогресс-бара

    local filledWidth = math.floor(w * math.max(0, math.min(1, progress)))
    if filledWidth > 0 then
        g.setBackground(barColor or 0x9ECE6A)
        g.fill(x, y, filledWidth, 1, " ") -- Заливаем прогресс
    end

    if borderColor then
        g.setForeground(borderColor)
        g.set(x, y, "█") -- Левая граница
        g.set(x + w - 1, y, "█") -- Правая граница
    end
end
