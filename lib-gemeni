-- lib/ultimateOC.lua
local component = require("component")
local unicode = require("unicode")
local term = require("term")
local fs = require("filesystem")

local g = component.gpu

local ultimateOC = {}

-- Функция для рисования текста с цветом
-- Убрана "жирность" через дублирование символов, так как это часто вызывает визуальные артефакты
-- и не является истинным "жирным" шрифтом в OpenComputers.
-- Если нужна акцентуация, лучше использовать разные цвета или инвертировать фон/текст.
function ultimateOC.drawText(x, y, text, color, bgColor)
    g.setForeground(color or 0xFFFFFF)
    -- Опционально: если задан фоновый цвет для текста, заливаем его
    if bgColor then
        g.setBackground(bgColor)
        g.fill(x, y, unicode.len(text), 1, " ") -- Заливаем фон под текстом
    else
        -- Сброс фона, если он не нужен для текста, чтобы не влиять на соседние области
        g.setBackground(g.getBackground())
    end
    g.set(x, y, tostring(text or "")) -- Убеждаемся, что текст не nil
end

-- Функция для рисования прямоугольника (заливка фоном)
function ultimateOC.fillRect(x, y, w, h, bgColor, char)
    g.setBackground(bgColor or 0x000000)
    g.fill(x, y, w, h, char or " ")
end

-- Функция для рисования прямоугольника с границами
function ultimateOC.drawRect(x, y, w, h, borderColor, bgColor)
    ultimateOC.fillRect(x, y, w, h, bgColor) -- Заливаем фон
    g.setForeground(borderColor or 0xFFFFFF)

    if w >= 2 and h >= 2 then
        -- Верхняя линия
        ultimateOC.drawText(x, y, "╔" .. string.rep("═", w - 2) .. "╗", borderColor)
        -- Нижняя линия
        ultimateOC.drawText(x, y + h - 1, "╚" .. string.rep("═", w - 2) .. "╝", borderColor)
        -- Боковые линии
        for i = 1, h - 2 do
            ultimateOC.drawText(x, y + i, "║", borderColor)
            ultimateOC.drawText(x + w - 1, y + i, "║", borderColor)
        end
    elseif w == 1 and h > 0 then -- Вертикальная линия
        for i = 0, h - 1 do
            ultimateOC.drawText(x, y + i, "║", borderColor)
        end
    elseif h == 1 and w > 0 then -- Горизонтальная линия
        ultimateOC.drawText(x, y, string.rep("═", w), borderColor)
    end
end


-- Функция для анимированной кнопки
function ultimateOC.animatedButton(x, y, w, h, text, bgColor, textColor, borderColor, subText, subTextColor)
    -- Отрисовываем фон кнопки
    ultimateOC.drawRect(x, y, w, h, borderColor, bgColor)

    -- Основной текст
    g.setForeground(textColor)
    local textLen = unicode.len(text)
    local tx = x + math.floor((w - textLen) / 2)
    ultimateOC.drawText(tx, y + math.floor(h / 2), text, textColor)

    -- Дополнительный текст (подтекст)
    if subText and subText ~= "" then
        local subTextLen = unicode.len(subText)
        local subTx = x + math.floor((w - subTextLen) / 2)
        ultimateOC.drawText(subTx, y + math.floor(h / 2) + 1, subText, subTextColor or textColor)
    end
end

-- Функция для отрисовки логов
function ultimateOC.drawLogs(x, y, logs, lines, color, offset, bgColor)
    bgColor = bgColor or 0x1A1B26 -- Цвет фона для логов, по умолчанию такой же, как в auto-gemeni

    -- Очищаем область логов перед отрисовкой
    ultimateOC.fillRect(x, y, term.getWidth() - x - 2, lines, bgColor)

    g.setForeground(color or 0x8BE9FD)
    for i = 1, lines do
        local idx = #logs - offset - lines + i
        if idx > 0 and idx <= #logs then
            local logText = logs[idx]
            -- Обрезаем текст, если он слишком длинный, чтобы не выходить за границы
            local maxLen = term.getWidth() - x - 2
            if unicode.len(logText) > maxLen then
                logText = unicode.sub(logText, 1, maxLen - 3) .. "..."
            end
            ultimateOC.drawText(x, y + i - 1, logText, color)
        end
    end
end

-- Функция для сохранения данных в файл
function ultimateOC.savef(path, data)
    local file = io.open(path, "w")
    if file then
        local serializedData = textutils.serialize(data)
        file:write(serializedData)
        file:close()
        return true
    else
        return false, "Не удалось открыть файл для записи: " .. path
    end
end

-- Функция для загрузки данных из файла
function ultimateOC.loadf(path)
    local file = io.open(path, "r")
    if not file then return nil, "Файл не найден: " .. path end
    local content = file:read("*a")
    file:close()
    
    -- Исправленная строка: убраны лишние "..."
    local func, err = load("return " .. content)
    if not func then
        return nil, "Ошибка синтаксиса в файле " .. path .. ": " .. tostring(err)
    end
    local ok, data = pcall(func)
    if not ok then
        return nil, "Ошибка выполнения содержимого файла " .. path .. ": " .. tostring(data)
    end
    return data, nil
end

-- Прогресс-бар
function ultimateOC.progressBar(x, y, w, progress, bgColor, barColor, borderColor)
    ultimateOC.fillRect(x, y, w, 1, bgColor or 0x2A2E44) -- Заливаем фон прогресс-бара

    local filledWidth = math.floor(w * math.max(0, math.min(1, progress)))
    if filledWidth > 0 then
        ultimateOC.fillRect(x, y, filledWidth, 1, barColor or 0x9ECE6A) -- Заливаем прогресс
    end

    if borderColor then
        g.setForeground(borderColor)
        g.set(x, y, "█") -- Левая граница
        g.set(x + w - 1, y, "█") -- Правая граница
    end
end

return ultimateOC
