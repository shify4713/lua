-- ultimateOC.lua - Улучшенная библиотека для визуала OpenComputers
local fs = require("filesystem")
local unicode = require("unicode")
local gpu = require("component").gpu

local M = {}

-- Безопасное сохранение таблицы (быстрее и надёжнее)
function M.savef(path, tbl)
    local ok, ser = pcall(require("serialization").serialize, tbl)
    if not ok then error("Ошибка сериализации: "..tostring(ser)) end
    local f, err = io.open(path, "w")
    if not f then error("Не могу открыть файл для записи: "..err) end
    f:write(ser)
    f:close()
end

function M.loadf(path)
    if not fs.exists(path) then return {} end
    local f, err = io.open(path, "r")
    if not f then error("Не могу открыть файл: "..err) end
    local data = f:read("*a")
    f:close()
    local ok, tbl = pcall(require("serialization").unserialize, data)
    if not ok then error("Ошибка десериализации: "..tostring(tbl)) end
    return tbl or {}
end

-- Гибкий фильтр предметов по подстроке (поиск не зависит от регистра)
function M.filterItems(items, searchTerm)
    local filtered = {}
    local lowerSearchTerm = unicode.lower(searchTerm)
    for _, item in ipairs(items) do
        local lowerName = unicode.lower(item.name)
        if unicode.find(lowerName, lowerSearchTerm) then
            table.insert(filtered, item)
        end
    end
    return filtered
end

-- Кэширование всех предметов из ME-интерфейса
local allMeItemsCache = {}
local lastCacheUpdate = 0
local CACHE_TTL = 30 -- Время жизни кэша в секундах

function M.getAllMeItems(me)
    local now = computer.uptime()
    if now - lastCacheUpdate > CACHE_TTL or #allMeItemsCache == 0 then
        local items = {}
        local pageSize = 50 -- Запрос по 50 предметов за раз, чтобы избежать слишком больших ответов
        local page = 1
        local totalItems = 0
        repeat
            local result = {me.getItemsInGrid(page, pageSize)}
            local count = #result
            for i = 1, count, 2 do
                table.insert(items, result[i])
            end
            totalItems = totalItems + (count / 2)
            page = page + 1
        until count < pageSize * 2 -- Если элементов меньше, чем запросили, значит, это последняя страница

        allMeItemsCache = items
        lastCacheUpdate = now
    end
    return allMeItemsCache
end

-- Рисует кнопку
function M.drawButton(x, y, w, h, text, bgColor, textColor, isHovered)
    if isHovered then
        bgColor = 0x555555 -- Темнее при наведении
    end
    gpu.setBackground(bgColor)
    gpu.fill(x, y, w, h, " ")
    gpu.setForeground(textColor)
    local textWidth = unicode.len(text)
    local textX = x + math.floor((w - textWidth) / 2)
    local textY = y + math.floor((h - 1) / 2)
    gpu.set(textX, textY, text)
end

-- Рисует текстовое поле ввода
function M.drawInputField(x, y, w, h, text, isActive, bgColor, textColor, cursorX)
    gpu.setBackground(bgColor)
    gpu.fill(x, y, w, h, " ")
    gpu.setForeground(textColor)

    local display_text = text
    if unicode.len(text) > w then
        display_text = unicode.sub(text, unicode.len(text) - w + 1, unicode.len(text))
    end
    gpu.set(x, y, display_text)

    if isActive then
        gpu.setBackground(0xFFFFFF) -- Цвет курсора
        gpu.set(x + cursorX, y, unicode.sub(display_text, cursorX + 1, cursorX + 1) or " ")
        gpu.setBackground(bgColor) -- Возвращаем цвет фона
    end
end


-- Рисует текст с тенью (для лучшей читаемости)
function M.drawText(x, y, text, color)
    local gpu = require("component").gpu
    if not gpu then return end
    gpu.setBackground(0x282A36) -- Цвет фона для тени
    local shadow_x = x + 1
    local shadow_y = y + 1
    local prev_color = gpu.getForeground()
    gpu.setForeground(0x282A36)
    gpu.set(shadow_x, shadow_y, text)
    gpu.setForeground(prev_color) -- Восстанавливаем предыдущий цвет
    gpu.set(x, y, text)
end

-- Быстрый логгер: добавляет строку в массив (до 50 записей)
function M.addLog(logs, text, lvl)
    lvl = lvl or "INFO"
    local now = os.date("!*t", os.time()+3*3600) -- МСК
    local t = string.format("[%02d:%02d:%02d][%s] %s", now.hour, now.min, now.sec, lvl, text)
    table.insert(logs, t)
    while #logs > 50 do table.remove(logs, 1) end
end

-- Рисует список логов (на экране)
function M.drawLogs(x, y, logs, count, color)
    count = count or 10
    color = color or 0x8BE9FD
    local logY = y
    for i = math.max(1,#logs-count+1), #logs do
        M.drawText(x, logY, logs[i], color)
        logY = logY + 1
    end
end

-- Быстрый автоматический скролл по массиву
function M.scrollArray(tbl, scroll, perPage)
    local res = {}
    perPage = perPage or 20
    scroll = math.max(1, math.min(scroll, math.max(1, #tbl - perPage + 1)))
    for i = scroll, math.min(scroll + perPage - 1, #tbl) do
        table.insert(res, tbl[i])
    end
    return res, scroll
end

-- Проверяет, находится ли курсор над кнопкой
function M.isMouseOver(mouseX, mouseY, x, y, w, h)
    return mouseX >= x and mouseX < x + w and mouseY >= y and mouseY < y + h
end

return M
