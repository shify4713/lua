local component = require("component")
local fs = require("filesystem")
local unicode = require("unicode")

-- !!! ВНИМАНИЕ !!!
-- Эти переменные 'g' и 'term' будут получать значения из главного скрипта (autoCraftUltimate.lua).
-- Если в главном скрипте они не инициализируются корректно, функции здесь не будут работать.
local g = nil
local term = nil

local M = {}

-- Функция для установки глобальных ссылок на GPU и Term
function M.setGlobals(gpu_obj, term_obj)
    g = gpu_obj
    term = term_obj
end

-- Вспомогательная функция для безопасной отрисовки текста
function M.drawText(x, y, text, color, bold)
    if not g or type(g) ~= "table" or not g.set then return end -- Защита от отсутствия GPU
    g.setForeground(color or 0xFFFFFF)
    if bold then g.setDepth(2) end -- Установите глубину только если GPU поддерживает
    g.set(x, y, text)
    if bold then g.setDepth(1) end -- Возвращаем глубину
end

-- Вспомогательная функция для безопасного рисования круглой рамки
function M.roundRect(x, y, w, h, borderColor, fillColor)
    if not g or type(g) ~= "table" or not g.fill then return end -- Защита от отсутствия GPU
    g.setBackground(borderColor)
    g.fill(x, y, w, h, " ")
    g.setBackground(fillColor)
    g.fill(x+1, y+1, w-2, h-2, " ")
end

-- Прогресс-бар
function M.progressBar(x, y, w, progress)
    if not g or type(g) ~= "table" or not g.fill then return end -- Защита от отсутствия GPU
    g.setBackground(0x44475a) -- progress_bg
    g.fill(x, y, w, 1, " ")
    local filledWidth = math.floor(w * math.max(0, math.min(1, progress)))
    if filledWidth > 0 then
        g.setBackground(0x50FA7B) -- progress_fg
        g.fill(x, y, filledWidth, 1, " ")
    end
end

-- Анимированная кнопка (или просто статичная, если не наведен курсор)
function M.animatedButton(x, y, w, h, text, isHovered, normalColor, activeColor, textColor)
    if not g or type(g) ~= "table" or not g.fill then return end -- Защита от отсутствия GPU
    local bgColor = isHovered and activeColor or normalColor
    g.setBackground(bgColor)
    g.fill(x, y, w, h, " ")
    g.setForeground(textColor)
    local textLen = unicode.len(text)
    local textX = x + math.floor((w - textLen) / 2)
    local textY = y + math.floor((h - 1) / 2)
    g.set(textX, textY, text)
end

-- Логгирование (только отрисовка, сами логи хранятся в main-скрипте)
function M.drawLogs(x, y, logs_table, maxLines, logColor)
    if not g or type(g) ~= "table" or not g.fill then return end -- Защита от отсутствия GPU
    local startLine = math.max(1, #logs_table - maxLines + 1)
    for i = 0, maxLines - 1 do
        local logIdx = startLine + i
        g.setBackground(0x23242b) -- bg
        g.fill(x, y + i, g.getResolution(), 1, " ") -- Очищаем строку перед выводом
        if logs_table[logIdx] then
            g.setForeground(logColor)
            g.set(x, y + i, unicode.sub(logs_table[logIdx], 1, g.getResolution()))
        end
    end
end

-- Функции для сохранения/загрузки данных
function M.savef(filename, data)
    local file = fs.open(filename, "w")
    if file then
        file.write(textutils.serialize(data))
        file.close()
        return true
    end
    return false, "Не удалось открыть файл для записи: " .. filename
end

function M.loadf(filename)
    if not fs.exists(filename) then return {} end
    local file = fs.open(filename, "r")
    if file then
        local data = textutils.unserialize(file.readAll())
        file.close()
        return data
    end
    return nil, "Не удалось открыть файл для чтения: " .. filename
end

return M
