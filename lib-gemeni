-- ultimateOC.lua - Улучшенная библиотека для визуала OpenComputers
local fs = require("filesystem")
local unicode = require("unicode")
local gpu = require("component").gpu

local M = {}

-- Безопасное сохранение таблицы (быстрее и надёжнее)
function M.savef(path, tbl)
    local ok, ser = pcall(require("serialization").serialize, tbl)
    if not ok then error("Ошибка сериализации: "..tostring(ser)) end
    local f, err = io.open(path, "w")
    if not f then error("Не могу открыть файл для записи: "..err) end
    f:write(ser)
    f:close()
end

function M.loadf(path)
    if not fs.exists(path) then return {} end
    local f, err = io.open(path, "r")
    if not f then error("Не могу открыть файл: "..err) end
    local data = f:read("*a")
    f:close()
    local ok, tbl = pcall(require("serialization").unserialize, data)
    if not ok then error("Ошибка десериализации: "..tostring(tbl)) end
    return tbl or {}
end

-- Гибкий фильтр предметов по подстроке (поиск не зависит от регистра)
function M.filterItems(items, filter)
    filter = unicode.lower(filter)
    local filtered = {}
    for _, item in ipairs(items) do
        if unicode.lower(item.name):find(filter) then
            table.insert(filtered, item)
        end
    end
    return filtered
end

-- Проверка попадания координат в область
function M.isInside(x, y, btnX, btnY, btnW, btnH)
    return x >= btnX and x < btnX + btnW and y >= btnY and y < btnY + btnH
end

-- Отрисовка текстового поля с рамкой
function M.drawField(x, y, width, text, isActive, bgColor, fgColor)
    gpu.setBackground(bgColor)
    gpu.setForeground(fgColor)
    gpu.fill(x, y, width, 1, " ")
    local displayedText = M.truncateText(text, width)
    gpu.set(x, y, displayedText)

    if isActive then
        -- Индикатор активного поля (курсор или рамка)
        local cursorX = x + unicode.len(displayedText)
        if cursorX < x + width then
            gpu.setBackground(0xFFFFFF) -- Белый курсор
            gpu.set(cursorX, y, " ")
        end
    end
end

-- Отрисовка кнопки
function M.drawButton(x, y, width, height, text, bgColor, fgColor, isHovered)
    local currentBg = isHovered and 0x8BE9FD or bgColor -- Цвет при наведении
    gpu.setBackground(currentBg)
    gpu.setForeground(fgColor)
    gpu.fill(x, y, width, height, " ") -- Заполняем фон кнопки

    -- Центрирование текста
    local textWidth = unicode.len(text)
    local textX = x + math.floor((width - textWidth) / 2)
    local textY = y + math.floor(height / 2)

    -- Если текст выходит за пределы кнопки, обрезать
    local truncatedText = M.truncateText(text, width)
    textX = x + math.floor((width - unicode.len(truncatedText)) / 2) -- Пересчитываем X для центрирования обрезанного текста

    gpu.set(textX, textY, truncatedText)
end


-- Обрезка текста до заданной ширины
function M.truncateText(text, width)
    local len = unicode.len(text)
    if len <= width then
        return text
    else
        return unicode.sub(text, 1, width - 1) .. "…" -- Один символ для многоточия
    end
end

-- Отрисовка текста
function M.drawText(x, y, text, color)
    gpu.setForeground(color)
    gpu.set(x, y, text)
end

-- Быстрый логгер: добавляет строку в массив (до 50 записей)
function M.addLog(logs, text, lvl)
    lvl = lvl or "INFO"
    local now = os.date("!*t", os.time()+3*3600) -- МСК
    local t = string.format("[%02d:%02d:%02d][%s] %s", now.hour, now.min, now.sec, lvl, text)
    table.insert(logs, t)
    while #logs > 50 do table.remove(logs, 1) end
end

-- Рисует список логов (на экране)
function M.drawLogs(x, y, logs, count, color)
    count = count or 10
    color = color or 0x8BE9FD
    local logY = y
    -- Отрисовка последних 'count' логов
    for i = math.max(1,#logs-count+1), #logs do
        M.drawText(x, logY, logs[i], color)
        logY = logY + 1
    end
end

-- Быстрый автоматический скролл по массиву
function M.scrollArray(tbl, scroll, perPage)
    local res = {}
    perPage = perPage or 20
    scroll = math.max(1, math.min(scroll, math.max(1, math.ceil(#tbl / perPage)))) -- Убедиться, что scroll в допустимых пределах
    local startIndex = (scroll - 1) * perPage + 1
    local endIndex = math.min(startIndex + perPage - 1, #tbl)
    for i = startIndex, endIndex do
        table.insert(res, tbl[i])
    end
    return res
end

return M
