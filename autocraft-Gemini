-- autoCraftUltimate.lua
-- Основная программа для OpenComputers.
-- Исправлены мерцания логов, наложение элементов, визуал таблицы и ошибки.
-- Поддержка поиска на кириллице.

local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode") -- Используется для работы с Unicode (включая кириллицу)
local term = require("term")
local computer = require("computer")

local g = component.gpu
local me = component.me_interface

-- Пути и библиотека
local DATA_FILE = "/home/BD.txt"
local LIB_PATH = "/lib/ultimateOC.lua"
local LIB_URL = "https://raw.githubusercontent.com/shify4713/lua/main/ultimateOC.lua"

-- Проверка и загрузка ultimateOC.lua
if not fs.exists(LIB_PATH) then
    io.stdout:write("Загрузка ultimateOC.lua...\n")
    local ok, err = shell.execute("wget -f " .. LIB_URL .. " " .. LIB_PATH)
    if not ok then
        io.stderr:write("Ошибка загрузки ultimateOC.lua: " .. tostring(err) .. "\n")
        os.exit(1)
    else
        io.stdout:write("ultimateOC.lua успешно загружен.\n")
    end
end

-- Загружаем библиотеку ultimateOC.lua
local ok, uoc = pcall(require, "ultimateOC")
if not ok then
    io.stderr:write("Не удалось загрузить ultimateOC.lua: " .. tostring(uoc) .. "\n")
    io.stderr:write("Убедитесь, что ultimateOC.lua существует по пути " .. LIB_PATH .. " и не содержит синтаксических ошибок.\n")
    os.exit(1)
end

-- Передаем ссылку на GPU в библиотеку, чтобы она могла использовать g
-- Это важно, так как uoc.lua теперь ожидает M.gpu
uoc.gpu = g

-- Проверка существования файла данных
if not fs.exists(DATA_FILE) then
    io.stdout:write("Файл базы данных " .. DATA_FILE .. " не найден, создаю пустой.\n")
    uoc.savef(DATA_FILE, {}) -- Создаем пустой файл данных
end

-------------------- Настройки --------------------
local COLORS = {
    button = 0x00BFFF,
    buttonActive = 0x1E90FF,
    border = 0x44475a,
    text = 0xF8F8F2,
    shadow = 0x282A36,
    bg = 0x23242b,
    error = 0xFF5555,
    ok = 0x50FA7B,
    log = 0x8BE9FD,
    progress_bg = 0x44475a,
    progress_fg = 0x50FA7B,
    select = 0x31313A,
    select_active = 0x44B3FF,
    search_bg = 0x282B36,
    search_border = 0x00BFFF,
    search_cross = 0xFF5555,
    search_hint = 0x888888,
    bar_shadow = 0x181920,
    tooltip_bg = 0x44475a,
    tooltip_text = 0xF8F8F2,
}

local WIDTH, HEIGHT = 110, 40
local craftStatus = "Ожидание..."
local nextCraftUpdate = 0
local isCrafting = false

-- Определяем фиксированные высоты для блоков
local HEADER_HEIGHT = 6 -- Высота хедера с прогресс-баром (строки 1-6)
local LOG_LINES = 4 -- Количество строк для логов
local LOG_HEIGHT = LOG_LINES -- Высота блока логов (по 1 строке на лог)
local BUTTON_HEIGHT = 3 -- Высота кнопок
local SEARCH_BAR_HEIGHT = 3 -- Высота строки поиска
local FOOTER_HEIGHT = 1 -- Зарезервированная строка внизу (не используется, но для отступов)

-- Рассчитываем Y-координаты снизу вверх, чтобы избежать наложений
local LOG_Y_START = HEIGHT - LOG_HEIGHT + 1 -- Логи начинаются с этого Y (40 - 4 + 1 = 37)
local BUTTON_Y = LOG_Y_START - BUTTON_HEIGHT - 1 -- Кнопки над логами, с отступом в 1 строку (37 - 3 - 1 = 33)
local SEARCH_BAR_Y = BUTTON_Y - SEARCH_BAR_HEIGHT - 2 -- Поиск над кнопками, с отступом в 2 строки (33 - 3 - 2 = 28)

-- Начало и конец области таблицы
local TABLE_Y_START = HEADER_HEIGHT + 2 -- Таблица начинается после хедера, с отступом в 2 строки (6 + 2 = 8)
-- TABLE_VISIBLE_ROWS = Y_поиска - Y_начала_таблицы - 3 строки (заголовки таблицы) - 1 отступ
local TABLE_VISIBLE_ROWS = SEARCH_BAR_Y - TABLE_Y_START - 3 - 1 -- 28 - 8 - 3 - 1 = 16 строк данных

-------------------- Переменные --------------------
local logs = {}
local dataItems = {} -- Список предметов для автокрафта
local search = ""
local selectedItemIdx = nil -- Индекс выбранного предмета в dataItems (не showItems)
local itemScroll = 1
local changeitem = false -- Флаг, который показывает, что идет режим ввода данных
local searchActive = false
local hoveredButton = nil
local tooltip = ""
local tooltipTimeout = 0
local lastDrawTime = 0 -- Для отслеживания времени между перерисовками (для производительности)


-- Предварительные объявления функций (важно для решения "nil value" ошибок)
-- Объявляем их как глобальные (без 'local'), чтобы они были доступны отовсюду
function addLog(text, lvl) end
function draw() end
function drawLogs() end
function drawTooltip() end


-------------------- Логгирование --------------------
function addLog(text, lvl)
    lvl = lvl or "INFO"
    local t = string.format("[!] [%s] %s", lvl, text)
    table.insert(logs, t)
    while #logs > LOG_LINES do table.remove(logs, 1) end -- Ограничиваем количество логов до LOG_LINES
    drawLogs() -- Перерисовываем только логи, это помогает уменьшить мерцание
end

-------------------- Визуал --------------------
-- Функция очистки экрана (используется только при полной перерисовке)
local function clearScreen()
    g.setBackground(COLORS.bg)
    g.fill(1,1,WIDTH,HEIGHT," ")
    g.setForeground(COLORS.text)
end

-- Отрисовка тени (без изменений)
local function shadowRect(x, y, w, h)
    g.setBackground(COLORS.bar_shadow)
    g.fill(x+1, y+h, w, 1, " ")
    g.fill(x+w, y, 1, h, " ")
    g.setBackground(COLORS.bg)
end

-- Отрисовка хедера
local function drawHeader()
    g.setBackground(COLORS.bg)
    g.fill(1, 1, WIDTH, HEADER_HEIGHT, " ") -- Очищаем область хедера
    uoc.drawText(3,3,"Ultimate AutoCraft",COLORS.ok,true)
    g.setBackground(COLORS.progress_fg)
    g.fill(2,4,WIDTH-2,1," ")
    shadowRect(2,4,WIDTH-2,1)
    g.setBackground(COLORS.bg)
    uoc.drawText(WIDTH-34,3,"Статус: "..craftStatus,
        (craftStatus:find("Ошибка") and COLORS.error) or COLORS.ok)
    uoc.progressBar(3,5,WIDTH-6, isCrafting and 0.9 or 0)
end

-- Отрисовка логов
function drawLogs()
    local start = math.max(1, #logs - LOG_LINES + 1)
    g.setBackground(COLORS.bg)
    -- Очищаем всю область логов, чтобы избежать остаточных символов и мерцания
    g.fill(1, LOG_Y_START, WIDTH, LOG_HEIGHT, " ")
    for i = 1, LOG_LINES do
        local idx = start + i - 1
        if logs[idx] then
            g.setForeground(COLORS.log)
            g.set(3, LOG_Y_START + i - 1, logs[idx])
        end
    end
    g.setForeground(COLORS.text)
end

-- Отрисовка таблицы предметов
local function drawItems()
    local x, y = 2, TABLE_Y_START
    local totalWidth = WIDTH - 6
    local col_name = math.floor(totalWidth * 0.44)
    local col_now = math.floor(totalWidth * 0.18)
    local col_hold = math.floor(totalWidth * 0.18)
    local col_once = totalWidth - col_name - col_now - col_hold

    -- Очищаем всю область таблицы перед отрисовкой
    g.setBackground(COLORS.bg)
    -- Высота области для очистки: 3 строки заголовков + TABLE_VISIBLE_ROWS строк данных + 1 строка для нижней рамки
    g.fill(x, y, totalWidth + 6, 3 + TABLE_VISIBLE_ROWS + 1, " ")

    -- Верх рамки
    g.setForeground(COLORS.select_active)
    g.set(x, y,       "┌"..string.rep("─",col_name).."┬"..string.rep("─",col_now).."┬"..string.rep("─",col_hold).."┬"..string.rep("─",col_once).."┐")
    -- Заголовки
    g.set(x, y+1,     "│")
    g.setForeground(COLORS.ok)
    uoc.drawText(x+1, y+1, string.format("%-"..col_name.."s"," Название"))
    g.setForeground(COLORS.select_active)
    g.set(x+col_name+1, y+1, "│")
    g.setForeground(COLORS.ok)
    uoc.drawText(x+col_name+2, y+1, string.format("%-"..(col_now).."s"," В наличии"))
    g.setForeground(COLORS.select_active)
    g.set(x+col_name+col_now+2, y+1, "│")
    g.setForeground(COLORS.ok)
    uoc.drawText(x+col_name+col_now+3, y+1, string.format("%-"..(col_hold).."s"," Держать"))
    g.setForeground(COLORS.select_active)
    g.set(x+col_name+col_now+col_hold+3, y+1, "│")
    g.setForeground(COLORS.ok)
    uoc.drawText(x+col_name+col_now+col_hold+4, y+1, string.format("%-"..(col_once).."s"," За раз"))
    g.setForeground(COLORS.select_active)
    g.set(x+col_name+col_now+col_hold+col_once+4, y+1, "│")
    -- Разделитель
    g.set(x, y+2, "├"..string.rep("─",col_name).."┼"..string.rep("─",col_now).."┼"..string.rep("─",col_hold).."┼"..string.rep("─",col_once).."┤")

    -- Фильтрация предметов для отображения
    local showItems = {}
    for i,item in ipairs(dataItems) do
        -- Поиск без учета регистра, поддержка кириллицы
        if search == "" or unicode.lower(item.name or ""):find(unicode.lower(search), 1, true) then
            table.insert(showItems, item)
        end
    end

    for i = itemScroll, math.min(#showItems, itemScroll + TABLE_VISIBLE_ROWS - 1) do
        local it = showItems[i]
        local isSel = (selectedItemIdx and dataItems[selectedItemIdx] == it)
        local row = y + 2 + (i - itemScroll) + 1

        -- Очищаем строку перед отрисовкой, чтобы избежать артефактов выделения
        g.setBackground(COLORS.bg)
        g.fill(x, row, totalWidth + 6, 1, " ")

        g.setBackground(isSel and COLORS.select_active or COLORS.bg)
        g.setForeground(COLORS.text)

        -- Обрезаем текст, чтобы он не выходил за рамки колонки
        local nameStr = unicode.sub((it.name or "<??>"), 1, col_name)
        local nowStr  = string.format("%"..col_now.."s", tostring(it.current or 0)):sub(-col_now)
        local holdStr = string.format("%"..col_hold.."s", tostring(it.count or 0)):sub(-col_hold)
        local onceStr = string.format("%"..col_once.."s", tostring(it.craftSize or 0)):sub(-col_once)

        g.set(x, row, "│")
        uoc.drawText(x+1, row, string.format("%-"..col_name.."s",nameStr))
        g.set(x+col_name+1, row, "│")
        uoc.drawText(x+col_name+2, row, nowStr)
        g.set(x+col_name+col_now+2, row, "│")
        uoc.drawText(x+col_name+col_now+3, row, holdStr)
        g.set(x+col_name+col_now+col_hold+3, row, "│")
        uoc.drawText(x+col_name+col_now+col_hold+4, row, onceStr)
        g.set(x+col_name+col_now+col_hold+col_once+4, row, "│")
        g.setBackground(COLORS.bg)
    end

    -- Низ рамки
    local lastRow = y + TABLE_VISIBLE_ROWS + 3
    g.setForeground(COLORS.select_active)
    g.set(x, lastRow, "└"..string.rep("─",col_name).."┴"..string.rep("─",col_now).."┴"..string.rep("─",col_hold).."┴"..string.rep("─",col_once).."┘")
    g.setForeground(COLORS.text)

    -- Скроллбар если нужно
    if #showItems > TABLE_VISIBLE_ROWS then
        local barLen = math.max(2, math.floor(TABLE_VISIBLE_ROWS * TABLE_VISIBLE_ROWS / #showItems))
        local barTop = y + 3 + math.floor((TABLE_VISIBLE_ROWS - barLen) * (itemScroll - 1) / math.max(1, #showItems - TABLE_VISIBLE_ROWS))
        g.setForeground(COLORS.select_active)
        g.fill(WIDTH-2, y+3, 1, TABLE_VISIBLE_ROWS, " ")
        for i=1,TABLE_VISIBLE_ROWS do
             g.set(WIDTH-2, y+2+i, "│")
        end
        g.setForeground(COLORS.ok)
        for i=0,barLen-1 do
            g.set(WIDTH-2, barTop+i, "█")
        end
        g.setForeground(COLORS.text)
    end
end

-- Отрисовка строки поиска
local function drawSearchBar()
    local x, y, w, h = 3, SEARCH_BAR_Y, WIDTH-6, SEARCH_BAR_HEIGHT
    g.setBackground(COLORS.bg)
    g.fill(x,y,w,h," ") -- Очищаем область поиска перед отрисовкой
    uoc.roundRect(x, y, w, h, COLORS.search_border, COLORS.search_bg)
    g.setBackground(COLORS.search_bg)
    g.fill(x+1, y+1, w-2, h-2, " ")
    g.setForeground(searchActive and COLORS.ok or COLORS.search_hint)
    local display = search
    if display=="" then display = "Поиск: введите часть названия..." end
    local maxlen = w - 7
    -- Обрезаем отображаемый текст поиска, чтобы он не выходил за рамки поля
    if unicode.len(display) > maxlen then
        display = unicode.sub(display, unicode.len(display)-maxlen+2)
    end
    g.set(x+2, y+1, display)
    if searchActive then
        term.setCursor(x + 2 + unicode.len(search), y + 1) -- Устанавливаем курсор для ввода
        term.showCursor(true)
    else
        term.showCursor(false)
    end
    g.setForeground(COLORS.search_cross)
    g.set(x+w-3, y+1, (search ~= "" and "×" or " ")) -- Кнопка сброса поиска
    g.setBackground(COLORS.bg)
    g.setForeground(COLORS.text)
end

-- Отрисовка кнопок
local function drawButtons()
    local btns = {
        {name="Удалить", x=WIDTH-60, tip="Удалить выбранный предмет из списка"},
        {name="Изменить", x=WIDTH-45, tip="Изменить параметры выбранного предмета"},
        {name=isCrafting and "Остановить" or "Автокрафт", x=WIDTH-30, tip=isCrafting and "Остановить автокрафт" or "Запустить автокрафт"},
        {name="Добавить", x=WIDTH-15, tip="Добавить новый предмет (предмет в 1 слоте ME интерфейса)"},
    }
    g.setBackground(COLORS.bg)
    g.fill(1, BUTTON_Y, WIDTH, BUTTON_HEIGHT, " ") -- Очищаем область кнопок
    for i,v in ipairs(btns) do
        local hover = hoveredButton == i
        uoc.animatedButton(v.x, BUTTON_Y, 12, 3, v.name, hover, COLORS.button, COLORS.buttonActive, COLORS.text)
        if hover then
            tooltip = v.tip
            tooltipTimeout = os.time()
        end
    end
end

-- Отрисовка футера (пустая строка внизу)
local function drawFooter()
    g.setBackground(COLORS.bg)
    g.fill(1, HEIGHT - FOOTER_HEIGHT + 1, WIDTH, FOOTER_HEIGHT, " ")
    g.setForeground(COLORS.text)
end

-- Отрисовка всплывающей подсказки
function drawTooltip()
    if tooltip and tooltip ~= "" and os.time() - tooltipTimeout >= 0.5 then
        local tipWidth = unicode.len(tooltip) + 4
        local tipHeight = 3
        local tipX = math.max(1, WIDTH - tipWidth - 1)
        local tipY = 1

        if tipX < 1 then tipX = 1 end

        g.setBackground(COLORS.tooltip_bg)
        uoc.roundRect(tipX, tipY, tipWidth, tipHeight, COLORS.tooltip_bg, COLORS.tooltip_bg)
        g.fill(tipX + 1, tipY + 1, tipWidth - 2, tipHeight - 2, " ")

        g.setForeground(COLORS.tooltip_text)
        g.set(tipX + 2, tipY + 1, tooltip)

        g.setBackground(COLORS.bg)
        g.setForeground(COLORS.text)
    else
        -- Очищаем только ту область, где могла быть подсказка
        g.setBackground(COLORS.bg)
        g.fill(WIDTH - 20, 1, 20, 3, " ") -- Примерная область для очистки подсказки
    end
end

-- Главная функция отрисовки всего интерфейса
function draw()
    -- Ограничиваем частоту перерисовки для уменьшения мерцания
    if computer.uptime() - lastDrawTime < 0.1 then return end
    lastDrawTime = computer.uptime()

    clearScreen() -- Полная очистка экрана при каждой полной перерисовке
    drawHeader()
    drawItems()
    drawSearchBar()
    drawButtons()
    drawLogs() -- Логи теперь в самом низу
    drawFooter()
    drawTooltip()
    g.setResolution(WIDTH, HEIGHT)
end

-------------------- IO и действия --------------------
local function reload()
    local ok, res = pcall(uoc.loadf, DATA_FILE)
    dataItems = ok and res or {}

    local me_network_items = {}
    local ok_net, network_items = pcall(me.getItemsInNetwork)
    if ok_net then
        addLog("Получение предметов из ME сети...", "DEBUG") -- Отладка
        for _, stack in ipairs(network_items) do
            local key = stack.name .. (stack.damage and ":" .. stack.damage or "")
            me_network_items[key] = (me_network_items[key] or 0) + (stack.size or stack.qty or 0)
            addLog(string.format("ME: %s (dmg:%s) size:%s -> key: %s", stack.name, tostring(stack.damage), tostring(stack.size or stack.qty), key), "DEBUG") -- Отладка
        end
    else
        addLog("Не удалось получить список предметов из ME сети: " .. tostring(network_items), "ERROR")
    end

    for _,item in ipairs(dataItems) do
        local key = item.id .. (item.dmg and ":" .. item.dmg or "")
        item.current = me_network_items[key] or 0
        addLog(string.format("Data: %s (id:%s dmg:%s) current: %s", item.name, item.id, tostring(item.dmg), tostring(item.current)), "DEBUG") -- Отладка
    end
    addLog("Данные и количество предметов обновлены.", "INFO")
end

local function save()
    local ok, err = pcall(uoc.savef, DATA_FILE, dataItems)
    if not ok then addLog("Ошибка сохранения: "..tostring(err), "ERROR") end
end

local function resetSelection()
    search = ""
    itemScroll = 1
    selectedItemIdx = nil
end

local function addItem()
    changeitem = true
    hoveredButton = nil -- Сбрасываем состояние наведенной кнопки
    term.showCursor(true) -- Показываем курсор для ввода

    -- Очищаем экран и рисуем только подсказки для ввода
    clearScreen()
    uoc.drawText(10,HEIGHT-9,"Вставьте предмет в 1-й слот ME интерфейса и введите параметры.",COLORS.ok)
    uoc.drawText(10,HEIGHT-8,"Название: ",COLORS.text)
    term.setCursor(20,HEIGHT-8)
    term.write(string.rep(" ", WIDTH - 20 - 1)) -- Очищаем остаток строки
    term.setCursor(20,HEIGHT-8) -- Снова устанавливаем курсор
    local name = tostring(io.read())
    if name == "" then name = "Новый предмет" end

    clearScreen() -- Очищаем экран перед следующим запросом
    uoc.drawText(10,HEIGHT-9,"Вставьте предмет в 1-й слот ME интерфейса и введите параметры.",COLORS.ok)
    uoc.drawText(10,HEIGHT-8,"Название: "..unicode.sub(name, 1, WIDTH - 10 - unicode.len("Название: ")),COLORS.text) -- Показываем уже введенное имя, обрезая
    uoc.drawText(10,HEIGHT-7,"Держать (число, 0 для пропуска): ",COLORS.text)
    term.setCursor(39,HEIGHT-7)
    term.write(string.rep(" ", WIDTH - 39 - 1)) -- Очищаем остаток строки
    term.setCursor(39,HEIGHT-7)
    local count = tonumber(io.read()) or 0

    clearScreen() -- Очищаем экран перед следующим запросом
    uoc.drawText(10,HEIGHT-9,"Вставьте предмет в 1-й слот ME интерфейса и введите параметры.",COLORS.ok)
    uoc.drawText(10,HEIGHT-8,"Название: "..unicode.sub(name, 1, WIDTH - 10 - unicode.len("Название: ")),COLORS.text)
    uoc.drawText(10,HEIGHT-7,"Держать: "..count,COLORS.text)
    uoc.drawText(10,HEIGHT-6,"Крафт за раз (число, 1 для пропуска): ",COLORS.text)
    term.setCursor(39,HEIGHT-6)
    term.write(string.rep(" ", WIDTH - 39 - 1)) -- Очищаем остаток строки
    term.setCursor(39,HEIGHT-6)
    local craftSize = tonumber(io.read()) or 1

    local stack = nil
    local ok, res = pcall(me.getStackInSlot, 1)
    if ok and res then stack = res end

    if stack then
        table.insert(dataItems, {name=name, id=stack.name, dmg=stack.damage, count=count, craftSize=craftSize, current=0})
        save()
        addLog("Добавлен предмет: "..(name or "?") .. " (" .. stack.name .. ")","INFO")
    else
        addLog("Ошибка: нет предмета в слоте 1 ME интерфейса!","ERROR")
    end
    changeitem = false
    term.showCursor(false) -- Скрываем курсор
    resetSelection()
    reload()
    draw() -- Обновляем экран после добавления
end

local function editItem()
    if not selectedItemIdx then return addLog("Не выбран предмет для изменения!","ERROR") end
    local item = dataItems[selectedItemIdx]
    if not item then return addLog("Выбранный предмет не существует (возможно, был удален).","ERROR") end

    changeitem = true
    hoveredButton = nil -- Сбрасываем состояние наведенной кнопки
    term.showCursor(true) -- Показываем курсор для ввода

    -- Очищаем экран и рисуем только подсказки для ввода
    clearScreen()
    uoc.drawText(10,HEIGHT-9,"Изменение: "..(item.name or "<??>"),COLORS.ok)
    uoc.drawText(10,HEIGHT-8,"Новое имя (Enter пропустить): ",COLORS.text)
    term.setCursor(40,HEIGHT-8)
    term.write(string.rep(" ", WIDTH - 40 - 1)) -- Очищаем остаток строки
    term.setCursor(40,HEIGHT-8)
    local name = tostring(io.read())
    if name ~= "" then
        item.name = name
    end

    clearScreen() -- Очищаем экран перед следующим запросом
    uoc.drawText(10,HEIGHT-9,"Изменение: "..(item.name or "<??>"),COLORS.ok)
    uoc.drawText(10,HEIGHT-8,"Новое имя: "..unicode.sub(item.name or "<??>", 1, WIDTH - 10 - unicode.len("Новое имя: ")),COLORS.text) -- Показываем уже введенное имя, обрезая
    uoc.drawText(10,HEIGHT-7,"Новое держать (число, Enter пропустить): ",COLORS.text)
    term.setCursor(54,HEIGHT-7)
    term.write(string.rep(" ", WIDTH - 54 - 1)) -- Очищаем остаток строки
    term.setCursor(54,HEIGHT-7)
    local countstr = tostring(io.read())
    local count = tonumber(countstr)
    if countstr ~= "" and count then item.count = count end

    clearScreen() -- Очищаем экран перед следующим запросом
    uoc.drawText(10,HEIGHT-9,"Изменение: "..(item.name or "<??>"),COLORS.ok)
    uoc.drawText(10,HEIGHT-8,"Новое имя: "..unicode.sub(item.name or "<??>", 1, WIDTH - 10 - unicode.len("Новое имя: ")),COLORS.text)
    uoc.drawText(10,HEIGHT-7,"Новое держать: "..(item.count or 0),COLORS.text)
    uoc.drawText(10,HEIGHT-6,"Новый крафт за раз (число, Enter пропустить): ",COLORS.text)
    term.setCursor(55,HEIGHT-6)
    term.write(string.rep(" ", WIDTH - 55 - 1)) -- Очищаем остаток строки
    term.setCursor(55,HEIGHT-6)
    local csstr = tostring(io.read())
    local cs = tonumber(csstr)
    if csstr ~= "" and cs then item.craftSize = cs end

    save()
    addLog("Изменено: "..item.name,"INFO")
    changeitem = false
    term.showCursor(false) -- Скрываем курсор
    resetSelection()
    reload()
    draw() -- Обновляем экран после изменения
end

local function removeItem()
    if not selectedItemIdx then return addLog("Не выбран предмет для удаления!","ERROR") end
    if not dataItems[selectedItemIdx] then return addLog("Выбранный предмет не существует (возможно, был удален).","ERROR") end

    addLog("Удалён: "..(dataItems[selectedItemIdx].name or "<??>"),"WARN")
    table.remove(dataItems,selectedItemIdx)
    selectedItemIdx = nil
    save()
    draw()
end

local function doCraft()
    isCrafting = true
    craftStatus = "Автокрафт..."
    addLog("Запущен автокрафт","INFO")
    save()
    draw()
end

local function stopCraft()
    isCrafting = false
    craftStatus = "Остановлено"
    addLog("Остановлен автокрафт","WARN")
    save()
    draw()
end

-------------------- Основной цикл автокрафта --------------------
local function autoCraftLoop()
    while true do
        if isCrafting then
            local now = computer.uptime()
            if now >= nextCraftUpdate then
                reload()
                local craftedThisCycle = false
                for i, item in ipairs(dataItems) do
                    local count = tonumber(item.count) or 0
                    local craftSize = tonumber(item.craftSize) or 1
                    local current = tonumber(item.current) or 0

                    if current < count then
                        local requiredAmount = count - current
                        local amountToCraft = math.min(craftSize, requiredAmount)

                        local ok_cpus, cpus = pcall(me.getCpus)
                        cpus = ok_cpus and cpus or {}
                        local freeCpu = nil
                        for _,cpu in ipairs(cpus) do
                            if not cpu.busy then freeCpu = cpu.name break end
                        end

                        if freeCpu then
                            local ok_craftables, craftables = pcall(me.getCraftables, {name=item.id, damage=item.dmg})
                            craftables = ok_craftables and craftables or {}

                            if #craftables >= 1 then
                                local recipe = craftables[1]
                                local succ, req = pcall(function() return recipe.request(amountToCraft, false, freeCpu) end)
                                if succ and req then
                                    craftStatus = "Крафт: "..(item.name or "<??>") .. " (" .. amountToCraft .. "x)"
                                    addLog("Запрошен крафт "..amountToCraft.."x "..(item.name or "<??>").." на CPU "..tostring(freeCpu),"INFO")
                                    craftedThisCycle = true
                                    break
                                else
                                    craftStatus = "Ошибка: запрос крафта " .. (item.name or "<??>") .. ": " .. tostring(req)
                                    addLog("Ошибка: не удалось отправить крафт "..(item.name or "<??>")..": "..tostring(req),"ERROR")
                                end
                            else
                                craftStatus = "Ошибка: нет рецепта для "..(item.name or "<??>")
                                addLog("Ошибка: нет рецепта для "..(item.name or "<??>"),"ERROR")
                            end
                        else
                            craftStatus = "Ожидание CPU..."
                            addLog("Нет свободных CPU для крафта.", "WARN")
                            break
                        end
                    end
                end
                if not craftedThisCycle and isCrafting then
                    craftStatus = "Ожидание..."
                    if #dataItems == 0 then craftStatus = "Нет предметов для крафта" end
                end
                save()
                nextCraftUpdate = now + 5
            end
        end
        draw()
        os.sleep(0.1)
    end
end

-------------------- События --------------------
event.listen("touch", function(_,_,x,y,_,_)
    if changeitem then return end

    hoveredButton = nil -- Сбрасываем наведение при клике
    tooltip = ""

    local btns = {
        {idx=1, x=WIDTH-60, y=BUTTON_Y, w=12, h=3},
        {idx=2, x=WIDTH-45, y=BUTTON_Y, w=12, h=3},
        {idx=3, x=WIDTH-30, y=BUTTON_Y, w=12, h=3},
        {idx=4, x=WIDTH-15, y=BUTTON_Y, w=12, h=3},
    }
    for i,btn in ipairs(btns) do
        if x >= btn.x and x <= btn.x+btn.w-1 and y >= btn.y and y <= btn.y+btn.h-1 then
            hoveredButton = btn.idx
            if btn.idx==1 then removeItem()
            elseif btn.idx==2 then editItem()
            elseif btn.idx==3 then if isCrafting then stopCraft() else doCraft() end
            elseif btn.idx==4 then addItem()
            end
            draw()
            return
        end
    end

    local searchBarX, searchBarY, searchBarW, searchBarH = 3, SEARCH_BAR_Y, WIDTH-6, SEARCH_BAR_HEIGHT
    if x >= searchBarX and x <= searchBarX + searchBarW - 1 and y >= searchBarY and y <= searchBarY + searchBarH - 1 then
        if x >= searchBarX + searchBarW - 3 and x <= searchBarX + searchBarW - 1 and search ~= "" then
            search = ""
            searchActive = false
            addLog("Поиск очищен.", "INFO")
        else
            searchActive = true
        end
        draw()
        return
    else
        searchActive = false
    end

    local itemsStartY = TABLE_Y_START + 3 -- Начало строк данных в таблице
    local itemsEndY = itemsStartY + TABLE_VISIBLE_ROWS - 1 -- Конец строк данных в таблице

    if y >= itemsStartY and y <= itemsEndY then
        local idxInShowItems = (y-itemsStartY) + itemScroll
        local showItems = {}
        for i,item in ipairs(dataItems) do
            if search == "" or unicode.lower(item.name or ""):find(unicode.lower(search), 1, true) then
                table.insert(showItems, item)
            end
        end

        if showItems[idxInShowItems] then
            selectedItemIdx = nil
            for k,v in ipairs(dataItems) do
                if v == showItems[idxInShowItems] then
                    selectedItemIdx = k
                    break
                end
            end
            addLog("Выбран предмет: " .. (dataItems[selectedItemIdx].name or "<??>"), "INFO")
        end
    else
        selectedItemIdx = nil
    end

    draw()
end)

event.listen("drag", function(_,_,x,y,_,_)
    if changeitem then return end
    hoveredButton = nil
    tooltip = ""

    local btns = {
        {idx=1, x=WIDTH-60, y=BUTTON_Y, w=12, h=3},
        {idx=2, x=WIDTH-45, y=BUTTON_Y, w=12, h=3},
        {idx=3, x=WIDTH-30, y=BUTTON_Y, w=12, h=3},
        {idx=4, x=WIDTH-15, y=BUTTON_Y, w=12, h=3},
    }
    for i,btn in ipairs(btns) do
        if x >= btn.x and x <= btn.x+btn.w-1 and y >= btn.y and y <= btn.y+btn.h-1 then
            hoveredButton = btn.idx
            tooltipTimeout = os.time()
            if btn.idx == 1 then tooltip = "Удалить выбранный предмет из списка"
            elseif btn.idx == 2 then tooltip = "Изменить параметры выбранного предмета"
            elseif btn.idx == 3 then tooltip = (isCrafting and "Остановить автокрафт" or "Запустить автокрафт")
            elseif btn.idx == 4 then tooltip = "Добавить новый предмет (предмет в 1 слоте ME интерфейса)"
            end
            draw()
            return
        end
    end
    draw()
end)

event.listen("key_down", function(_,_,key,_,_)
    if changeitem then return end

    local showItems = {}
    for i,item in ipairs(dataItems) do
        if search == "" or unicode.lower(item.name or ""):find(unicode.lower(search), 1, true) then
            table.insert(showItems, item)
        end
    end
    local perPage = TABLE_VISIBLE_ROWS

    if searchActive then
        if key == 14 then -- backspace
            search = unicode.sub(search, 1, unicode.len(search)-1) -- Корректное удаление Unicode символов
        elseif key == 211 then -- delete
            search = ""
        elseif key == 28 then -- enter
            searchActive = false
        end
        itemScroll = 1
        selectedItemIdx = nil
    else
        if key == 200 then -- up
            itemScroll = math.max(1,itemScroll-1)
        elseif key == 208 then -- down
            if #showItems > perPage then
                itemScroll = math.min(#showItems-perPage+1,itemScroll+1)
            end
        end
    end
    draw()
end)

event.listen("key_press", function(_, char)
    if changeitem then return end
    if searchActive then
        -- Если это не управляющий символ (Enter, Backspace и т.д.), добавляем его к поиску
        if not (char == '\n' or char == '\b' or char == '\r' or char == '\t') then -- Добавил '\t' для табуляции
            if unicode.len(search) < WIDTH-15 then
                search = search .. char
            end
        end
        itemScroll = 1
        selectedItemIdx = nil
        draw()
    end
end)


-------------------- Старт --------------------
g.setResolution(WIDTH,HEIGHT)
clearScreen() -- Полная очистка при старте
addLog("Программа запущена.", "INFO")
reload()
draw()

local craftThread = coroutine.create(autoCraftLoop)

while true do
    local status, result = coroutine.resume(craftThread)
    if not status then
        addLog("Фатальная ошибка в цикле автокрафта: "..tostring(result), "ERROR")
        draw()
        os.sleep(5)
        computer.shutdown(true)
    end

    local e = {event.pull(0.05)}
    if e[1] == "touch" then
        event.push("touch", e[2],e[3],e[4],e[5],e[6],e[7])
    elseif e[1] == "drag" then
        event.push("drag", e[2],e[3],e[4],e[5],e[6],e[7])
    elseif e[1] == "key_down" then
        event.push("key_down", e[2],e[3],e[4],e[5],e[6],e[7])
    elseif e[1] == "key_press" then
        event.push("key_press", e[2],e[3],e[4],e[5])
    end

    draw()
end
