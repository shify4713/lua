-- OpenOS 1.6.1 Lua 5.2
local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode")
-- local term = require("term") -- Original line, will be handled below
local computer = require("computer")
local g = component.gpu
local me = component.me_interface

-- Пути и библиотека
local DATA_FILE = "/home/BD.txt"
local LIB_PATH = "/lib/ultimateOC.lua"
local LIB_URL = "https://raw.githubusercontent.com/shify4713/lua/main/ultimateOC.lua"

-- Enhanced terminal loading with error handling
local term = require("term")
if not term then
  -- Output to stderr if available, otherwise print (which might not be visible if term is broken)
  local err_out = io.stderr or io.output()
  err_out:write("CRITICAL ERROR: The terminal component ('term') could not be loaded.\n")
  err_out:write("The program's UI will likely be broken. Please check your OpenComputers setup (e.g., ensure a Screen and GPU are attached and configured).\n")
  
  -- Create a dummy 'term' table to prevent crashes on method calls.
  -- Functionality relying on these terminal operations will not work.
  term = {
    setCursorPos = function(x, y)
      -- This is a no-operation function. The cursor will not be moved.
    end,
    setCursorBlink = function(blink)
      -- This is a no-operation function. Cursor blinking will not change.
    end,
    -- If other 'term' functions were directly used by this script, they would need stubs too.
    -- Note: io.read() for input might also be affected if the terminal is non-functional.
    -- This workaround primarily prevents the script from crashing due to 'term' being nil.
  }
end

if not fs.exists(LIB_PATH) then
    -- This command might print to the console, like "Saved data to ..."
    shell.execute("wget -f " .. LIB_URL .. " " .. LIB_PATH)
end
local ok, uoc = pcall(require, "ultimateOC")
if not ok then
    (io.stderr or io.output()):write("Не удалось загрузить ultimateOC.lua: " .. tostring(uoc) .. "\n")
    os.exit(1) -- Exit if library is essential and fails to load
end

if not fs.exists(DATA_FILE) then
    uoc.savef(DATA_FILE, {})
end

-------------------- Настройки --------------------
local COLORS = {
    button = 0x00BFFF,
    buttonActive = 0x1E90FF,
    border = 0x44475a,
    text = 0xF8F8F2,
    shadow = 0x282A36,
    bg = 0x23242b,
    error = 0xFF5555,
    ok = 0x50FA7B,
    log = 0x8BE9FD,
    progress_bg = 0x44475a,
    progress_fg = 0x50FA7B,
    select = 0x31313A,
    select_active = 0x44B3FF,
    search_bg = 0x282B36,
    search_border = 0x00BFFF,
    search_cross = 0xFF5555,
    search_hint = 0x888888,
    bar_shadow = 0x181920,
    tooltip_bg = 0x44475a,
    tooltip_text = 0xF8F8F2,
}
local WIDTH, HEIGHT = 110, 40
local craftStatus = "Ожидание..."
local nextCraftUpdate = 0
local isCrafting = false

-------------------- Переменные --------------------
local logs = {}
local dataItems = {}
local search = ""
local selectedItem = nil
local itemScroll = 1
local changeitem = false
local searchActive = false
local hoveredButton = nil
local tooltip = ""
local tooltipTimeout = 0

-------------------- Логгирование без времени --------------------
local function addLog(logsTable, text, lvl)
    lvl = lvl or "INFO"
    -- Время удалено из логов по запросу
    local t = string.format("[%s] %s", lvl, text)
    table.insert(logsTable, t)
    while #logsTable > 50 do table.remove(logsTable, 1) end
end

-------------------- Визуал --------------------
local function clear()
    g.setBackground(COLORS.bg)
    g.fill(1,1,WIDTH,HEIGHT," ")
    g.setForeground(COLORS.text)
end

local function shadowRect(x, y, w, h)
    g.setBackground(COLORS.bar_shadow)
    g.fill(x+1, y+h, w, 1, " ")
    g.fill(x+w, y, 1, h, " ")
    g.setBackground(COLORS.bg)
end

local function drawHeader()
    uoc.drawText(3,3,"Ultimate AutoCraft",COLORS.ok,true)
    g.setBackground(COLORS.progress_fg)
    g.fill(2,4,WIDTH-2,1," ")
    shadowRect(2,4,WIDTH-2,1)
    g.setBackground(COLORS.bg)
    uoc.drawText(WIDTH-34,3,"Статус: "..craftStatus,
        (craftStatus:find("Ошибка") and COLORS.error) or COLORS.ok)
    uoc.progressBar(3,5,WIDTH-6, isCrafting and 0.9 or 0) -- Progress bar might represent overall activity
end

local function drawLogs()
    -- Логи перемещены ниже строки поиска и их количество изменено на 3
    uoc.drawLogs(3, HEIGHT-10, logs, 3, COLORS.log)
end

local function drawItems()
    local x, y = 2, 8
    local totalWidth = WIDTH-4
    local col_name = math.floor(totalWidth * 0.45)
    local col_now = math.floor(totalWidth * 0.17)
    local col_hold = math.floor(totalWidth * 0.17)
    local col_once = totalWidth - col_name - col_now - col_hold

    g.setForeground(COLORS.select_active)
    g.set(x, y,     "┌"..string.rep("─",col_name).."┬"..string.rep("─",col_now).."┬"..string.rep("─",col_hold).."┬"..string.rep("─",col_once).."┐")
    g.set(x, y+1,   "│")
    g.setForeground(COLORS.ok)
    g.set(x+1, y+1,  string.format("%-"..col_name.."s"," Название"))
    g.setForeground(COLORS.select_active)
    g.set(x+col_name+1, y+1, "│")
    g.setForeground(COLORS.ok)
    g.set(x+col_name+2, y+1, string.format("%-"..(col_now).."s"," В наличии"))
    g.setForeground(COLORS.select_active)
    g.set(x+col_name+col_now+2, y+1, "│")
    g.setForeground(COLORS.ok)
    g.set(x+col_name+col_now+3, y+1, string.format("%-"..(col_hold).."s"," Держать"))
    g.setForeground(COLORS.select_active)
    g.set(x+col_name+col_now+col_hold+3, y+1, "│")
    g.setForeground(COLORS.ok)
    g.set(x+col_name+col_now+col_hold+4, y+1, string.format("%-"..(col_once).."s"," За раз"))
    g.setForeground(COLORS.select_active)
    g.set(x+col_name+col_now+col_hold+col_once+4, y+1, "│")
    g.set(x, y+2, "├"..string.rep("─",col_name).."┼"..string.rep("─",col_now).."┼"..string.rep("─",col_hold).."┼"..string.rep("─",col_once).."┤")

    local showItems = {}
    for i,item in ipairs(dataItems) do
        if search == "" or unicode.lower(item.name or ""):find(unicode.lower(search), 1, true) then
            table.insert(showItems, item)
        end
    end
    local perPage = HEIGHT-24 -- Height for item list area
    for i = itemScroll, math.min(#showItems, itemScroll+perPage-1) do
        local it = showItems[i]
        local isSel = (selectedItem and dataItems[selectedItem] and it==dataItems[selectedItem])
        local rowY = y+2+(i-itemScroll)+1
        g.setBackground(isSel and COLORS.select_active or COLORS.bg)
        g.setForeground(COLORS.text)
        local nameStr = unicode.sub((it.name or "<??>"), 1, col_name)
        g.set(x, rowY, "│")
        g.set(x+1, rowY, string.format("%-"..col_name.."s",nameStr))
        g.set(x+col_name+1, rowY, "│")
        g.set(x+col_name+2, rowY, string.format("%"..col_now.."s",tonumber(it.current) or 0))
        g.set(x+col_name+col_now+2, rowY, "│")
        g.set(x+col_name+col_now+3, rowY, string.format("%"..col_hold.."s",tonumber(it.count) or 0))
        g.set(x+col_name+col_now+col_hold+3, rowY, "│")
        g.set(x+col_name+col_now+col_hold+4, rowY, string.format("%"..col_once.."s",tonumber(it.craftSize) or 0))
        g.set(x+col_name+col_now+col_hold+col_once+4, rowY, "│")
        g.setBackground(COLORS.bg)
    end

    local lastRow = y+perPage+3
    g.setForeground(COLORS.select_active)
    g.set(x, lastRow, "└"..string.rep("─",col_name).."┴"..string.rep("─",col_now).."┴"..string.rep("─",col_hold).."┴"..string.rep("─",col_once).."┘")
    g.setForeground(COLORS.text)

    if #showItems > perPage then
        local barLen = math.max(2, math.floor(perPage * perPage / #showItems))
        local barTop = y+3 + math.floor((perPage-barLen) * (itemScroll-1) / math.max(1,#showItems-perPage))
        g.setForeground(COLORS.select_active)
        g.set(WIDTH-2, y+3, "│") -- Part of scrollbar track
        for i=1,perPage do
            g.set(WIDTH-2, y+2+i, "│") -- Scrollbar track
        end
        g.setForeground(COLORS.ok)
        for i=0,barLen-1 do
            g.set(WIDTH-2, barTop+i, "█") -- Scrollbar handle
        end
        g.setForeground(COLORS.text)
    end
end

local function drawSearchBar()
    local x, y, w, h = 3, HEIGHT-13, WIDTH-6, 3
    uoc.roundRect(x, y, w, h, COLORS.search_border, COLORS.search_bg)
    g.setBackground(COLORS.search_bg)
    g.fill(x+1, y+1, w-2, h-2, " ")
    g.setForeground(COLORS.search_cross)
    g.set(x+w-3, y+1, (search ~= "" and "×" or " "))
    g.setForeground(searchActive and COLORS.ok or COLORS.search_hint)
    local display = search
    if display=="" and not searchActive then display = "Поиск: введите часть названия..." end
    if searchActive then display = display .. "_" end
    
    local maxDisplayLen = w-7 -- Max characters to display in search bar
    if unicode.len(display) > maxDisplayLen then
        display = "..." .. unicode.sub(display, unicode.len(display)-maxDisplayLen+4) -- Show tail of long string
    end
    g.set(x+2, y+1, display)
    g.setBackground(COLORS.bg)
    g.setForeground(COLORS.text)
end

local function drawButtons()
    local btns = {
        {name="Удалить", x=WIDTH-60, tip="Удалить выбранный предмет из списка"},
        {name="Изменить", x=WIDTH-45, tip="Изменить параметры предмета"},
        {name=isCrafting and "Остановить" or "Автокрафт", x=WIDTH-30, tip=isCrafting and "Остановить автокрафт" or "Запустить автокрафт"},
        {name="Добавить", x=WIDTH-15, tip="Добавить новый предмет (предмет в 1 слоте интерфейса ME)"},
    }
    for i,v in ipairs(btns) do
        local hover = hoveredButton == i
        uoc.animatedButton(v.x, HEIGHT-4, 12, 3, v.name, hover, COLORS.button, COLORS.buttonActive, COLORS.text)
        if hover then
            tooltip = v.tip
            tooltipTimeout = computer.uptime() -- Use computer.uptime for consistency with other timers
        end
    end
end

local function drawTooltip()
    if tooltip ~= "" and computer.uptime() - tooltipTimeout < 3 then
        local txt = " "..tooltip.." "
        local w = unicode.len(txt)
        local xPos, yPos = WIDTH-w-3, HEIGHT-7 -- Position tooltip
        -- Ensure tooltip doesn't go off screen
        if xPos < 1 then xPos = 1 end

        g.setBackground(COLORS.tooltip_bg)
        g.setForeground(COLORS.tooltip_text)
        g.fill(xPos, yPos, w+2, 3, " ") -- Tooltip box
        g.set(xPos+1, yPos+1, txt) -- Tooltip text
        g.setBackground(COLORS.bg)
        g.setForeground(COLORS.text)
    end
end

local function draw()
    g.setResolution(WIDTH, HEIGHT) -- Ensure resolution is set before drawing
    clear()
    drawHeader()
    drawItems()
    drawSearchBar() -- Search bar drawn before logs
    drawLogs()      -- Logs drawn after search bar
    drawButtons()
    drawTooltip()
    term.setCursorPos(1,1) -- Hide terminal cursor (will use dummy if term failed to load)
    term.setCursorBlink(false) -- (will use dummy if term failed to load)
end

-------------------- IO и действия --------------------
local function reload()
    local r_ok, res = pcall(uoc.loadf, DATA_FILE)
    dataItems = r_ok and res or {}
    for _,item in ipairs(dataItems) do
        local qty = 0
        local stackList = {}
        -- Attempt to get item count from network
        local get_items_ok, items_data = pcall(function() return me.getItemsInNetwork({name = item.id, damage = item.dmg}) end)
        if get_items_ok and items_data and items_data.n and items_data.n > 0 then
            for _,stack in ipairs(items_data) do
                 -- Ensure correct item matching, especially with damage values
                if stack.name == item.id and (item.dmg == nil or stack.damage == item.dmg or (item.dmg == 0 and stack.damage == nil) or (item.dmg == nil and stack.damage == 0)) then
                    qty = qty + (stack.size or stack.qty or 0) -- Sum up if multiple stacks match
                end
            end
             if items_data.n == 1 and items_data[1].name == item.id and (item.dmg == nil or items_data[1].damage == item.dmg) then
                qty = items_data[1].size or items_data[1].qty or 0
            else -- If multiple results, iterate and sum, or handle specific logic
                for i=1,items_data.n do
                    local stack = items_data[i]
                    if stack.name == item.id and (item.dmg == nil or stack.damage == item.dmg) then
                         qty = qty + (stack.size or stack.qty or 0)
                    end
                end
            end
        else -- Fallback if getItemsInNetwork fails or returns no items
            local get_detail_ok, d = pcall(me.getItemDetail, {name = item.id, damage = item.dmg})
            if get_detail_ok and d then
                qty = d.qty or d.size or 0
            end
        end
        item.current = qty
    end
end


local function save()
    local s_ok, err = pcall(uoc.savef, DATA_FILE, dataItems)
    if not s_ok then addLog(logs, "Ошибка сохранения: "..tostring(err), "ERROR") end
end

local function resetSelection()
    search = ""
    itemScroll = 1
    selectedItem = nil
end

local function addItem()
    changeitem = true
    term.setCursorBlink(true) -- (will use dummy if term failed to load)
    clear()
    uoc.drawText(10,HEIGHT-7,"Вставьте предмет в 1-й слот ME интерфейса и введите параметры.",COLORS.ok)
    uoc.drawText(10,HEIGHT-6,"Название: ",COLORS.text)
    term.setCursorPos(20,HEIGHT-6) -- (will use dummy if term failed to load)
    io.write("\027[?25h") -- Attempt to show cursor via ANSI, might not work if term is broken
    local name = tostring(io.read() or "")
    uoc.drawText(10,HEIGHT-5,"Держать (число): ",COLORS.text)
    term.setCursorPos(29,HEIGHT-5) -- (will use dummy if term failed to load)
    local count = tonumber(io.read()) or 0
    uoc.drawText(10,HEIGHT-4,"Крафт за раз (число): ",COLORS.text)
    term.setCursorPos(32,HEIGHT-4) -- (will use dummy if term failed to load)
    local craftSize = tonumber(io.read()) or 1
    io.write("\027[?25l") -- Attempt to hide cursor via ANSI
    term.setCursorBlink(false) -- (will use dummy if term failed to load)

    local stack = nil
    local get_stack_ok, res = pcall(me.getStackInSlot, 1)
    if get_stack_ok then stack = res end

    if stack and stack.name then -- Check if stack.name exists
        table.insert(dataItems, {name=name, id=stack.name, dmg=stack.damage, count=count, craftSize=craftSize})
        save()
        addLog(logs, "Добавлен предмет: "..name,"INFO")
    else
        addLog(logs, "Ошибка: нет предмета в слоте 1 или предмет некорректен!","ERROR")
    end
    changeitem = false
    resetSelection()
end

local function editItem()
    if not selectedItem then return addLog(logs,"Не выбран предмет!","ERROR") end
    local item = dataItems[selectedItem]
    if not item then return addLog(logs,"Ошибка: выбранный предмет не найден!","ERROR") end

    changeitem = true
    term.setCursorBlink(true) -- (will use dummy if term failed to load)
    clear()
    uoc.drawText(10,HEIGHT-7,"Изменение: "..(item.name or "<??>"),COLORS.ok)
    io.write("\027[?25h") -- Attempt to show cursor

    uoc.drawText(10,HEIGHT-6,"Новое имя (Enter пропустить): ",COLORS.text)
    term.setCursorPos(40,HEIGHT-6) -- (will use dummy if term failed to load)
    local name = tostring(io.read() or "")
    if name and name ~= "" then
        item.name = name
    end

    uoc.drawText(10,HEIGHT-5,"Новое держать (число, Enter пропустить): ",COLORS.text)
    term.setCursorPos(54,HEIGHT-5) -- (will use dummy if term failed to load)
    local countstr = tostring(io.read() or "")
    if countstr ~= "" then
        local count = tonumber(countstr)
        if count then item.count = count end
    end

    uoc.drawText(10,HEIGHT-4,"Новый крафт за раз (число, Enter пропустить): ",COLORS.text)
    term.setCursorPos(55,HEIGHT-4) -- (will use dummy if term failed to load)
    local csstr = tostring(io.read() or "")
    if csstr ~= "" then
        local cs = tonumber(csstr)
        if cs then item.craftSize = cs end
    end
    
    io.write("\027[?25l") -- Attempt to hide cursor
    term.setCursorBlink(false) -- (will use dummy if term failed to load)
    save()
    addLog(logs, "Изменено: "..item.name,"INFO")
    changeitem = false
    resetSelection()
end

local function removeItem()
    if not selectedItem then return addLog(logs,"Не выбран предмет!","ERROR") end
    if not dataItems[selectedItem] then
        addLog(logs, "Ошибка: попытка удалить несуществующий предмет.", "ERROR")
        selectedItem = nil
        return
    end
    addLog(logs, "Удалён: "..(dataItems[selectedItem].name or "<??>"),"WARN")
    table.remove(dataItems,selectedItem)
    selectedItem = nil
    save()
end

local function doCraft()
    isCrafting = true
    craftStatus = "Автокрафт..."
    save() 
    addLog(logs,"Запущен автокрафт","INFO")
end

local function stopCraft()
    isCrafting = false
    craftStatus = "Остановлено"
    addLog(logs, "Остановлен автокрафт","WARN")
end

-------------------- Основной цикл автокрафта --------------------
local function autoCraftLoop()
    while true do
        if isCrafting then
            local now_time = computer.uptime()
            if now_time >= nextCraftUpdate then
                reload() -- Reload item counts from ME network

                local cpus_list_ok, all_cpus_details = pcall(me.getCpus)
                local available_cpus_for_this_scan = {}
                if cpus_list_ok and all_cpus_details then
                    for _, cpu_detail in ipairs(all_cpus_details) do
                        if not cpu_detail.busy then
                            table.insert(available_cpus_for_this_scan, cpu_detail.name)
                        end
                    end
                end
                
                local assigned_cpus_in_this_scan = {} -- Track CPUs assigned in this specific scan

                for i, item in ipairs(dataItems) do
                    local count = tonumber(item.count) or 0
                    local craftSize = tonumber(item.craftSize) or 1
                    local current = tonumber(item.current) or 0

                    if current < count then
                        local freeCpuForThisItem = nil
                        -- Find a CPU that is in available_cpus_for_this_scan AND not in assigned_cpus_in_this_scan
                        for _, cpu_name_avail in ipairs(available_cpus_for_this_scan) do
                            local is_assigned_already = false
                            for _, assigned_name in ipairs(assigned_cpus_in_this_scan) do
                                if cpu_name_avail == assigned_name then
                                    is_assigned_already = true
                                    break
                                end
                            end
                            if not is_assigned_already then
                                freeCpuForThisItem = cpu_name_avail
                                table.insert(assigned_cpus_in_this_scan, freeCpuForThisItem) -- Mark as assigned for this item in this scan
                                break
                            end
                        end

                        if freeCpuForThisItem then
                            local craftables_ok, craftables_data = pcall(me.getCraftables, {name=item.id, damage=item.dmg})
                            craftables_data = craftables_ok and craftables_data or {n=0}

                            if craftables_data.n and craftables_data.n >= 1 then
                                local delta = math.min(craftSize, count - current)
                                if delta > 0 then
                                    -- Ensure craftables_data[1] and its 'request' method exist
                                    if craftables_data[1] and type(craftables_data[1].request) == "function" then
                                        local succ_req, req_res = pcall(function() return craftables_data[1].request(delta, false, freeCpuForThisItem) end)
                                        if succ_req and req_res then
                                            craftStatus = "Крафт: "..(item.name or "<??>")
                                            addLog(logs, "Крафт "..delta.."x "..(item.name or "<??>").." на CPU "..tostring(freeCpuForThisItem),"INFO")
                                        else
                                            craftStatus = "Ошибка: запрос крафта"
                                            addLog(logs, "Ошибка: не удалось отправить крафт "..(item.name or "<??>").." (" .. tostring(req_res) .. ")","ERROR")
                                        end
                                    else
                                        craftStatus = "Ошибка: нет метода request у рецепта"
                                        addLog(logs, "Ошибка: нет метода request у рецепта для "..(item.name or "<??>"),"ERROR")
                                    end
                                end
                            else
                                craftStatus = "Ошибка: нет рецепта "..(item.name or "<??>")
                                addLog(logs, "Ошибка: нет рецепта "..(item.name or "<??>"),"ERROR")
                            end
                        else
                            addLog(logs, "Инфо: нет свободных CPU для "..(item.name or "<?>").." в этом цикле","INFO")
                            if craftStatus ~= "Ошибка: запрос крафта" and not craftStatus:find("Крафт:") then 
                                craftStatus = "Ожидание CPU..."
                            end
                        end
                    end
                end
                save() 
                nextCraftUpdate = now_time + 5 
            end
        end
        draw() 
        os.sleep(0.1) 
    end
end

-------------------- События --------------------
event.listen("touch", function(_,_,x,y,button_code,_)
    if changeitem then return end 

    local prevHoveredButton = hoveredButton
    hoveredButton = nil 

    local btns_layout = {
        {x=WIDTH-60, y=HEIGHT-4, w=12, h=3, id=1}, 
        {x=WIDTH-45, y=HEIGHT-4, w=12, h=3, id=2}, 
        {x=WIDTH-30, y=HEIGHT-4, w=12, h=3, id=3}, 
        {x=WIDTH-15, y=HEIGHT-4, w=12, h=3, id=4}, 
    }

    for i,btn_layout_item in ipairs(btns_layout) do
        if x >= btn_layout_item.x and x < btn_layout_item.x+btn_layout_item.w and y >= btn_layout_item.y and y < btn_layout_item.y+btn_layout_item.h then
            hoveredButton = btn_layout_item.id
            if button_code == 0 then 
                if btn_layout_item.id==1 then removeItem()
                elseif btn_layout_item.id==2 then editItem()
                elseif btn_layout_item.id==3 then if isCrafting then stopCraft() else doCraft() end
                elseif btn_layout_item.id==4 then addItem()
                end
            end
            return
        end
    end

    local searchBarX, searchBarY, searchBarW, searchBarH = 3, HEIGHT-13, WIDTH-6, 3
    if y >= searchBarY and y < searchBarY + searchBarH then
        if x >= searchBarX + searchBarW - 3 and x < searchBarX + searchBarW -1 and search ~= "" then
            if button_code == 0 then
                search = ""
                itemScroll = 1 
                searchActive = false 
            end
        elseif x >= searchBarX + 1 and x < searchBarX + searchBarW - 3 then
             if button_code == 0 then
                searchActive = true
             end
        else
            if button_code == 0 then searchActive = false end 
        end
        return
    else
      if button_code == 0 then searchActive = false end 
    end

    local showItemsTemp = {} 
    for _,item_entry in ipairs(dataItems) do
        if search == "" or unicode.lower(item_entry.name or ""):find(unicode.lower(search), 1, true) then
            table.insert(showItemsTemp, item_entry)
        end
    end
    local items_per_page_count = HEIGHT-24
    local itemsListY_start = 8 + 3 
    local itemsListY_end = itemsListY_start + items_per_page_count -1

    if y >= itemsListY_start and y <= itemsListY_end then
        if button_code == 0 then
            local clicked_idx_in_view = y - itemsListY_start
            local actual_idx_in_showItems = itemScroll + clicked_idx_in_view
            if showItemsTemp[actual_idx_in_showItems] then
                for k,v_data_item in ipairs(dataItems) do
                    if v_data_item == showItemsTemp[actual_idx_in_showItems] then
                        selectedItem = k
                        break
                    end
                end
            end
        end
        return
    end
    if prevHoveredButton ~= hoveredButton then 
    end
end)

event.listen("drag", function(_,_,x,y,_,_)
    if changeitem then return end
    local currentHover = nil
    local btns_layout = {
        {name="Удалить", x=WIDTH-60, y=HEIGHT-4, w=12, h=3, id=1, tip="Удалить выбранный предмет из списка"},
        {name="Изменить", x=WIDTH-45, y=HEIGHT-4, w=12, h=3, id=2, tip="Изменить параметры предмета"},
        {name=isCrafting and "Остановить" or "Автокрафт", x=WIDTH-30, y=HEIGHT-4, w=12, h=3, id=3, tip=isCrafting and "Остановить автокрафт" or "Запустить автокрафт"},
        {name="Добавить", x=WIDTH-15, y=HEIGHT-4, w=12, h=3, id=4, tip="Добавить новый предмет (предмет в 1 слоте интерфейса ME)"},
    }
    for _,btn_layout_item in ipairs(btns_layout) do
        if x >= btn_layout_item.x and x < btn_layout_item.x+btn_layout_item.w and y >= btn_layout_item.y and y < btn_layout_item.y+btn_layout_item.h then
            currentHover = btn_layout_item.id
            tooltip = btn_layout_item.tip
            tooltipTimeout = computer.uptime()
            break
        end
    end
    if hoveredButton ~= currentHover then
        hoveredButton = currentHover
        if not hoveredButton then tooltip = "" end 
    end
end)

event.listen("scroll", function(_, _, x, y, direction, _)
    if changeitem then return end
    local items_per_page_count = HEIGHT-24
    local itemsListY_start = 8 + 3 
    local itemsListY_end = itemsListY_start + items_per_page_count -1
    
    if y >= itemsListY_start and y <= itemsListY_end then
        local showItemsTemp = {}
        for _,item_entry in ipairs(dataItems) do
            if search == "" or unicode.lower(item_entry.name or ""):find(unicode.lower(search), 1, true) then
                table.insert(showItemsTemp, item_entry)
            end
        end

        if direction < 0 then 
            itemScroll = math.max(1, itemScroll - 1)
        elseif direction > 0 then 
            if #showItemsTemp > items_per_page_count then
                itemScroll = math.min(#showItemsTemp - items_per_page_count + 1, itemScroll + 1)
            end
        end
    end
end)


event.listen("key_down", function(_, _, keyCode, charStr, _)
    if changeitem then return end

    local showItemsFiltered = {} 
    for _,item_entry in ipairs(dataItems) do
        if search == "" or unicode.lower(item_entry.name or ""):find(unicode.lower(search), 1, true) then
            table.insert(showItemsFiltered, item_entry)
        end
    end
    local items_per_page_count = HEIGHT-24
    local search_max_len = (WIDTH-6)-7 

    if searchActive then
        if keyCode == 14 then 
            if unicode.len(search) > 0 then
                search = unicode.sub(search, 1, unicode.len(search) - 1)
            end
        elseif keyCode == 211 then 
            search = ""
        elseif keyCode == 28 or keyCode == 156 then 
            searchActive = false
        elseif type(charStr) == "string" and unicode.len(charStr) > 0 then
            local firstByte = string.byte(charStr, 1)
            if firstByte >= 32 or unicode.len(charStr) > 1 then 
                 if unicode.len(search) < search_max_len then
                    search = search .. charStr
                end
            end
        end
        itemScroll = 1 
    else 
        if keyCode == 200 then 
            itemScroll = math.max(1,itemScroll-1)
        elseif keyCode == 208 then 
            if #showItemsFiltered > items_per_page_count then
                itemScroll = math.min(#showItemsFiltered - items_per_page_count + 1, itemScroll + 1)
            end
        elseif keyCode == 201 then 
            itemScroll = math.max(1, itemScroll - items_per_page_count)
        elseif keyCode == 209 then 
             if #showItemsFiltered > items_per_page_count then
                itemScroll = math.min(#showItemsFiltered - items_per_page_count + 1, itemScroll + items_per_page_count)
            end
        elseif keyCode == 28 or keyCode == 156 then 
        end
    end
end)

-------------------- Старт --------------------
-- term.setCursorBlink and term.setCursorPos are called after term is potentially replaced by a dummy
term.setCursorBlink(false)
term.setCursorPos(1,1)
g.setResolution(WIDTH,HEIGHT) 
reload()

local final_ok, final_err = pcall(autoCraftLoop)
if not final_ok then
    pcall(function()
        clear()
        g.setForeground(COLORS.error)
        local err_msg = "Фатальная ошибка: " .. tostring(final_err)
        local y_pos = math.floor(HEIGHT / 2)
        g.set(math.floor((WIDTH - unicode.len(err_msg)) / 2), y_pos, err_msg)
        
        local temp_logs = {}
        addLog(temp_logs, "Фатальная ошибка: "..tostring(final_err), "FATAL") 
        if temp_logs[1] then
             g.set(math.floor((WIDTH - unicode.len(temp_logs[1])) / 2), y_pos + 1, temp_logs[1])
        end
        (io.stderr or io.output()):write("LUA SCRIPT FATAL ERROR: " .. err_msg .. "\n")
    end)
    os.sleep(5)
    computer.shutdown(true) 
end
