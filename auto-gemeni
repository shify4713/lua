-- Ultimate AutoCraft for OpenComputers (Lua 5.2, OpenOS 1.6.1)
-- Combines robust crafting from pre craft with enhanced UI from auto-gemeni
local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode")
local term = require("term")
local computer = require("computer")

-- Paths and library
local DATA_FILE = "/home/BD.txt"
local LIB_PATH = "/lib/ultimateOC.lua"
local LIB_URL = "https://raw.githubusercontent.com/shify4713/lua/main/ultimateOC.lua"

-- Component checks
local function checkComponents()
    if not component.isAvailable("gpu") then error("GPU unavailable") end
    if not component.isAvailable("screen") then error("Screen unavailable") end
    if not component.isAvailable("me_interface") then error("ME Interface unavailable") end
end

-- Bind GPU to screen
local function bindGpu()
    local screen = component.list("screen")()
    if not screen then error("No screen found for GPU binding") end
    component.gpu.bind(screen)
    return true
end

-- Load or download library
if not fs.exists(LIB_PATH) then
    local success, err = shell.execute("wget -f " .. LIB_URL .. " " .. LIB_PATH)
    if not success then error("Failed to download ultimateOC.lua: " .. tostring(err)) end
end
local uoc = require("ultimateOC")

-- Settings
local COLORS = {
    button = 0x00BFFF, buttonActive = 0x1E90FF, border = 0x44475a, text = 0xF8F8F2,
    shadow = 0x282A36, bg = 0x23242b, error = 0xFF5555, ok = 0x50FA7B, log = 0x8BE9FD,
    progress_bg = 0x44475a, progress_fg = 0x50FA7B, select = 0x31313A, select_active = 0x44B3FF,
    search_bg = 0x282B36, search_border = 0x00BFFF, search_cross = 0xFF5555, search_hint = 0x888888,
    warning = 0xFFB86C, input_bg = 0x282B36, input_border = 0x00BFFF, input_text = 0xF8F8F2
}
local WIDTH, HEIGHT = component.gpu.getResolution()
local ADM = {['KReaTlVNuY'] = true, ['LiwMorgan] = true}
local craftStatus = "Waiting..."
local isCrafting = false
local logs = {}
local dataItems = {}
local settings = {sortCriteria = "name", sortAscending = true}
local search = ""
local selectedItem = nil
local currentPage = 1
local changeitem = false
local searchActive = false
local logOffset = 0
local lastRequestedItem = nil
local lastRequestTime = 0
local buttonHover = nil
local inputMode = nil
local inputFields = {}
local maxscroll = 1
local scroll = 1
local posSelect = nil

-- Helper functions
local function saveData()
    uoc.savef(DATA_FILE, {items = dataItems, settings = settings})
end

local function loadData()
    local data = uoc.loadf(DATA_FILE) or {items = {}, settings = {sortCriteria = "name", sortAscending = true}}
    dataItems = data.items or {}
    settings = data.settings or {sortCriteria = "name", sortAscending = true}
    for _, item in ipairs(dataItems) do
        item.category = item.category or "No Category"
        item.current = item.current or 0
    end
end

local function getFilteredAndSortedItems()
    local filtered = uoc.filterItems(dataItems, search)
    table.sort(filtered, function(a, b)
        local valA, valB
        if settings.sortCriteria == "name" then
            valA, valB = unicode.lower(a.name or ""), unicode.lower(b.name or "")
        elseif settings.sortCriteria == "current" then
            valA, valB = tonumber(a.current) or 0, tonumber(b.current) or 0
        elseif settings.sortCriteria == "count" then
            valA, valB = tonumber(a.count) or 0, tonumber(b.count) or 0
        elseif settings.sortCriteria == "craftSize" then
            valA, valB = tonumber(a.craftSize) or 0, tonumber(b.craftSize) or 0
        elseif settings.sortCriteria == "category" then
            valA, valB = unicode.lower(a.category or "No Category"), unicode.lower(b.category or "No Category")
        end
        return settings.sortAscending and valA < valB or valA > valB
    end)
    return filtered
end

local function getItemsPerPage()
    return HEIGHT - 20
end

local function getMaxPages()
    return math.max(1, math.ceil(#getFilteredAndSortedItems() / getItemsPerPage()))
end

local function clampPage()
    currentPage = math.max(1, math.min(currentPage, getMaxPages()))
end

-- GUI functions
local function clear()
    component.gpu.setBackground(COLORS.bg)
    component.gpu.fill(1, 1, WIDTH, HEIGHT, " ")
    component.gpu.setForeground(COLORS.text)
end

local function drawHeader()
    uoc.drawText(2, 2, "Ultimate AutoCraft", COLORS.ok, COLORS.shadow)
    uoc.roundRect(1, 3, WIDTH, 1, COLORS.progress_fg, COLORS.progress_fg)
    uoc.drawText(2, 4, "Status: " .. craftStatus, (craftStatus:find("Error") and COLORS.error) or COLORS.ok, COLORS.shadow)
    uoc.progressBar(2, 5, WIDTH - 20, isCrafting and 0.9 or 0, COLORS.progress_fg, COLORS.progress_bg)
    uoc.drawText(2, 6, "Page: " .. currentPage .. "/" .. getMaxPages(), COLORS.text, COLORS.shadow)
end

local function drawItems()
    local filteredItems = getFilteredAndSortedItems()
    local x, y = 1, 8
    local totalWidth = WIDTH - 25
    local col_name = math.floor(totalWidth * 0.35)
    local col_category = math.floor(totalWidth * 0.15)
    local col_now = math.floor(totalWidth * 0.15)
    local col_hold = math.floor(totalWidth * 0.15)
    local col_once = totalWidth - col_name - col_category - col_now - col_hold

    component.gpu.setForeground(COLORS.select_active)
    component.gpu.set(x, y, "┌" .. string.rep("─", col_name) .. "┬" .. string.rep("─", col_category) .. "┬" .. string.rep("─", col_now) .. "┬" .. string.rep("─", col_hold) .. "┬" .. string.rep("─", col_once) .. "┐")
    component.gpu.set(x, y + 1, "│")
    component.gpu.setForeground(COLORS.ok)
    component.gpu.set(x + 1, y + 1, string.format("%-" .. col_name .. "s", "Name"))
    component.gpu.setForeground(COLORS.select_active)
    component.gpu.set(x + col_name + 1, y + 1, "│")
    component.gpu.setForeground(COLORS.ok)
    component.gpu.set(x + col_name + 2, y + 1, string.format("%-" .. col_category .. "s", "Category"))
    component.gpu.setForeground(COLORS.select_active)
    component.gpu.set(x + col_name + col_category + 2, y + 1, "│")
    component.gpu.setForeground(COLORS.ok)
    component.gpu.set(x + col_name + col_category + 3, y + 1, string.format("%-" .. col_now .. "s", "Current"))
    component.gpu.setForeground(COLORS.select_active)
    component.gpu.set(x + col_name + col_category + col_now + 3, y + 1, "│")
    component.gpu.setForeground(COLORS.ok)
    component.gpu.set(x + col_name + col_category + col_now + 4, y + 1, string.format("%-" .. col_hold .. "s", "Target"))
    component.gpu.setForeground(COLORS.select_active)
    component.gpu.set(x + col_name + col_category + col_now + col_hold + 4, y + 1, "│")
    component.gpu.setForeground(COLORS.ok)
    component.gpu.set(x + col_name + col_category + col_now + col_hold + 5, y + 1, string.format("%-" .. col_once .. "s", "Craft Size"))
    component.gpu.setForeground(COLORS.select_active)
    component.gpu.set(x + col_name + col_category + col_now + col_hold + col_once + 5, y + 1, "│")
    component.gpu.set(x, y + 2, "├" .. string.rep("─", col_name) .. "┼" .. string.rep("─", col_category) .. "┼" .. string.rep("─", col_now) .. "┼" .. string.rep("─", col_hold) .. "┼" .. string.rep("─", col_once) .. "┤")

    local perPage = getItemsPerPage()
    local startIndex = (currentPage - 1) * perPage + 1
    for i = startIndex, math.min(#filteredItems, startIndex + perPage - 1) do
        local item = filteredItems[i]
        local isSel = (selectedItem and dataItems[selectedItem] == item)
        local row = y + 2 + (i - startIndex)
        component.gpu.setBackground(isSel and COLORS.select_active or COLORS.bg)
        component.gpu.fill(x, row, totalWidth + 2, 1, " ")
        component.gpu.setForeground(tonumber(item.current or 0) < tonumber(item.count or 0) and COLORS.warning or COLORS.text)
        component.gpu.set(x, row, "│")
        local nameStr = tostring(item.name or "<?>")
        if unicode.len(nameStr) > col_name then nameStr = unicode.sub(nameStr, 1, col_name - 1) .. "…" end
        component.gpu.set(x + 1, row, string.format("%-" .. col_name .. "s", nameStr))
        component.gpu.set(x + col_name + 1, row, "│")
        local categoryStr = tostring(item.category or "No Category")
        if unicode.len(categoryStr) > col_category then categoryStr = unicode.sub(categoryStr, 1, col_category - 1) .. "…" end
        component.gpu.set(x + col_name + 2, row, string.format("%-" .. col_category .. "s", categoryStr))
        component.gpu.set(x + col_name + col_category + 2, row, "│")
        local currentStr = tostring(item.current or 0)
        if unicode.len(currentStr) > col_now then currentStr = unicode.sub(currentStr, 1, col_now - 1) .. "…" end
        component.gpu.set(x + col_name + col_category + 3, row, string.format("%-" .. col_now .. "s", currentStr))
        component.gpu.set(x + col_name + col_category + col_now + 3, row, "│")
        local holdStr = tostring(item.count or 0)
        if unicode.len(holdStr) > col_hold then holdStr = unicode.sub(holdStr, 1, col_hold - 1) .. "…" end
        component.gpu.set(x + col_name + col_category + col_now + 4, row, string.format("%-" .. col_hold .. "s", holdStr))
        component.gpu.set(x + col_name + col_category + col_now + col_hold + 4, row, "│")
        local craftSizeStr = tostring(item.craftSize or 0)
        if unicode.len(craftSizeStr) > col_once then craftSizeStr = unicode.sub(craftSizeStr, 1, col_once - 1) .. "…" end
        component.gpu.set(x + col_name + col_category + col_now + col_hold + 5, row, string.format("%-" .. col_once .. "s", craftSizeStr))
        component.gpu.set(x + col_name + col_category + col_now + col_hold + col_once + 5, row, "│")
    end
    component.gpu.setForeground(COLORS.select_active)
    component.gpu.set(x, y + perPage + 2, "└" .. string.rep("─", col_name) .. "┴" .. string.rep("─", col_category) .. "┴" .. string.rep("─", col_now) .. "┴" .. string.rep("─", col_hold) .. "┴" .. string.rep("─", col_once) .. "┘")
    component.gpu.setBackground(COLORS.bg)
    component.gpu.setForeground(COLORS.text)
end

local function drawSearchBar()
    local x, y = 2, HEIGHT - 10
    local w, h = WIDTH - 20, 3
    uoc.roundRect(x, y, w, h, COLORS.search_border, COLORS.search_bg)
    component.gpu.setBackground(COLORS.search_bg)
    component.gpu.fill(x + 1, y + 1, w - 2, h - 2, " ")
    component.gpu.setForeground(COLORS.search_cross)
    component.gpu.set(x + w - 3, y + 1, search ~= "" and "×" or " ")
    component.gpu.setForeground(searchActive and COLORS.ok or COLORS.search_hint)
    local display = search == "" and "Search: enter item name..." or search
    if searchActive then display = display .. "_" end
    local maxlen = w - 7
    if unicode.len(display) > maxlen then
        display = unicode.sub(display, unicode.len(display) - maxlen + 1)
    end
    component.gpu.set(x + 2, y + 1, display)
    component.gpu.setBackground(COLORS.bg)
    component.gpu.setForeground(COLORS.text)
end

local function drawLogs()
    uoc.drawLogs(2, HEIGHT - 5, logs, 5, COLORS.log, logOffset)
end

local function drawButtons()
    local btnWidth, btnHeight, btnPadding = 12, 3, 2
    local btnX = WIDTH - btnWidth - 5
    local btns = {
        {name = "Delete", action = "delete"},
        {name = "Edit", action = "edit"},
        {name = isCrafting and "Stop" or "AutoCraft", action = "toggleCraft"},
        {name = "Add", action = "add"}
    }
    for i, btn in ipairs(btns) do
        local btnY = 10 + (i - 1) * (btnHeight + btnPadding)
        uoc.animatedButton(btnX, btnY, btnWidth, btnHeight, btn.name, buttonHover == btn.action, COLORS.button, COLORS.buttonActive, COLORS.text)
    end
    local arrowBtnW, arrowBtnH = 4, 3
    local arrowBtnY = 10 + (#btns * (btnHeight + btnPadding))
    local prevArrowBtnX, nextArrowBtnX = btnX, btnX + arrowBtnW + 1
    local prevEnabled, nextEnabled = currentPage > 1, currentPage < getMaxPages()
    uoc.animatedButton(prevArrowBtnX, arrowBtnY, arrowBtnW, arrowBtnH, "<-", buttonHover == "prevPage",
        prevEnabled and COLORS.button or COLORS.border, prevEnabled and COLORS.buttonActive or COLORS.border,
        prevEnabled and COLORS.text or COLORS.search_hint)
    uoc.animatedButton(nextArrowBtnX, arrowBtnY, arrowBtnW, arrowBtnH, "->", buttonHover == "nextPage",
        nextEnabled and COLORS.button or COLORS.border, nextEnabled and COLORS.buttonActive or COLORS.border,
        nextEnabled and COLORS.text or COLORS.search_hint)
    local sortBtnY, sortBtnW = arrowBtnY + arrowBtnH + 2, 12
    local sortText = "Sort: "
    local sortIndicator = settings.sortCriteria == "name" and "Name" or
                         settings.sortCriteria == "current" and "Curr." or
                         settings.sortCriteria == "count" and "Tgt." or
                         settings.sortCriteria == "craftSize" and "Size" or
                         settings.sortCriteria == "category" and "Cat." or ""
    sortIndicator = sortIndicator .. (settings.sortAscending and "↑" or "↓")
    local fullSortText = sortText .. sortIndicator
    if unicode.len(fullSortText) > sortBtnW then
        fullSortText = unicode.sub(fullSortText, 1, sortBtnW - 1)
    end
    uoc.animatedButton(btnX, sortBtnY, sortBtnW, arrowBtnH, fullSortText, buttonHover == "sort", COLORS.button, COLORS.buttonActive, COLORS.text)
end

local function draw()
    if not changeitem then
        clear()
        drawHeader()
        drawItems()
        drawSearchBar()
        drawLogs()
        drawButtons()
    end
end

local function promptForInput(label, keyName, isNumeric, defaultValue)
    local currentInput = inputFields[keyName] or tostring(defaultValue or "")
    local baseY = HEIGHT - 15
    local fieldsConfig = {
        {label = "Name:", key = "name", x = 2, y = baseY + 3, w = 40},
        {label = "Category:", key = "category", x = 2, y = baseY + 5, w = 40},
        {label = "Target:", key = "count", x = 2, y = baseY + 7, w = 20},
        {label = "Craft Size:", key = "craftSize", x = 2, y = baseY + 9, w = 20}
    }
    local currentFieldConfig = nil
    for _, config in ipairs(fieldsConfig) do
        if config.key == keyName then currentFieldConfig = config break end
    end
    local function redrawInputScreen(activeInput)
        clear()
        uoc.drawText(2, baseY, inputMode == "add" and "Add Item" or "Edit: " .. (dataItems[selectedItem].name or "<?>"), COLORS.ok, COLORS.shadow)
        uoc.drawText(2, baseY + 1, "Insert item in ME interface slot 1 (for adding).", COLORS.ok, COLORS.shadow)
        uoc.drawText(2, baseY + 12, "Enter: save/skip, Ctrl+C: cancel", COLORS.text, COLORS.shadow)
        for _, field in ipairs(fieldsConfig) do
            local isActiveField = (field.key == keyName)
            uoc.roundRect(field.x, field.y, field.w, 3, COLORS.input_border, COLORS.input_bg)
            component.gpu.setForeground(COLORS.text)
            component.gpu.set(field.x + 1, field.y, field.label)
            component.gpu.setBackground(COLORS.input_bg)
            component.gpu.fill(field.x + 1, field.y + 1, field.w - 2, 1, " ")
            component.gpu.setForeground(isActiveField and COLORS.ok or COLORS.input_text)
            local displayValue = inputFields[field.key] or ""
            if isActiveField then displayValue = activeInput .. "_" elseif displayValue == "" then displayValue = "Enter value..." end
            local maxlen = field.w - 4
            if unicode.len(displayValue) > maxlen then displayValue = unicode.sub(displayValue, unicode.len(displayValue) - maxlen + 1) end
            component.gpu.set(field.x + 2, field.y + 1, displayValue)
        end
        component.gpu.setBackground(COLORS.bg)
        component.gpu.setForeground(COLORS.text)
    end
    redrawInputScreen(currentInput)
    term.setCursor(currentFieldConfig.x + 2 + unicode.len(currentInput), currentFieldConfig.y + 1)
    term.showCursor(true)
    local result = nil
    while true do
        local ev, _, char, key = event.pullMultiple("key_down", "char", "interrupted")
        if ev == "interrupted" then
            term.showCursor(false)
            return nil
        elseif ev == "key_down" then
            if key == 28 then result = currentInput break
            elseif key == 14 then currentInput = unicode.sub(currentInput, 1, -2)
            elseif key == 211 then currentInput = ""
            end
        elseif ev == "char" and unicode.len(char) > 0 and not char:find("[\x00-\x1F\x7F]") then
            if unicode.len(currentInput) < currentFieldConfig.w - 4 then currentInput = currentInput .. char end
        end
        redrawInputScreen(currentInput)
        term.setCursor(currentFieldConfig.x + 2 + unicode.len(currentInput), currentFieldConfig.y + 1)
    end
    term.showCursor(false)
    if result == "" then result = defaultValue end
    if isNumeric then
        local numResult = tonumber(result)
        if not numResult then
            uoc.addLog(logs, "Invalid number for '" .. label .. "'. Using default: " .. tostring(defaultValue), "WARN")
            return tonumber(defaultValue) or 0
        end
        return numResult
    end
    return result
end

-- Item management
local function reload()
    local me = component.me_interface
    for _, item in ipairs(dataItems) do
        local qty = 0
        local ok, res = pcall(me.getItemDetail, {id = item.id, dmg = item.dmg})
        if ok and res then qty = qty + (res.basic and res.basic().qty or res.qty or 0) end
        local ok_jobs, jobs = pcall(me.getCraftingJobs)
        if ok_jobs and jobs and jobs.n then
            for _, job in ipairs(jobs) do
                if job.output and job.output.id == item.id and (item.dmg == nil or job.output.damage == item.dmg) then
                    qty = qty + (job.output.size or job.output.qty or 0)
                    if lastRequestedItem and lastRequestedItem.id == item.id and (lastRequestedItem.dmg == nil or lastRequestedItem.dmg == item.dmg) then
                        lastRequestedItem = nil
                        lastRequestTime = 0
                    end
                end
            end
        end
        item.current = qty
    end
    if lastRequestedItem and computer.uptime() - lastRequestTime > 30 then
        uoc.addLog(logs, "Timeout for '" .. (lastRequestedItem.id or "<?>") .. "'. Resetting.", "WARN")
        lastRequestedItem = nil
        lastRequestTime = 0
    end
    clampPage()
end

local function addItem()
    if not ADM[term.getPlayerName() or ""] then
        uoc.addLog(logs, "Access denied for adding item", "ERROR")
        return
    end
    changeitem = true
    inputMode = "add"
    inputFields = {name = "", category = "", count = "0", craftSize = "1"}
    local me = component.me_interface
    local stack = pcall(me.getStackInSlot, 1) and me.getStackInSlot(1) or nil
    local originalName = stack and (stack.label or stack.id) or ""
    inputFields.name = promptForInput("Name:", "name", false, originalName)
    if not inputFields.name then changeitem = false inputMode = nil inputFields = {} draw() return end
    if inputFields.name == "" then inputFields.name = originalName end
    inputFields.category = promptForInput("Category:", "category", false, "No Category")
    if not inputFields.category then changeitem = false inputMode = nil inputFields = {} draw() return end
    if inputFields.category == "" then inputFields.category = "No Category" end
    inputFields.count = promptForInput("Target:", "count", true, "0")
    if not inputFields.count then changeitem = false inputMode = nil inputFields = {} draw() return end
    inputFields.craftSize = promptForInput("Craft Size:", "craftSize", true, "1")
    if not inputFields.craftSize then changeitem = false inputMode = nil inputFields = {} draw() return end
    if stack then
        table.insert(dataItems, {
            name = inputFields.name, category = inputFields.category, id = stack.id, dmg = stack.dmg,
            count = inputFields.count, craftSize = inputFields.craftSize, current = 0
        })
        saveData()
        uoc.addLog(logs, "Added item: " .. inputFields.name .. " (Category: " .. inputFields.category .. ")", "INFO")
        currentPage = getMaxPages()
        selectedItem = nil
    else
        uoc.addLog(logs, "No item in ME interface slot 1", "ERROR")
    end
    changeitem = false
    inputMode = nil
    inputFields = {}
    draw()
end

local function editItem()
    if not ADM[term.getPlayerName() or ""] then
        uoc.addLog(logs, "Access denied for editing item", "ERROR")
        return
    end
    if not selectedItem or not dataItems[selectedItem] then
        uoc.addLog(logs, "No item selected", "ERROR")
        return
    end
    changeitem = true
    inputMode = "edit"
    local item = dataItems[selectedItem]
    inputFields = {name = item.name, category = item.category, count = tostring(item.count), craftSize = tostring(item.craftSize)}
    inputFields.name = promptForInput("Name:", "name", false, item.name)
    if not inputFields.name then changeitem = false inputMode = nil inputFields = {} draw() return end
    inputFields.category = promptForInput("Category:", "category", false, item.category)
    if not inputFields.category then changeitem = false inputMode = nil inputFields = {} draw() return end
    inputFields.count = promptForInput("Target:", "count", true, tostring(item.count))
    if not inputFields.count then changeitem = false inputMode = nil inputFields = {} draw() return end
    inputFields.craftSize = promptForInput("Craft Size:", "craftSize", true, tostring(item.craftSize))
    if not inputFields.craftSize then changeitem = false inputMode = nil inputFields = {} draw() return end
    item.name = inputFields.name
    item.category = inputFields.category
    item.count = inputFields.count
    item.craftSize = inputFields.craftSize
    saveData()
    uoc.addLog(logs, "Edited item: " .. item.name .. " (Category: " .. item.category .. ")", "INFO")
    changeitem = false
    inputMode = nil
    inputFields = {}
    draw()
end

local function removeItem()
    if not ADM[term.getPlayerName() or ""] then
        uoc.addLog(logs, "Access denied for removing item", "ERROR")
        return
    end
    if not selectedItem or not dataItems[selectedItem] then
        uoc.addLog(logs, "No item selected", "ERROR")
        return
    end
    uoc.addLog(logs, "Removed item: " .. dataItems[selectedItem].name, "WARN")
    table.remove(dataItems, selectedItem)
    selectedItem = nil
    clampPage()
    saveData()
    draw()
end

local function tryCraftItem(item)
    local count = tonumber(item.count) or 0
    local current = tonumber(item.current) or 0
    if current >= count then return false end
    if lastRequestedItem and lastRequestedItem.id == item.id and (lastRequestedItem.dmg == nil or lastRequestedItem.dmg == item.dmg) then
        craftStatus = "Waiting: " .. (item.name or "<?>")
        uoc.addLog(logs, "Item '" .. (item.name or "<?>") .. "' recently requested. Waiting.", "INFO")
        return false
    end
    local me = component.me_interface
    local ok, cpus = pcall(me.getCpus)
    if not ok then
        craftStatus = "Error: ME CPU"
        uoc.addLog(logs, "Error getting CPUs: " .. tostring(cpus), "ERROR")
        return false
    end
    cpus = cpus or {}
    local freeCpu = nil
    for _, cpu in ipairs(cpus) do
        if not cpu.busy then freeCpu = cpu.name break end
    end
    if freeCpu then
        local ok, craftables = pcall(me.getCraftables, {name = item.id, damage = item.dmg})
        if not ok then
            craftStatus = "Error: ME Recipes"
            uoc.addLog(logs, "Error getting recipes: " .. tostring(craftables), "ERROR")
            return false
        end
        craftables = craftables or {n = 0}
        if craftables.n and craftables.n >= 1 then
            local quantity = math.min(tonumber(item.craftSize) or 1, count - current)
            if quantity <= 0 then return false end
            local ok, req = pcall(function() return craftables[1].request(quantity, false, freeCpu) end)
            if ok and req then
                craftStatus = "Crafting: " .. (item.name or "<?>")
                uoc.addLog(logs, "Requested " .. quantity .. "x " .. (item.name or "<?>") .. " on CPU " .. tostring(freeCpu), "INFO")
                lastRequestedItem = {id = item.id, dmg = item.dmg, expectedOutput = quantity}
                lastRequestTime = computer.uptime()
                return true
            else
                craftStatus = "Error: Craft rejected"
                uoc.addLog(logs, "Failed to craft " .. (item.name or "<?>") .. ": " .. tostring(req), "ERROR")
                return false
            end
        else
            craftStatus = "Error: No recipe for " .. (item.name or "<?>")
            uoc.addLog(logs, "No recipe for " .. (item.name or "<?>"), "ERROR")
            return false
        end
    else
        craftStatus = "Error: No free CPU"
        uoc.addLog(logs, "No free CPUs available", "ERROR")
        return false
    end
end

-- Event handlers
local function updateButtonHover(x, y)
    local btnWidth, btnHeight, btnPadding = 12, 3, 2
    local btnX = WIDTH - btnWidth - 5
    local btns = {
        {name = "Delete", action = "delete"},
        {name = "Edit", action = "edit"},
        {name = isCrafting and "Stop" or "AutoCraft", action = "toggleCraft"},
        {name = "Add", action = "add"}
    }
    for i, btn in ipairs(btns) do
        local btnY = 10 + (i - 1) * (btnHeight + btnPadding)
        if x >= btnX and x <= btnX + btnWidth - 1 and y >= btnY and y <= btnY + btnHeight - 1 then return btn.action end
    end
    local arrowBtnW, arrowBtnH = 4, 3
    local arrowBtnY = 10 + (#btns * (btnHeight + btnPadding))
    local prevArrowBtnX, nextArrowBtnX = btnX, btnX + arrowBtnW + 1
    local sortBtnY, sortBtnW = arrowBtnY + arrowBtnH + 2, 12
    if x >= prevArrowBtnX and x <= prevArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then return "prevPage"
    elseif x >= nextArrowBtnX and x <= nextArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then return "nextPage"
    elseif x >= btnX and x <= btnX + sortBtnW - 1 and y >= sortBtnY and y <= sortBtnY + arrowBtnH - 1 then return "sort"
    end
    return nil
end

local function handleTouch(_, _, x, y, _, nick)
    if not ADM[nick or ""] or changeitem then return end
    local btnWidth, btnHeight, btnPadding = 12, 3, 2
    local btnX = WIDTH - btnWidth - 5
    local btns = {
        {name = "Delete", action = "delete"},
        {name = "Edit", action = "edit"},
        {name = isCrafting and "Stop" or "AutoCraft", action = "toggleCraft"},
        {name = "Add", action = "add"}
    }
    for i, btn in ipairs(btns) do
        local btnY = 10 + (i - 1) * (btnHeight + btnPadding)
        if x >= btnX and x <= btnX + btnWidth - 1 and y >= btnY and y <= btnY + btnHeight - 1 then
            if btn.action == "delete" then removeItem()
            elseif btn.action == "edit" then editItem()
            elseif btn.action == "toggleCraft" then
                isCrafting = not isCrafting
                craftStatus = isCrafting and "AutoCrafting..." or "Stopped"
                uoc.addLog(logs, isCrafting and "AutoCraft started" or "AutoCraft stopped", isCrafting and "INFO" or "WARN")
            elseif btn.action == "add" then addItem()
            end
            buttonHover = nil
            draw()
            return
        end
    end
    local arrowBtnW, arrowBtnH = 4, 3
    local arrowBtnY = 10 + (#btns * (btnHeight + btnPadding))
    local prevArrowBtnX, nextArrowBtnX = btnX, btnX + arrowBtnW + 1
    local sortBtnY, sortBtnW = arrowBtnY + arrowBtnH + 2, 12
    if x >= prevArrowBtnX and x <= prevArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 and currentPage > 1 then
        currentPage = currentPage - 1
        selectedItem = nil
        buttonHover = nil
        draw()
        return
    elseif x >= nextArrowBtnX and x <= nextArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 and currentPage < getMaxPages() then
        currentPage = currentPage + 1
        selectedItem = nil
        buttonHover = nil
        draw()
        return
    elseif x >= btnX and x <= btnX + sortBtnW - 1 and y >= sortBtnY and y <= sortBtnY + arrowBtnH - 1 then
        local criteria = {"name", "category", "current", "count", "craftSize"}
        local idx = 1
        for i, v in ipairs(criteria) do
            if v == settings.sortCriteria then idx = i break end
        end
        idx = idx + 1
        if idx > #criteria then idx = 1 settings.sortAscending = not settings.sortAscending else settings.sortAscending = true end
        settings.sortCriteria = criteria[idx]
        currentPage = 1
        selectedItem = nil
        buttonHover = nil
        saveData()
        draw()
        return
    end
    if y >= HEIGHT - 10 and y <= HEIGHT - 8 then
        if x >= 2 + (WIDTH - 20) - 3 and x <= 2 + (WIDTH - 20) - 1 and search ~= "" then
            search = ""
            currentPage = 1
            selectedItem = nil
            buttonHover = nil
            draw()
            return
        elseif x >= 2 + 1 and x <= 2 + (WIDTH - 20) - 4 then
            searchActive = true
            buttonHover = nil
            draw()
            return
        end
    else
        searchActive = false
    end
    local filteredItems = getFilteredAndSortedItems()
    local perPage = getItemsPerPage()
    local startIndex = (currentPage - 1) * perPage + 1
    local itemsStartY, itemsEndY = 10, 10 + perPage - 1
    if y >= itemsStartY and y <= itemsEndY then
        local idxOnPage = y - itemsStartY
        local actualIndex = startIndex + idxOnPage
        if filteredItems[actualIndex] then
            for k, v in ipairs(dataItems) do
                if v == filteredItems[actualIndex] then
                    selectedItem = k
                    posSelect = actualIndex
                    break
                end
            end
        end
        buttonHover = nil
        draw()
    end
end

local function handleMouseMove(_, _, x, y)
    if changeitem then return end
    local newHover = updateButtonHover(x, y)
    if newHover ~= buttonHover then
        buttonHover = newHover
        draw()
    end
end

local function handleKeyDown(_, _, char, key, nick)
    if not ADM[nick or ""] or changeitem then return end
    local filteredItems = getFilteredAndSortedItems()
    local perPage = getItemsPerPage()
    if searchActive then
        if key == 14 then search = unicode.sub(search, 1, -2)
        elseif key == 211 then search = ""
        elseif key == 28 then searchActive = false
        elseif char > 0 and unicode.char(char):find("[^\x00-\x1F\x7F]") then
            if unicode.len(search) < WIDTH - 25 then search = search .. unicode.char(char) end
        end
        currentPage = 1
        selectedItem = nil
        buttonHover = nil
        draw()
    else
        if key == 200 then -- Up
            local startIndex = (currentPage - 1) * perPage + 1
            local visibleItems = {}
            for i = startIndex, math.min(#filteredItems, startIndex + perPage - 1) do
                table.insert(visibleItems, filteredItems[i])
            end
            if selectedItem then
                for i, v in ipairs(visibleItems) do
                    if v == dataItems[selectedItem] then
                        if i > 1 then
                            selectedItem = nil
                            for k, v2 in ipairs(dataItems) do
                                if v2 == visibleItems[i - 1] then selectedItem = k posSelect = startIndex + i - 2 break end
                            end
                        end
                        break
                    end
                end
            elseif #visibleItems > 0 then
                for k, v in ipairs(dataItems) do
                    if v == visibleItems[#visibleItems] then selectedItem = k posSelect = startIndex + #visibleItems - 1 break end
                end
            end
        elseif key == 208 then -- Down
            local startIndex = (currentPage - 1) * perPage + 1
            local visibleItems = {}
            for i = startIndex, math.min(#filteredItems, startIndex + perPage - 1) do
                table.insert(visibleItems, filteredItems[i])
            end
            if selectedItem then
                for i, v in ipairs(visibleItems) do
                    if v == dataItems[selectedItem] then
                        if i < #visibleItems then
                            selectedItem = nil
                            for k, v2 in ipairs(dataItems) do
                                if v2 == visibleItems[i + 1] then selectedItem = k posSelect = startIndex + i break end
                            end
                        end
                        break
                    end
                end
            elseif #visibleItems > 0 then
                for k, v in ipairs(dataItems) do
                    if v == visibleItems[1] then selectedItem = k posSelect = startIndex break end
                end
            end
        elseif key == 203 and currentPage > 1 then currentPage = currentPage - 1 selectedItem = nil posSelect = nil
        elseif key == 205 and currentPage < getMaxPages() then currentPage = currentPage + 1 selectedItem = nil posSelect = nil
        elseif key == 200 and term.isShiftDown() then logOffset = math.min(logOffset + 1, #logs - 5)
        elseif key == 208 and term.isShiftDown() then logOffset = math.max(logOffset - 1, 0)
        end
        buttonHover = nil
        draw()
    end
end

local function handleScroll(_, _, _, _, dir, nick)
    if not ADM[nick or ""] or changeitem then return end
    local filteredItems = getFilteredAndSortedItems()
    scroll = math.max(1, math.min(scroll + dir, math.max(1, #filteredItems - getItemsPerPage() + 1)))
    maxscroll = scroll + getItemsPerPage() - 1
    if posSelect then
        posSelect = math.max(scroll, math.min(posSelect + dir, maxscroll))
        for k, v in ipairs(dataItems) do
            if v == filteredItems[posSelect] then selectedItem = k break end
        end
    end
    draw()
end

-- Main loop
local function main()
    checkComponents()
    bindGpu()
    if not fs.exists(DATA_FILE) then uoc.savef(DATA_FILE, {items = {}, settings = {sortCriteria = "name", sortAscending = true}}) end
    loadData()
    uoc.addLog(logs, "Program started", "INFO")
    draw()
    local etouch = event.listen("touch", handleTouch)
    local emove = event.listen("mouse_move", handleMouseMove)
    local ekey = event.listen("key_down", handleKeyDown)
    local escroll = event.listen("scroll", handleScroll)
    while true do
        if isCrafting then
            local ok, err = pcall(reload)
            if not ok then
                craftStatus = "Error: Data refresh"
                uoc.addLog(logs, "Error in reload: " .. tostring(err), "ERROR")
            else
                local crafted = false
                for _, item in ipairs(dataItems) do
                    if not crafted and tryCraftItem(item) then crafted = true break end
                end
                saveData()
                if not changeitem then draw() end
            end
        end
        os.sleep(0.5)
    end
end

local ok, err = pcall(main)
if not ok then
    uoc.addLog(logs, "Fatal error: " .. tostring(err), "ERROR")
    draw()
    event.cancel(etouch)
    event.cancel(emove)
    event.cancel(ekey)
    event.cancel(escroll)
    computer.shutdown(true)
end
