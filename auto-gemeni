local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode")
local term = require("term")
local computer = require("computer")

-- Paths and library
local DATA_FILE = "/home/BD.txt"
local LIB_PATH = "/lib/ultimateOC.lua"
local LIB_URL = "https://raw.githubusercontent.com/shify4713/lua/refs/heads/main/lib-gemeni"

-- Check component availability
local function checkComponents()
    local gpuAvailable = component.isAvailable("gpu")
    local meAvailable = component.isAvailable("me_interface")
    if not gpuAvailable then
        print("Error: GPU component is unavailable")
        return false
    end
    if not meAvailable then
        print("Error: ME Interface component is unavailable")
        return false
    end
    return true
end

-- Load or download the library
local uoc = {}
local function loadLibrary()
    if not fs.exists(LIB_PATH) then
        print("ultimateOC.lua not found. Downloading...")
        local success, err = shell.execute("wget -f " .. LIB_URL .. " " .. LIB_PATH)
        if not success then
            print("Failed to download ultimateOC.lua: " .. tostring(err))
            return false
        end
    end

    local ok, result = pcall(require, "ultimateOC")
    if not ok then
        print("Failed to load ultimateOC.lua: " .. tostring(result))
        return false
    end
    uoc = result or {}
    return true
end

-- Fallback library functions (excluding animatedButton since it's now fixed in the library)
if not uoc.drawText then
    function uoc.drawText(x, y, text, color, bold)
        local gpu = component.gpu
        gpu.setForeground(color or 0xFFFFFF)
        gpu.set(x, y, text)
    end
end
if not uoc.progressBar then
    function uoc.progressBar(x, y, w, p)
        local gpu = component.gpu
        gpu.fill(x, y, math.floor(w * p), 1, "█")
    end
end
if not uoc.roundRect then
    function uoc.roundRect(x, y, w, h, borderColor, bgColor)
        local gpu = component.gpu
        gpu.setBackground(bgColor or 0x000000)
        gpu.fill(x, y, w, h, " ")
        gpu.setForeground(borderColor or 0xFFFFFF)
        gpu.set(x, y, "╔" .. string.rep("═", w-2) .. "╗")
        gpu.set(x, y+h-1, "╚" .. string.rep("═", w-2) .. "╝")
        for i = 1, h-2 do
            gpu.set(x, y+i, "║")
            gpu.set(x+w-1, y+i, "║")
        end
    end
end
if not uoc.drawLogs then
    function uoc.drawLogs(x, y, logs, lines, color, offset)
        local gpu = component.gpu
        gpu.setForeground(color or 0xFFFFFF)
        for i = 1, lines do
            local idx = #logs - offset - lines + i
            if idx > 0 and idx <= #logs then
                gpu.set(x, y + i - 1, logs[idx])
            end
        end
    end
end
if not uoc.addLog then
    logs = {}
    function uoc.addLog(logsTable, msg)
        table.insert(logsTable, msg)
        if #logsTable > 100 then table.remove(logsTable, 1) end
    end
end
if not uoc.loadf then
    function uoc.loadf(path)
        local file = io.open(path, "r")
        if not file then return nil end
        local content = file:read("*a")
        file:close()
        return load("return " .. content)()
    end
end
if not uoc.savef then
    function uoc.savef(path, data)
        local file = io.open(path, "w")
        if file then
            file:write(textutils.serialize(data))
            file:close()
        end
    end
end

-- Initialize data file
if not fs.exists(DATA_FILE) then
    uoc.savef(DATA_FILE, {items = {}, settings = {sortCriteria = "name", sortAscending = true}})
end

-- Configuration
local COLORS = {
    button = 0x00BFFF,
    buttonActive = 0x1E90FF,
    border = 0x44475a,
    text = 0xF8F8F2,
    shadow = 0x282A36,
    bg = 0x23242b,
    error = 0xFF5555,
    ok = 0x50FA7B,
    log = 0x8BE9FD,
    progress_bg = 0x44475a,
    progress_fg = 0x50FA7B,
    select = 0x31313A,
    select_active = 0x44B3FF,
    search_bg = 0x282B36,
    search_border = 0x00BFFF,
    search_cross = 0xFF5555,
    search_hint = 0x888888,
    bar_shadow = 0x181920,
    warning = 0xFFB86C,
}
local WIDTH, HEIGHT = 110, 40
local craftStatus = "Waiting..."
local nextCraftUpdate = 0
local isCrafting = false
local logs = {}
local dataItems = {}
local settings = {sortCriteria = "name", sortAscending = true}
local search = ""
local selectedItem = nil
local currentPage = 1
local changeItem = false
local searchActive = false
local logOffset = 0
local lastRequestedItem = nil
local lastRequestTime = 0
local lastDrawnState = {}

-- Components
local gpu = component.gpu
local me = component.me_interface

-- Helper Functions
local function getFilteredAndSortedItems()
    local filtered = {}
    for _, item in ipairs(dataItems) do
        if search == "" or unicode.lower(item.name or ""):find(unicode.lower(search), 1, true) then
            if not item.category then item.category = "No Category" end
            table.insert(filtered, item)
        end
    end
    table.sort(filtered, function(a, b)
        local valA, valB
        if settings.sortCriteria == "name" then
            valA = unicode.lower(a.name or "")
            valB = unicode.lower(b.name or "")
        elseif settings.sortCriteria == "current" then
            valA = tonumber(a.current) or 0
            valB = tonumber(b.current) or 0
        elseif settings.sortCriteria == "count" then
            valA = tonumber(a.count) or 0
            valB = tonumber(b.count) or 0
        elseif settings.sortCriteria == "craftSize" then
            valA = tonumber(a.craftSize) or 0
            valB = tonumber(b.craftSize) or 0
        elseif settings.sortCriteria == "category" then
            valA = unicode.lower(a.category or "No Category")
            valB = unicode.lower(b.category or "No Category")
        end
        return settings.sortAscending and valA < valB or valA > valB
    end)
    return filtered
end

local function getItemsPerPage()
    return HEIGHT - 24
end

local function getMaxPages()
    local filteredItems = getFilteredAndSortedItems()
    local perPage = getItemsPerPage()
    return math.max(1, math.ceil(#filteredItems / perPage))
end

local function clampPage()
    currentPage = math.max(1, math.min(currentPage, getMaxPages()))
end

-- Rendering Functions
local function clear()
    gpu.setBackground(COLORS.bg)
    gpu.fill(1, 1, WIDTH, HEIGHT, " ")
    gpu.setForeground(COLORS.text)
end

local function shadowRect(x, y, w, h)
    gpu.setBackground(COLORS.bar_shadow)
    gpu.fill(x + 1, y + h, w, 1, " ")
    gpu.fill(x + w, y, 1, h, " ")
    gpu.setBackground(COLORS.bg)
end

local function drawHeader()
    if lastDrawnState.header == craftStatus then return end
    uoc.drawText(3, 3, "Ultimate AutoCraft", COLORS.ok, true)
    gpu.setBackground(COLORS.progress_fg)
    gpu.fill(2, 4, WIDTH - 2, 1, " ")
    shadowRect(2, 4, WIDTH - 2, 1)
    gpu.setBackground(COLORS.bg)
    uoc.drawText(WIDTH - 34, 3, "Status: " .. craftStatus,
        craftStatus:find("Error") and COLORS.error or COLORS.ok)
    uoc.progressBar(3, 5, WIDTH - 6, isCrafting and 0.9 or 0)
    uoc.drawText(3, 6, "Page: " .. currentPage .. "/" .. getMaxPages(), COLORS.text)
    lastDrawnState.header = craftStatus
end

local function drawLogs()
    if lastDrawnState.logs == logOffset then return end
    uoc.drawLogs(3, HEIGHT - 9, logs, 4, COLORS.log, logOffset)
    lastDrawnState.logs = logOffset
end

local function drawItems()
    local filteredItems = getFilteredAndSortedItems()
    local stateKey = currentPage .. "|" .. (selectedItem or 0) .. "|" .. search
    if lastDrawnState.items == stateKey then return end

    local x, y = 2, 8
    local totalWidth = WIDTH - 4
    local colWidths = {
        name = math.floor(totalWidth * 0.35),
        category = math.floor(totalWidth * 0.15),
        current = math.floor(totalWidth * 0.15),
        count = math.floor(totalWidth * 0.15),
        craftSize = totalWidth - math.floor(totalWidth * 0.8)
    }

    -- Draw table header
    gpu.setForeground(COLORS.select_active)
    gpu.set(x, y, "┌" .. string.rep("─", colWidths.name) .. "┬" .. string.rep("─", colWidths.category) ..
        "┬" .. string.rep("─", colWidths.current) .. "┬" .. string.rep("─", colWidths.count) ..
        "┬" .. string.rep("─", colWidths.craftSize) .. "┐")
    gpu.set(x, y + 1, "│")
    gpu.setForeground(COLORS.ok)
    gpu.set(x + 1, y + 1, string.format("%-" .. colWidths.name .. "s", "Name"))
    gpu.setForeground(COLORS.select_active)
    gpu.set(x + colWidths.name + 1, y + 1, "│")
    gpu.setForeground(COLORS.ok)
    gpu.set(x + colWidths.name + 2, y + 1, string.format("%-" .. colWidths.category .. "s", "Category"))
    gpu.setForeground(COLORS.select_active)
    gpu.set(x + colWidths.name + colWidths.category + 2, y + 1, "│")
    gpu.setForeground(COLORS.ok)
    gpu.set(x + colWidths.name + colWidths.category + 3, y + 1, string.format("%-" .. colWidths.current .. "s", "Current"))
    gpu.setForeground(COLORS.select_active)
    gpu.set(x + colWidths.name + colWidths.category + colWidths.current + 3, y + 1, "│")
    gpu.setForeground(COLORS.ok)
    gpu.set(x + colWidths.name + colWidths.category + colWidths.current + 4, y + 1, string.format("%-" .. colWidths.count .. "s", "Keep"))
    gpu.setForeground(COLORS.select_active)
    gpu.set(x + colWidths.name + colWidths.category + colWidths.current + colWidths.count + 4, y + 1, "│")
    gpu.setForeground(COLORS.ok)
    gpu.set(x + colWidths.name + colWidths.category + colWidths.current + colWidths.count + 5, y + 1, string.format("%-" .. colWidths.craftSize .. "s", "Batch"))
    gpu.setForeground(COLORS.select_active)
    gpu.set(x + colWidths.name + colWidths.category + colWidths.current + colWidths.count + colWidths.craftSize + 5, y + 1, "│")
    gpu.set(x, y + 2, "├" .. string.rep("─", colWidths.name) .. "┼" .. string.rep("─", colWidths.category) ..
        "┼" .. string.rep("─", colWidths.current) .. "┼" .. string.rep("─", colWidths.count) ..
        "┼" .. string.rep("─", colWidths.craftSize) .. "┤")

    -- Draw items
    local perPage = getItemsPerPage()
    local startIndex = (currentPage - 1) * perPage + 1
    for i = startIndex, math.min(#filteredItems, startIndex + perPage - 1) do
        local item = filteredItems[i]
        local isSelected = selectedItem and dataItems[selectedItem] == item
        local row = y + 2 + (i - startIndex) + 1
        gpu.setBackground(isSelected and COLORS.select_active or COLORS.bg)
        gpu.fill(x, row, totalWidth + 2, 1, " ")
        gpu.setForeground(tonumber(item.current or 0) < tonumber(item.count or 0) and COLORS.warning or COLORS.text)
        gpu.set(x, row, "│")

        local nameStr = tostring(item.name or "<?>")
        if unicode.len(nameStr) > colWidths.name then
            nameStr = unicode.sub(nameStr, 1, colWidths.name - 1) .. "…"
        end
        gpu.set(x + 1, row, string.format("%-" .. colWidths.name .. "s", nameStr))

        gpu.setForeground(COLORS.select_active)
        gpu.set(x + colWidths.name + 1, row, "│")
        gpu.setForeground(tonumber(item.current or 0) < tonumber(item.count or 0) and COLORS.warning or COLORS.text)
        local categoryStr = tostring(item.category or "No Category")
        if unicode.len(categoryStr) > colWidths.category then
            categoryStr = unicode.sub(categoryStr, 1, colWidths.category - 1) .. "…"
        end
        gpu.set(x + colWidths.name + 2, row, string.format("%-" .. colWidths.category .. "s", categoryStr))

        gpu.setForeground(COLORS.select_active)
        gpu.set(x + colWidths.name + colWidths.category + 2, row, "│")
        gpu.setForeground(tonumber(item.current or 0) < tonumber(item.count or 0) and COLORS.warning or COLORS.text)
        local currentStr = tostring(item.current or 0)
        if unicode.len(currentStr) > colWidths.current then
            currentStr = unicode.sub(currentStr, 1, colWidths.current - 1) .. "…"
        end
        gpu.set(x + colWidths.name + colWidths.category + 3, row, string.format("%-" .. colWidths.current .. "s", currentStr))

        gpu.setForeground(COLORS.select_active)
        gpu.set(x + colWidths.name + colWidths.category + colWidths.current + 3, row, "│")
        gpu.setForeground(tonumber(item.current or 0) < tonumber(item.count or 0) and COLORS.warning or COLORS.text)
        local countStr = tostring(item.count or 0)
        if unicode.len(countStr) > colWidths.count then
            countStr = unicode.sub(countStr, 1, colWidths.count - 1) .. "…"
        end
        gpu.set(x + colWidths.name + colWidths.category + colWidths.current + 4, row, string.format("%-" .. colWidths.count .. "s", countStr))

        gpu.setForeground(COLORS.select_active)
        gpu.set(x + colWidths.name + colWidths.category + colWidths.current + colWidths.count + 4, row, "│")
        gpu.setForeground(tonumber(item.current or 0) < tonumber(item.count or 0) and COLORS.warning or COLORS.text)
        local craftSizeStr = tostring(item.craftSize or 0)
        if unicode.len(craftSizeStr) > colWidths.craftSize then
            craftSizeStr = unicode.sub(craftSizeStr, 1, colWidths.craftSize - 1) .. "…"
        end
        gpu.set(x + colWidths.name + colWidths.category + colWidths.current + colWidths.count + 5, row, string.format("%-" .. colWidths.craftSize .. "s", craftSizeStr))

        gpu.setForeground(COLORS.select_active)
        gpu.set(x + colWidths.name + colWidths.category + colWidths.current + colWidths.count + colWidths.craftSize + 5, row, "│")
    end

    -- Clear remaining rows
    for i = math.min(#filteredItems, startIndex + perPage - 1) + 1, startIndex + perPage - 1 do
        local row = y + 2 + (i - startIndex) + 1
        gpu.setBackground(COLORS.bg)
        gpu.fill(x, row, totalWidth + 2, 1, " ")
    end

    -- Draw table footer
    gpu.setForeground(COLORS.select_active)
    local lastRow = y + perPage + 3
    gpu.set(x, lastRow, "└" .. string.rep("─", colWidths.name) .. "┴" .. string.rep("─", colWidths.category) ..
        "┴" .. string.rep("─", colWidths.current) .. "┴" .. string.rep("─", colWidths.count) ..
        "┴" .. string.rep("─", colWidths.craftSize) .. "┘")
    gpu.setForeground(COLORS.text)
    lastDrawnState.items = stateKey
end

local function drawSearchBar()
    local stateKey = search .. tostring(searchActive)
    if lastDrawnState.search == stateKey then return end
    local x, y, w, h = 3, HEIGHT - 17, WIDTH - 6, 3
    uoc.roundRect(x, y, w, h, COLORS.search_border, COLORS.search_bg)
    gpu.setBackground(COLORS.search_bg)
    gpu.fill(x + 1, y + 1, w - 2, h - 2, " ")
    gpu.setForeground(COLORS.search_cross)
    gpu.set(x + w - 3, y + 1, search ~= "" and "×" or " ")
    gpu.setForeground(searchActive and COLORS.ok or COLORS.search_hint)
    local display = search == "" and "Search: type part of name..." or search
    if searchActive then display = display .. "_" end
    if unicode.len(display) > w - 7 then
        display = unicode.sub(display, unicode.len(display) - (w - 8), -1)
    end
    gpu.set(x + 2, y + 1, display)
    gpu.setBackground(COLORS.bg)
    gpu.setForeground(COLORS.text)
    lastDrawnState.search = stateKey
end

local function drawButtons()
    local btnState = tostring(isCrafting) .. "|" .. settings.sortCriteria .. "|" .. tostring(settings.sortAscending)
    if lastDrawnState.buttons == btnState then return end
    local btns = {
        {name = "Craft All", x = WIDTH - 75, action = "craftAll", hover = false},
        {name = "Delete", x = WIDTH - 60, action = "delete", hover = false},
        {name = "Edit", x = WIDTH - 45, action = "edit", hover = false},
        {name = isCrafting and "Stop" or "AutoCraft", x = WIDTH - 30, action = "toggleCraft", hover = false},
        {name = "Add", x = WIDTH - 15, action = "add", hover = false},
    }
    for _, btn in ipairs(btns) do
        uoc.animatedButton(btn.x, HEIGHT - 4, 12, 3, btn.name, btn.hover, COLORS.button, COLORS.buttonActive, COLORS.text)
    end
    local arrowBtnW, arrowBtnH, arrowBtnY = 4, 3, HEIGHT - 4
    local prevArrowBtnX = 2
    local nextArrowBtnX = prevArrowBtnX + arrowBtnW + 1
    local sortBtnX = nextArrowBtnX + arrowBtnW + 1
    local sortBtnW = 14
    local maxPages = getMaxPages()
    uoc.animatedButton(prevArrowBtnX, arrowBtnY, arrowBtnW, arrowBtnH, "<-", false,
        currentPage > 1 and COLORS.button or COLORS.border,
        currentPage > 1 and COLORS.buttonActive or COLORS.border,
        currentPage > 1 and COLORS.text or COLORS.search_hint)
    uoc.animatedButton(nextArrowBtnX, arrowBtnY, arrowBtnW, arrowBtnH, "->", false,
        currentPage < maxPages and COLORS.button or COLORS.border,
        currentPage < maxPages and COLORS.buttonActive or COLORS.border,
        currentPage < maxPages and COLORS.text or COLORS.search_hint)
    local sortText = "Sort: " .. (settings.sortCriteria == "name" and "Name" or
                                  settings.sortCriteria == "current" and "Current" or
                                  settings.sortCriteria == "count" and "Keep" or
                                  settings.sortCriteria == "craftSize" and "Batch" or
                                  "Category") .. (settings.sortAscending and " ^" or " v")
    uoc.animatedButton(sortBtnX, arrowBtnY, sortBtnW, arrowBtnH, "Sort", false, COLORS.button, COLORS.buttonActive, COLORS.text, sortText, COLORS.text)
    lastDrawnState.buttons = btnState
end

local function draw()
    local ok, err = pcall(function()
        clear()
        drawHeader()
        drawItems()
        drawSearchBar()
        drawLogs()
        drawButtons()
    end)
    if not ok then
        uoc.addLog(logs, "ERROR: Failed to draw UI: " .. tostring(err))
        clear()
        uoc.drawText(1, 1, "Error rendering UI: " .. tostring(err), COLORS.error)
    end
end

-- Data Management
local function reload()
    local ok, data = pcall(uoc.loadf, DATA_FILE)
    if not ok then
        uoc.addLog(logs, "ERROR: Failed to load BD.txt: " .. tostring(data))
        dataItems = {}
        settings = {sortCriteria = "name", sortAscending = true}
    else
        data = data or {items = {}, settings = {sortCriteria = "name", sortAscending = true}}
        dataItems = data.items or {}
        settings = data.settings or {sortCriteria = "name", sortAscending = true}
    end
    clampPage()

    for _, item in ipairs(dataItems) do
        local qty = 0
        local ok, items = pcall(me.getItemsInNetwork, {id = item.id, damage = item.dmg})
        if ok and items and items.n and items.n > 0 then
            for _, stack in ipairs(items) do
                if stack.name == item.id and (item.dmg == nil or stack.damage == item.dmg) then
                    qty = qty + (stack.size or stack.qty or 0)
                end
            end
        else
            local ok2, detail = pcall(me.getItemDetail, {id = item.id, damage = item.dmg})
            if ok2 and detail then
                qty = qty + (detail.qty or detail.size or 0)
            end
        end

        local ok, jobs = pcall(me.getCraftingJobs)
        if ok and jobs and jobs.n then
            for _, job in ipairs(jobs) do
                if job.output and job.output.id == item.id and (item.dmg == nil or job.output.damage == item.dmg) then
                    qty = qty + (job.output.size or job.output.qty or 0)
                    if lastRequestedItem and lastRequestedItem.id == item.id and
                       (lastRequestedItem.dmg == nil or lastRequestedItem.dmg == item.dmg) then
                        uoc.addLog(logs, "DEBUG: Item '" .. (item.name or "<?>") .. "' in active crafts. Resetting lastRequestedItem.")
                        lastRequestedItem = nil
                        lastRequestTime = 0
                    end
                end
            end
        end
        item.current = qty
    end

    if lastRequestedItem and computer.uptime() - lastRequestTime > 30 then
        uoc.addLog(logs, "WARN: Timeout for '" .. (lastRequestedItem.id or "<?>") .. "'. Resetting lastRequestedItem.")
        lastRequestedItem = nil
        lastRequestTime = 0
    end
end

local function save()
    local ok, err = pcall(uoc.savef, DATA_FILE, {items = dataItems, settings = settings})
    if not ok then
        uoc.addLog(logs, "ERROR: Failed to save: " .. tostring(err))
    end
end

local function resetSelection()
    search = ""
    currentPage = 1
    selectedItem = nil
end

local function addItem()
    changeItem = true
    clear()
    uoc.drawText(10, HEIGHT - 8, "Place item in ME Interface slot 1 and enter details.", COLORS.ok)
    uoc.drawText(10, HEIGHT - 7, "Name: ", COLORS.text)
    term.setCursor(20, HEIGHT - 7)
    local name = tostring(term.read({doBreak = true, clear = true}) or ""):gsub("\n", "")
    uoc.drawText(10, HEIGHT - 6, "Category: ", COLORS.text)
    term.setCursor(20, HEIGHT - 6)
    local category = tostring(term.read({doBreak = true, clear = true}) or ""):gsub("\n", "")
    uoc.drawText(10, HEIGHT - 5, "Keep (number): ", COLORS.text)
    term.setCursor(29, HEIGHT - 5)
    local count = tonumber(term.read({doBreak = true, clear = true}) or "0") or 0
    uoc.drawText(10, HEIGHT - 4, "Craft Batch (number): ", COLORS.text)
    term.setCursor(32, HEIGHT - 4)
    local craftSize = tonumber(term.read({doBreak = true, clear = true}) or "1") or 1

    local ok, stack = pcall(me.getStackInSlot, 1)
    if ok and stack then
        table.insert(dataItems, {
            name = name ~= "" and name or stack.label or stack.id,
            category = category ~= "" and category or "No Category",
            id = stack.id,
            dmg = stack.dmg,
            count = math.max(0, count),
            craftSize = math.max(1, craftSize)
        })
        save()
        uoc.addLog(logs, "INFO: Added item: " .. (name ~= "" and name or stack.label or stack.id) ..
            " (Category: " .. (category ~= "" and category or "No Category") .. ")")
        currentPage = getMaxPages()
        selectedItem = nil
    else
        uoc.addLog(logs, "ERROR: No item in slot 1!")
    end
    changeItem = false
    draw()
end

local function editItem()
    if not selectedItem then
        uoc.addLog(logs, "ERROR: No item selected!")
        return
    end
    local item = dataItems[selectedItem]
    changeItem = true
    clear()
    uoc.drawText(10, HEIGHT - 8, "Editing: " .. (item.name or "<?>"), COLORS.ok)
    uoc.drawText(10, HEIGHT - 7, "New Name (Enter to skip): ", COLORS.text)
    term.setCursor(40, HEIGHT - 7)
    local name = tostring(term.read({doBreak = true, clear = true}) or ""):gsub("\n", "")
    uoc.drawText(10, HEIGHT - 6, "New Category (Enter to skip): ", COLORS.text)
    term.setCursor(40, HEIGHT - 6)
    local category = tostring(term.read({doBreak = true, clear = true}) or ""):gsub("\n", "")
    uoc.drawText(10, HEIGHT - 5, "New Keep (number, Enter to skip): ", COLORS.text)
    term.setCursor(54, HEIGHT - 5)
    local countStr = tostring(term.read({doBreak = true, clear = true}) or ""):gsub("\n", "")
    uoc.drawText(10, HEIGHT - 4, "New Craft Batch (number, Enter to skip): ", COLORS.text)
    term.setCursor(55, HEIGHT - 4)
    local craftSizeStr = tostring(term.read({doBreak = true, clear = true}) or ""):gsub("\n", "")

    if name ~= "" then item.name = name end
    if category ~= "" then item.category = category end
    if countStr ~= "" then item.count = math.max(0, tonumber(countStr) or item.count) end
    if craftSizeStr ~= "" then item.craftSize = math.max(1, tonumber(craftSizeStr) or item.craftSize) end
    save()
    uoc.addLog(logs, "INFO: Edited: " .. item.name .. " (Category: " .. (item.category or "No Category") .. ")")
    changeItem = false
    draw()
end

local function removeItem()
    if not selectedItem then
        uoc.addLog(logs, "ERROR: No item selected!")
        return
    end
    uoc.addLog(logs, "WARN: Removed: " .. (dataItems[selectedItem].name or "<?>"))
    table.remove(dataItems, selectedItem)
    selectedItem = nil
    clampPage()
    save()
    draw()
end

local function tryCraftItem(item)
    local count = tonumber(item.count) or 0
    local current = tonumber(item.current) or 0
    if current >= count then
        uoc.addLog(logs, "DEBUG: Item '" .. (item.name or "<?>") .. "' has sufficient quantity (" .. current .. " >= " .. count .. ").")
        return false
    end
    uoc.addLog(logs, "DEBUG: Attempting to craft: " .. (item.name or "<?>") .. " (Current: " .. current .. ", Needed: " .. count .. ")")
    if lastRequestedItem and lastRequestedItem.id == item.id and
       (item.dmg == nil or lastRequestedItem.dmg == item.dmg) then
        uoc.addLog(logs, "INFO: Item '" .. (item.name or "<?>") .. "' recently requested. Waiting.")
        craftStatus = "Waiting: " .. (item.name or "<?>")
        return false
    end

    local ok, cpus = pcall(me.getCpus)
    if not ok then
        uoc.addLog(logs, "ERROR: Failed to get CPUs: " .. tostring(cpus))
        craftStatus = "Error: ME CPU"
        return false
    end
    cpus = cpus or {}
    local freeCpu = nil
    for _, cpu in ipairs(cpus) do
        if not cpu.busy then
            freeCpu = cpu.name
            break
        end
    end
    if not freeCpu then
        uoc.addLog(logs, "ERROR: No free CPUs available")
        craftStatus = "Error: No free CPUs"
        return false
    end

    uoc.addLog(logs, "DEBUG: Found free CPU: " .. tostring(freeCpu))
    local ok, craftables = pcall(me.getCraftables, {name = item.id, damage = item.dmg})
    if not ok then
        uoc.addLog(logs, "ERROR: Failed to get craftables: " .. tostring(craftables))
        craftStatus = "Error: ME Recipes"
        return false
    end
    craftables = craftables or {n = 0}
    if craftables.n < 1 then
        uoc.addLog(logs, "ERROR: No recipe for " .. (item.name or "<?>"))
        craftStatus = "Error: No recipe for " .. (item.name or "<?>")
        return false
    end

    uoc.addLog(logs, "DEBUG: Found recipe for: " .. (item.name or "<?>"))
    local recipeOutput = (craftables[1].output and craftables[1].output.size) or 1
    if recipeOutput == 0 then recipeOutput = 1 end
    local quantity = math.max(1, tonumber(item.craftSize) or 1)
    local estimatedOutput = math.ceil(quantity / recipeOutput) * recipeOutput

    if current + estimatedOutput >= count then
        uoc.addLog(logs, "INFO: Item '" .. (item.name or "<?>") .. "' will meet target (" .. estimatedOutput .. "x).")
        craftStatus = "Sufficient: " .. (item.name or "<?>")
        return false
    end

    local ok, req = pcall(craftables[1].request, craftables[1], quantity, false, freeCpu)
    if ok and req then
        local committed = req.size or req.qty or quantity
        craftStatus = "Crafting: " .. (item.name or "<?>")
        uoc.addLog(logs, "INFO: Requested craft of " .. quantity .. "x " .. (item.name or "<?>") .. " on CPU " .. tostring(freeCpu))
        lastRequestedItem = {id = item.id, dmg = item.dmg, expectedOutput = committed}
        lastRequestTime = computer.uptime()
        return true
    else
        uoc.addLog(logs, "ERROR: Failed to craft " .. (item.name or "<?>") .. ": " .. tostring(req))
        craftStatus = "Error: Craft rejected"
        return false
    end
end

local function doCraft()
    isCrafting = true
    craftStatus = "AutoCrafting..."
    save()
    uoc.addLog(logs, "INFO: Started AutoCraft")
    draw()
end

local function stopCraft()
    isCrafting = false
    craftStatus = "Stopped"
    uoc.addLog(logs, "WARN: Stopped AutoCraft")
    draw()
end

local function craftAll()
    isCrafting = true
    craftStatus = "Crafting All..."
    uoc.addLog(logs, "INFO: Started crafting all items")
    local crafted = false
    for _, item in ipairs(dataItems) do
        if tryCraftItem(item) then
            crafted = true
        end
    end
    if not crafted then
        craftStatus = "All items sufficient"
        uoc.addLog(logs, "INFO: No items need crafting")
    end
    draw()
end

local function autoCraftLoop()
    uoc.addLog(logs, "DEBUG: Starting autoCraftLoop")
    while true do
        if isCrafting then
            local now = computer.uptime()
            if now >= nextCraftUpdate then
                uoc.addLog(logs, "DEBUG: AutoCraft cycle")
                local ok, err = pcall(reload)
                if not ok then
                    uoc.addLog(logs, "ERROR: Reload failed: " .. tostring(err))
                    craftStatus = "Error: Data update"
                else
                    local craftedThisCycle = false
                    for _, item in ipairs(dataItems) do
                        if not craftedThisCycle and tryCraftItem(item) then
                            craftedThisCycle = true
                            break
                        end
                    end
                    save()
                    nextCraftUpdate = now + 30
                    uoc.addLog(logs, "DEBUG: AutoCraft cycle complete. Crafted: " .. tostring(craftedThisCycle))
                end
            end
        end
        draw()
        os.sleep(0.2)
    end
end

-- Event Handlers
local function updateButtonHover(x, y)
    local btns = {
        {name = "Craft All", x = WIDTH - 75, action = "craftAll", hover = false},
        {name = "Delete", x = WIDTH - 60, action = "delete", hover = false},
        {name = "Edit", x = WIDTH - 45, action = "edit", hover = false},
        {name = isCrafting and "Stop" or "AutoCraft", x = WIDTH - 30, action = "toggleCraft", hover = false},
        {name = "Add", x = WIDTH - 15, action = "add", hover = false},
    }
    local arrowBtnW, arrowBtnH, arrowBtnY = 4, 3, HEIGHT - 4
    local prevArrowBtnX = 2
    local nextArrowBtnX = prevArrowBtnX + arrowBtnW + 1
    local sortBtnX = nextArrowBtnX + arrowBtnW + 1
    local sortBtnW = 14

    for _, btn in ipairs(btns) do
        if x >= btn.x and x <= btn.x + 12 - 1 and y >= arrowBtnY and y <= arrowBtnY + 3 - 1 then
            btn.hover = true
        end
    end
    if x >= prevArrowBtnX and x <= prevArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        return true, "prevPage"
    elseif x >= nextArrowBtnX and x <= nextArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        return true, "nextPage"
    elseif x >= sortBtnX and x <= sortBtnX + sortBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        return true, "sort"
    end
    return false, nil
end

event.listen("touch", function(_, _, x, y)
    if changeItem then return end
    local btns = {
        {name = "Craft All", x = WIDTH - 75, action = "craftAll"},
        {name = "Delete", x = WIDTH - 60, action = "delete"},
        {name = "Edit", x = WIDTH - 45, action = "edit"},
        {name = isCrafting and "Stop" or "AutoCraft", x = WIDTH - 30, action = "toggleCraft"},
        {name = "Add", x = WIDTH - 15, action = "add"},
    }
    for _, btn in ipairs(btns) do
        if x >= btn.x and x <= btn.x + 12 - 1 and y >= HEIGHT - 4 and y <= HEIGHT - 1 then
            uoc.addLog(logs, "DEBUG: Button '" .. btn.name .. "' clicked")
            if btn.action == "delete" then removeItem()
            elseif btn.action == "edit" then editItem()
            elseif btn.action == "toggleCraft" then if isCrafting then stopCraft() else doCraft() end
            elseif btn.action == "add" then addItem()
            elseif btn.action == "craftAll" then craftAll()
            end
            draw()
            return
        end
    end
    local arrowBtnW, arrowBtnH, arrowBtnY = 4, 3, HEIGHT - 4
    local prevArrowBtnX = 2
    local nextArrowBtnX = prevArrowBtnX + arrowBtnW + 1
    local sortBtnX = nextArrowBtnX + arrowBtnW + 1
    local sortBtnW = 14
    if x >= prevArrowBtnX and x <= prevArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        uoc.addLog(logs, "DEBUG: Button '<-' clicked")
        if currentPage > 1 then
            currentPage = currentPage - 1
            selectedItem = nil
            draw()
        end
        return
    elseif x >= nextArrowBtnX and x <= nextArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        uoc.addLog(logs, "DEBUG: Button '->' clicked")
        if currentPage < getMaxPages() then
            currentPage = currentPage + 1
            selectedItem = nil
            draw()
        end
        return
    elseif x >= sortBtnX and x <= sortBtnX + sortBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        uoc.addLog(logs, "DEBUG: Button 'Sort' clicked")
        local criteriaList = {"name", "category", "current", "count", "craftSize"}
        local currentIndex = 1
        for i, v in ipairs(criteriaList) do
            if v == settings.sortCriteria then
                currentIndex = i
                break
            end
        end
        currentIndex = currentIndex % #criteriaList + 1
        if currentIndex == 1 then
            settings.sortAscending = not settings.sortAscending
        else
            settings.sortAscending = true
        end
        settings.sortCriteria = criteriaList[currentIndex]
        currentPage = 1
        selectedItem = nil
        save()
        draw()
        return
    end
    if y >= HEIGHT - 17 and y <= HEIGHT - 15 then
        searchActive = false
        if x >= WIDTH - 9 and x <= WIDTH - 7 and search ~= "" then
            search = ""
            currentPage = 1
            selectedItem = nil
            draw()
            return
        elseif x >= 4 and x <= WIDTH - 10 then
            searchActive = true
            draw()
            return
        end
    else
        searchActive = false
    end
    local filteredItems = getFilteredAndSortedItems()
    local perPage = getItemsPerPage()
    local startIndex = (currentPage - 1) * perPage + 1
    local itemsStartY, itemsEndY = 11, 11 + perPage - 1
    if y >= itemsStartY and y <= itemsEndY then
        local idx = startIndex + (y - itemsStartY)
        if filteredItems[idx] then
            for i, item in ipairs(dataItems) do
                if item == filteredItems[idx] then
                    selectedItem = i
                    break
                end
            end
            draw()
        end
    end
end)

event.listen("key_down", function(_, _, char, code)
    if changeItem then return end
    local filteredItems = getFilteredAndSortedItems()
    local perPage = getItemsPerPage()
    if searchActive then
        uoc.addLog(logs, "DEBUG: Search input, key: " .. char)
        if char == 8 then -- Backspace
            search = unicode.sub(search, 1, -2)
        elseif char == 127 then -- Delete
            search = ""
        elseif code == 28 then -- Enter
            searchActive = false
        elseif char >= 32 and char < 127 then
            if unicode.len(search) < WIDTH - 15 then
                search = search .. unicode.char(char)
            end
        end
        currentPage = 1
        selectedItem = nil
    else
        uoc.addLog(logs, "DEBUG: Key pressed: " .. code)
        if code == 200 then -- Up
            local visibleItems = {}
            local startIndex = (currentPage - 1) * perPage + 1
            for i = startIndex, math.min(#filteredItems, startIndex + perPage - 1) do
                table.insert(visibleItems, filteredItems[i])
            end
            if selectedItem then
                for i, v in ipairs(visibleItems) do
                    if v == dataItems[selectedItem] then
                        if i > 1 then
                            for k, item in ipairs(dataItems) do
                                if item == visibleItems[i - 1] then
                                    selectedItem = k
                                    break
                                end
                            end
                        elseif currentPage > 1 then
                            currentPage = currentPage - 1
                            selectedItem = nil
                            for k, item in ipairs(dataItems) do
                                if item == filteredItems[(currentPage - 1) * perPage + perPage] then
                                    selectedItem = k
                                    break
                                end
                            end
                        end
                        break
                    end
                end
            elseif #visibleItems > 0 then
                for k, item in ipairs(dataItems) do
                    if item == visibleItems[#visibleItems] then
                        selectedItem = k
                        break
                    end
                end
            end
        elseif code == 208 then -- Down
            local visibleItems = {}
            local startIndex = (currentPage - 1) * perPage + 1
            for i = startIndex, math.min(#filteredItems, startIndex + perPage - 1) do
                table.insert(visibleItems, filteredItems[i])
            end
            if selectedItem then
                for i, v in ipairs(visibleItems) do
                    if v == dataItems[selectedItem] then
                        if i < #visibleItems then
                            for k, item in ipairs(dataItems) do
                                if item == visibleItems[i + 1] then
                                    selectedItem = k
                                    break
                                end
                            end
                        elseif currentPage < getMaxPages() then
                            currentPage = currentPage + 1
                            selectedItem = nil
                            for k, item in ipairs(dataItems) do
                                if item == filteredItems[(currentPage - 1) * perPage + 1] then
                                    selectedItem = k
                                    break
                                end
                            end
                        end
                        break
                    end
                end
            elseif #visibleItems > 0 then
                for k, item in ipairs(dataItems) do
                    if item == visibleItems[1] then
                        selectedItem = k
                        break
                    end
                end
            end
        elseif code == 203 then -- Left
            if currentPage > 1 then
                currentPage = currentPage - 1
                selectedItem = nil
            end
        elseif code == 205 then -- Right
            if currentPage < getMaxPages() then
                currentPage = currentPage + 1
                selectedItem = nil
            end
        elseif code == 201 then -- Page Up
            logOffset = math.min(logOffset + 1, #logs - 4)
        elseif code == 209 then -- Page Down
            logOffset = math.max(logOffset - 1, 0)
        end
    end
    draw()
end)

-- Main
if not checkComponents() then
    while true do os.sleep(1) end
end
gpu.setResolution(WIDTH, HEIGHT)
uoc.addLog(logs, "DEBUG: Program started")
if not loadLibrary() then
    uoc.addLog(logs, "WARNING: Using fallback library functions")
end
local ok, err = pcall(reload)
if not ok then
    uoc.addLog(logs, "ERROR: Initial load failed: " .. tostring(err))
    draw()
    while true do os.sleep(1) end
end
draw()
local ok, err = pcall(autoCraftLoop)
if not ok then
    uoc.addLog(logs, "ERROR: Fatal error in autoCraftLoop: " .. tostring(err))
    draw()
    while true do os.sleep(1) end
end
