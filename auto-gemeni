local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode")
local term = require("term")
local computer = require("computer")
local g = component.gpu
local me = component.me_interface
local serialization = require("serialization")

-- Paths and library
local DATA_FILE = "/home/BD.txt"
local LIB_PATH = "/lib/ultimateOC.lua"
local LIB_URL = "https://raw.githubusercontent.com/shify4713/lua/refs/heads/main/ultimateOC.lua"

-- Check component availability
local function checkComponents()
    if not component.isAvailable("gpu") or not component.isAvailable("screen") or not component.isAvailable("me_interface") then
        io.stderr:write("Error: Required components (GPU, Screen, ME Interface) not available\n")
        os.exit(1)
    end
end

-- Bind GPU to screen
local function bindGpu()
    local screen = component.list("screen")()
    if not screen then io.stderr:write("Error: No screen found\n") os.exit(1) end
    g.bind(screen)
    io.stdout:write("GPU bound to screen: " .. screen .. "\n")
end

-- Load or download ultimateOC library
if not fs.exists(LIB_PATH) then
    io.stdout:write("Downloading ultimateOC.lua...\n")
    shell.execute("wget -f " .. LIB_URL .. " " .. LIB_PATH)
end
local uoc = require("ultimateOC") or {
    drawText = function(x, y, text, color) g.setForeground(color or 0xFFFFFF) g.set(x, y, text) end,
    roundRect = function(x, y, w, h, borderColor, bgColor) 
        g.setForeground(borderColor or 0xFFFFFF) 
        g.setBackground(bgColor or 0x000000) 
        g.fill(x, y, w, h, " ") 
    end,
    animatedButton = function(x, y, w, h, text, hover, bgColor, activeColor, textColor)
        g.setBackground(hover and activeColor or bgColor)
        g.fill(x, y, w, h, " ")
        g.setForeground(textColor)
        local textX = x + math.floor((w - unicode.len(text)) / 2)
        local textY = y + math.floor(h / 2)
        g.set(textX, textY, text)
    end,
    savef = function(path, data) local f = io.open(path, "w") f:write(serialization.serialize(data)) f:close() end,
    loadf = function(path) 
        local f = io.open(path, "r") 
        if not f then return nil end 
        local c = f:read("*a") 
        f:close() 
        return serialization.unserialize(c) 
    end
}

-- Initialize data file
if not fs.exists(DATA_FILE) then
    uoc.savef(DATA_FILE, {items = {}, settings = {sortCriteria = "name", sortAscending = true}})
end

-- Colors and settings
local COLORS = {
    button = 0x00BFFF, buttonActive = 0x1E90FF, border = 0x44475a, text = 0xF8F8F2,
    bg = 0x23242b, error = 0xFF5555, ok = 0x50FA7B, input_bg = 0x282A36, input_text = 0xF8F8F2
}
local WIDTH, HEIGHT = g.getResolution()
local craftStatus, isCrafting = "Waiting...", false
local logs, dataItems, settings = {}, {}, {sortCriteria = "name", sortAscending = true}
local search, selectedItem, currentPage, changeitem = "", nil, 1, false

-- Helper functions
local function addLog(logs, text) table.insert(logs, text) if #logs > 50 then table.remove(logs, 1) end end

local function getFilteredAndSortedItems()
    local filtered = {}
    for _, item in ipairs(dataItems) do
        if search == "" or unicode.lower(item.name or ""):find(unicode.lower(search)) then
            table.insert(filtered, item)
        end
    end
    table.sort(filtered, function(a, b)
        local valA = settings.sortCriteria == "name" and unicode.lower(a.name or "") or tonumber(a[settings.sortCriteria] or 0)
        local valB = settings.sortCriteria == "name" and unicode.lower(b.name or "") or tonumber(b[settings.sortCriteria] or 0)
        return settings.sortAscending and valA < valB or valA > valB
    end)
    return filtered
end

local function getItemsPerPage() return HEIGHT - 20 end
local function getMaxPages() return math.max(1, math.ceil(#getFilteredAndSortedItems() / getItemsPerPage())) end

-- UI drawing functions
local function clear() g.setBackground(COLORS.bg) g.fill(1, 1, WIDTH, HEIGHT, " ") g.setForeground(COLORS.text) end

local function drawHeader()
    uoc.drawText(2, 2, "Ultimate AutoCraft", COLORS.ok)
    uoc.drawText(2, 4, "Status: " .. craftStatus, craftStatus:find("Error") and COLORS.error or COLORS.ok)
end

local function drawItems()
    local items = getFilteredAndSortedItems()
    local perPage = getItemsPerPage()
    local start = (currentPage - 1) * perPage + 1
    for i = start, math.min(#items, start + perPage - 1) do
        local item = items[i]
        local y = 8 + (i - start)
        g.setBackground(selectedItem and dataItems[selectedItem] == item and COLORS.button or COLORS.bg)
        g.fill(1, y, WIDTH - 25, 1, " ")
        g.setForeground(COLORS.text)
        g.set(2, y, string.format("%-30s %-15s %-10s %-10s", item.name or "??", item.category or "No category", item.current or 0, item.count or 0))
    end
end

local function drawButtons()
    local btns = {{"Add", "add"}, {"Edit", "edit"}, {"Delete", "delete"}, {isCrafting and "Stop" or "Craft", "toggleCraft"}}
    for i, btn in ipairs(btns) do
        uoc.animatedButton(WIDTH - 15, 10 + (i-1)*4, 12, 3, btn[1], false, COLORS.button, COLORS.buttonActive, COLORS.text)
    end
end

local function draw()
    if not changeitem then
        clearrobot clear() drawHeader() drawItems() drawButtons()
    end
end

-- Input handling
local function simplePrompt(label, default, x, y)
    g.setBackground(COLORS.input_bg)
    g.fill(1, y, WIDTH, 1, " ")
    g.setForeground(COLORS.text)
    g.set(x, y, label)
    local input = default or ""
    g.setForeground(COLORS.input_text)
    g.set(x + unicode.len(label), y, input)
    term.setCursor(x + unicode.len(label) + unicode.len(input), y)
    term.cursorBlink(true)
    
    while true do
        local _, _, char, code = event.pull("key_down")
        if code == 28 then break -- Enter
        elseif code == 14 and #input > 0 then -- Backspace
            input = unicode.sub(input, 1, -2)
        elseif char >= 32 and char <= 126 then -- Printable chars
            input = input .. unicode.char(char)
        end
        g.setBackground(COLORS.input_bg)
        g.fill(x + unicode.len(label), y, WIDTH, 1, " ")
        g.setForeground(COLORS.input_text)
        g.set(x + unicode.len(label), y, input)
        term.setCursor(x + unicode.len(label) + unicode.len(input), y)
    end
    term.cursorBlink(false)
    g.setBackground(COLORS.bg)
    return input ~= "" and input or default
end

-- Item management
local function addItem()
    changeitem = true
    clear()
    uoc.roundRect(5, HEIGHT-15, WIDTH-10, 12, COLORS.border, COLORS.input_bg)
    uoc.drawText(6, HEIGHT-14, "Add Item", COLORS.ok)
    uoc.drawText(6, HEIGHT-13, "Insert item into slot 1 of ME interface", COLORS.text)
    
    local stack = me.getStackInSlot(1)
    if not stack then
        uoc.drawText(6, HEIGHT-11, "Error: No item in slot 1", COLORS.error)
        os.sleep(2)
        changeitem = false
        draw()
        return
    end
    
    local name = simplePrompt("Name: ", stack.label or stack.id, 6, HEIGHT-11)
    local category = simplePrompt("Category: ", "No category", 6, HEIGHT-9)
    local count = tonumber(simplePrompt("Hold: ", "0", 6, HEIGHT-7)) or 0
    local craftSize = tonumber(simplePrompt("Craft Size: ", "1", 6, HEIGHT-5)) or 1
    
    table.insert(dataItems, {name = name, category = category, id = stack.id, dmg = stack.dmg, count = count, craftSize = craftSize})
    uoc.savef(DATA_FILE, {items = dataItems, settings = settings})
    changeitem = false
    draw()
end

local function editItem()
    if not selectedItem then return end
    changeitem = true
    clear()
    uoc.roundRect(5, HEIGHT-15, WIDTH-10, 12, COLORS.border, COLORS.input_bg)
    uoc.drawText(6, HEIGHT-14, "Edit Item", COLORS.ok)
    
    local item = dataItems[selectedItem]
    local name = simplePrompt("Name: ", item.name, 6, HEIGHT-11)
    local category = simplePrompt("Category: ", item.category, 6, HEIGHT-9)
    local count = tonumber(simplePrompt("Hold: ", tostring(item.count), 6, HEIGHT-7)) or item.count
    local craftSize = tonumber(simplePrompt("Craft Size: ", tostring(item.craftSize), 6, HEIGHT-5)) or item.craftSize
    
    item.name, item.category, item.count, item.craftSize = name, category, count, craftSize
    uoc.savef(DATA_FILE, {items = dataItems, settings = settings})
    changeitem = false
    draw()
end

local function deleteItem()
    if selectedItem then
        table.remove(dataItems, selectedItem)
        selectedItem = nil
        uoc.savef(DATA_FILE, {items = dataItems, settings = settings})
        draw()
    end
end

-- Event handling
event.listen("touch", function(_, _, x, y)
    if changeitem then return end
    if x >= WIDTH-15 and x <= WIDTH-3 then
        if y >= 10 and y < 13 then addItem()
        elseif y >= 14 and y < 17 then editItem()
        elseif y >= 18 and y < 21 then deleteItem()
        elseif y >= 22 and y < 25 then isCrafting = not isCrafting draw()
        end
    elseif y >= 8 and y <= HEIGHT-20 then
        local idx = math.floor((y-8) / 1) + (currentPage-1) * getItemsPerPage() + 1
        if getFilteredAndSortedItems()[idx] then
            for i, item in ipairs(dataItems) do
                if item == getFilteredAndSortedItems()[idx] then selectedItem = i break end
            end
            draw()
        end
    end
end)

-- Main loop
checkComponents()
bindGpu()
local data = uoc.loadf(DATA_FILE) or {items = {}, settings = {sortCriteria = "name", sortAscending = true}}
dataItems, settings = data.items, data.settings
draw()

while true do
    os.sleep(0.1)
    if isCrafting then
        -- Add crafting logic here if needed
    end
end
