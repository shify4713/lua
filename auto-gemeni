-- auto-gemeni.txt
local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode")
local term = require("term")
local computer = require("computer")
local g = component.gpu
local me = component.me_interface

-- Пути и библиотека
local DATA_FILE = "/home/BD.txt"
local LIB_PATH = "/lib/ultimateOC.lua"
local LIB_URL = "https://raw.githubusercontent.com/shify4713/lua/refs/heads/main/lib-gemeni"

-- Проверка доступности компонентов
local function checkComponents()
    if not component.isAvailable("gpu") then
        io.stderr:write("Ошибка: GPU недоступен\n")
        os.exit(1)
    end
    if not component.isAvailable("screen") then
        io.stderr:write("Ошибка: Экран недоступен\n")
        os.exit(1)
    end
    if not component.isAvailable("me_interface") then
        io.stderr:write("Ошибка: ME-интерфейс недоступен\n")
        os.exit(1)
    end
end

-- Привязка GPU к экрану
local function bindGpu()
    local screen = component.list("screen")()
    if not screen then
        io.stderr:write("Ошибка: Не найден экран для привязки GPU\n")
        os.exit(1)
    end
    local success, err = pcall(g.bind, screen)
    if not success then
        io.stderr:write("Ошибка: Не удалось привязать GPU к экрану: " .. tostring(err) .. "\n")
        os.exit(1)
    end
    io.stdout:write("GPU привязан к экрану: " .. screen .. "\n")
    return true
end

-- Проверяем наличие библиотеки
if not fs.exists(LIB_PATH) then
    io.stdout:write("ultimateOC.lua не найден. Скачивание...\n")
    local success, err = shell.execute("wget -f " .. LIB_URL .. " " .. LIB_PATH)
    if not success then
        io.stderr:write("Не удалось скачать ultimateOC.lua: " .. tostring(err) .. "\n")
        os.exit(1)
    end
end
local ok, uoc = pcall(require, "ultimateOC")
if not ok then
    io.stderr:write("Не удалось загрузить ultimateOC.lua: " .. tostring(uoc) .. "\n")
    uoc = {}
    function uoc.drawText(x, y, text, color, bold) 
        g.setForeground(color or 0xFFFFFF) 
        g.set(x, y, text) 
    end
    function uoc.roundRect(x, y, w, h, borderColor, bgColor) 
        g.setForeground(borderColor or 0xFFFFFF) 
        g.setBackground(bgColor or 0x000000) 
        g.fill(x, y, w, h, " ") 
    end
    function uoc.animatedButton(x, y, w, h, text, hover, bgColor, activeColor, textColor) 
        g.setBackground(hover and activeColor or bgColor) 
        g.fill(x, y, w, h, " ") 
        g.setForeground(textColor) 
        local textX = x + math.floor((w - unicode.len(text)) / 2)
        local textY = y + math.floor(h / 2)
        g.set(textX, textY, text) 
    end
    function uoc.drawLogs(x, y, logs, lines, color, offset) 
        g.setForeground(color) 
        for i = 1, lines do
            local logIndex = #logs - lines + i - offset
            if logIndex > 0 then
                g.set(x, y + i - 1, logs[logIndex] or "")
            end
        end
    end
    function uoc.savef(path, data) 
        local file = io.open(path, "w") 
        if file then 
            file:write(textutils.serialize(data)) 
            file:close() 
        end 
    end
    function uoc.loadf(path) 
        local file = io.open(path, "r") 
        if not file then return nil end 
        local content = file:read("*a") 
        file:close() 
        return load("return " .. content)() 
    end
    function uoc.progressBar(x, y, w, progress) 
        g.setBackground(0x44475a) 
        g.fill(x, y, w, 1, " ") 
        g.setBackground(0x50FA7B) 
        g.fill(x, y, math.floor(w * progress), 1, " ") 
    end
end

-- Проверяем файл данных
if not fs.exists(DATA_FILE) then
    uoc.savef(DATA_FILE, {items = {}, settings = {sortCriteria = "name", sortAscending = true}})
    io.stdout:write("Создан новый файл BD.txt\n")
end

-------------------- Настройки --------------------
local COLORS = {
    button = 0x00BFFF,
    buttonActive = 0x1E90FF,
    border = 0x44475a,
    text = 0xF8F8F2,
    shadow = 0x282A36,
    bg = 0x23242b,
    error = 0xFF5555,
    ok = 0x50FA7B,
    log = 0x8BE9FD,
    progress_bg = 0x44475a,
    progress_fg = 0x50FA7B,
    select = 0x31313A,
    select_active = 0x44B3FF,
    search_bg = 0x282B36,
    search_border = 0x00BFFF,
    search_cross = 0xFF5555,
    search_hint = 0x888888,
    bar_shadow = 0x181920,
    warning = 0xFFB86C,
    input_bg = 0x282B36,
    input_border = 0x00BFFF,
    input_text = 0xF8F8F2,
}
local WIDTH, HEIGHT = g.maxResolution()
local craftStatus = "Ожидание..."
local nextCraftUpdate = 0
local isCrafting = false
local logs = {}
local dataItems = {}
local settings = {sortCriteria = "name", sortAscending = true}
local search = ""
local selectedItem = nil
local currentPage = 1
local changeitem = false
local searchActive = false
local logOffset = 0
local lastRequestedItem = nil
local lastRequestTime = 0
local buttonHover = nil
local inputMode = nil -- "add" or "edit"
local inputFields = {}
local currentField = 1
local inputActive = false

-------------------- Логгирование --------------------
local function addLog(logs, text, lvl)
    lvl = lvl or "INFO"
    local t = string.format("%-7s %s", "[" .. lvl .. "]", text)
    table.insert(logs, t)
    while #logs > 50 do table.remove(logs, 1) end
end

-------------------- Вспомогательные функции --------------------
local function getFilteredAndSortedItems()
    local filtered = {}
    for i, item in ipairs(dataItems) do
        if search == "" or unicode.lower(item.name or ""):find(unicode.lower(search), 1, true) then
            if not item.category then item.category = "Без категории" end
            table.insert(filtered, item)
        end
    end
    table.sort(filtered, function(a, b)
        local valA, valB
        if settings.sortCriteria == "name" then
            valA = unicode.lower(a.name or "")
            valB = unicode.lower(b.name or "")
        elseif settings.sortCriteria == "current" then
            valA = tonumber(a.current) or 0
            valB = tonumber(b.current) or 0
        elseif settings.sortCriteria == "count" then
            valA = tonumber(a.count) or 0
            valB = tonumber(b.count) or 0
        elseif settings.sortCriteria == "craftSize" then
            valA = tonumber(a.craftSize) or 0
            valB = tonumber(b.craftSize) or 0
        elseif settings.sortCriteria == "category" then
            valA = unicode.lower(a.category or "Без категории")
            valB = unicode.lower(b.category or "Без категории")
        end
        if settings.sortAscending then
            return valA < valB
        else
            return valA > valB
        end
    end)
    return filtered
end

local function getItemsPerPage()
    return HEIGHT - 20
end

local function getMaxPages()
    local filteredItems = getFilteredAndSortedItems()
    local perPage = getItemsPerPage()
    return math.max(1, math.ceil(#filteredItems / perPage))
end

local function clampPage()
    local maxPages = getMaxPages()
    currentPage = math.max(1, math.min(currentPage, maxPages))
end

-------------------- Визуал --------------------
local function clear()
    g.setBackground(COLORS.bg)
    g.fill(1, 1, WIDTH, HEIGHT, " ")
    g.setForeground(COLORS.text)
end

local function drawHeader()
    uoc.drawText(2, 2, "Ultimate AutoCraft", COLORS.ok, true)
    g.setBackground(COLORS.progress_fg)
    g.fill(1, 3, WIDTH, 1, " ")
    g.setBackground(COLORS.bg)
    uoc.drawText(2, 4, "Статус: " .. craftStatus,
        (craftStatus:find("Ошибка") and COLORS.error) or COLORS.ok)
    if uoc.progressBar then
        uoc.progressBar(2, 5, WIDTH - 20, isCrafting and 0.9 or 0)
    end
    local maxPages = getMaxPages()
    uoc.drawText(2, 6, "Страница: " .. currentPage .. "/" .. maxPages, COLORS.text)
end

local function drawItems()
    local filteredAndSortedItems = getFilteredAndSortedItems()
    local x, y = 1, 8
    local totalWidth = WIDTH - 25 -- Уменьшено для большего пространства справа
    local col_name = math.floor(totalWidth * 0.35)
    local col_category = math.floor(totalWidth * 0.15)
    local col_now = math.floor(totalWidth * 0.15)
    local col_hold = math.floor(totalWidth * 0.15)
    local col_once = totalWidth - col_name - col_category - col_now - col_hold

    g.setForeground(COLORS.select_active)
    g.set(x, y, "┌" .. string.rep("─", col_name) .. "┬" .. string.rep("─", col_category) .. "┬" .. string.rep("─", col_now) .. "┬" .. string.rep("─", col_hold) .. "┬" .. string.rep("─", col_once) .. "┐")
    g.set(x, y + 1, "│")
    g.setForeground(COLORS.ok)
    g.set(x + 1, y + 1, string.format("%-" .. col_name .. "s", "Название"))
    g.setForeground(COLORS.select_active)
    g.set(x + col_name + 1, y + 1, "│")
    g.setForeground(COLORS.ok)
    g.set(x + col_name + 2, y + 1, string.format("%-" .. col_category .. "s", "Категория"))
    g.setForeground(COLORS.select_active)
    g.set(x + col_name + col_category + 2, y + 1, "│")
    g.setForeground(COLORS.ok)
    g.set(x + col_name + col_category + 3, y + 1, string.format("%-" .. col_now .. "s", "В наличии"))
    g.setForeground(COLORS.select_active)
    g.set(x + col_name + col_category + col_now + 3, y + 1, "│")
    g.setForeground(COLORS.ok)
    g.set(x + col_name + col_category + col_now + 4, y + 1, string.format("%-" .. col_hold .. "s", "Держать"))
    g.setForeground(COLORS.select_active)
    g.set(x + col_name + col_category + col_now + col_hold + 4, y + 1, "│")
    g.setForeground(COLORS.ok)
    g.set(x + col_name + col_category + col_now + col_hold + 5, y + 1, string.format("%-" .. col_once .. "s", "За раз"))
    g.setForeground(COLORS.select_active)
    g.set(x + col_name + col_category + col_now + col_hold + col_once + 5, y + 1, "│")
    g.set(x, y + 2, "├" .. string.rep("─", col_name) .. "┼" .. string.rep("─", col_category) .. "┼" .. string.rep("─", col_now) .. "┼" .. string.rep("─", col_hold) .. "┼" .. string.rep("─", col_once) .. "┤")

    local perPage = getItemsPerPage()
    local startIndex = (currentPage - 1) * perPage + 1
    for i = startIndex, math.min(#filteredAndSortedItems, startIndex + perPage - 1) do
        local it = filteredAndSortedItems[i]
        local isSel = (selectedItem and dataItems[selectedItem] and it == dataItems[selectedItem])
        local row = y + 2 + (i - startIndex)
        g.setBackground(isSel and COLORS.select_active or COLORS.bg)
        g.fill(x, row, totalWidth + 2, 1, " ")
        g.setForeground(tonumber(it.current or 0) < tonumber(it.count or 0) and COLORS.warning or COLORS.text)
        g.set(x, row, "│")
        local nameStr = tostring(it.name or "<??>")
        if unicode.len(nameStr) > col_name then
            nameStr = unicode.sub(nameStr, 1, col_name - 1) .. "…"
        end
        g.set(x + 1, row, string.format("%-" .. col_name .. "s", nameStr))
        g.set(x + col_name + 1, row, "│")
        local categoryStr = tostring(it.category or "Без категории")
        if unicode.len(categoryStr) > col_category then
            categoryStr = unicode.sub(categoryStr, 1, col_category - 1) .. "…"
        end
        g.set(x + col_name + 2, row, string.format("%-" .. col_category .. "s", categoryStr))
        g.set(x + col_name + col_category + 2, y + 1, "│")
        g.set(x + col_name + col_category + 2, row, "│") -- Исправлено: добавлена строка для отрисовки вертикальной линии
        local current_val = tonumber(it.current) or 0
        local current_str = tostring(current_val)
        if unicode.len(current_str) > col_now then
            current_str = unicode.sub(current_str, 1, col_now - 1) .. "…"
        end
        g.set(x + col_name + col_category + 3, row, string.format("%-" .. col_now .. "s", current_str))
        g.set(x + col_name + col_category + col_now + 3, row, "│")
        local hold_val = tonumber(it.count) or 0
        local hold_str = tostring(hold_val)
        if unicode.len(hold_str) > col_hold then
            hold_str = unicode.sub(hold_str, 1, col_hold - 1) .. "…"
        end
        g.set(x + col_name + col_category + col_now + 4, row, string.format("%-" .. col_hold .. "s", hold_str))
        g.set(x + col_name + col_category + col_now + col_hold + 4, row, "│")
        local craftSize_val = tonumber(it.craftSize) or 0
        local craftSize_str = tostring(craftSize_val)
        if unicode.len(craftSize_str) > col_once then
            craftSize_str = unicode.sub(craftSize_str, 1, col_once - 1) .. "…"
        end
        g.set(x + col_name + col_category + col_now + col_hold + 5, row, string.format("%-" .. col_once .. "s", craftSize_str))
        g.set(x + col_name + col_category + col_now + col_hold + col_once + 5, row, "│")
    end
    for i = math.min(#filteredAndSortedItems, startIndex + perPage - 1) + 1, startIndex + perPage - 1 do
        local row = y + 2 + (i - startIndex)
        g.setBackground(COLORS.bg)
        g.fill(x, row, totalWidth + 2, 1, " ")
    end
    g.setForeground(COLORS.select_active)
    g.set(x, y + perPage + 2, "└" .. string.rep("─", col_name) .. "┴" .. string.rep("─", col_category) .. "┴" .. string.rep("─", col_now) .. "┴" .. string.rep("─", col_hold) .. "┴" .. string.rep("─", col_once) .. "┘")
    g.setForeground(COLORS.text)
end

local function drawSearchBar()
    local x, y = 2, HEIGHT - 10
    local w, h = WIDTH - 20, 3
    uoc.roundRect(x, y, w, h, COLORS.search_border, COLORS.search_bg)
    g.setBackground(COLORS.search_bg)
    g.fill(x + 1, y + 1, w - 2, h - 2, " ")
    g.setForeground(COLORS.search_cross)
    g.set(x + w - 3, y + 1, (search ~= "" and "×" or " "))
    g.setForeground(searchActive and COLORS.ok or COLORS.search_hint)
    local display = search
    if display == "" then display = "Поиск: введите часть названия..." end
    if searchActive then display = display .. "_" end
    local maxlen = w - 7
    if unicode.len(display) > maxlen then
        display = unicode.sub(display, unicode.len(display) - maxlen + 2)
    end
    g.set(x + 2, y + 1, display)
    g.setBackground(COLORS.bg)
    g.setForeground(COLORS.text)
end

local function drawLogs()
    local logLines = 5
    uoc.drawLogs(2, HEIGHT - logLines, logs, logLines, COLORS.log, logOffset)
end

local function drawButtons()
    local btnWidth = 12
    local btnHeight = 3
    local btnX = WIDTH - btnWidth - 5 -- Больше пространства от таблицы
    local btnPadding = 2 -- Увеличено расстояние между кнопками
    local btns = {
        {name = "Крафт всех", action = "craftAll"},
        {name = "Удалить", action = "delete"},
        {name = "Изменить", action = "edit"},
        {name = isCrafting and "Остановить" or "Автокрафт", action = "toggleCraft"},
        {name = "Добавить", action = "add"},
    }
    for i, btn in ipairs(btns) do
        local btnY = 10 + (i - 1) * (btnHeight + btnPadding) -- Сдвинули вниз
        local hover = (buttonHover == btn.action)
        local bg = hover and COLORS.buttonActive or COLORS.button -- Определяем фон здесь
        g.setBackground(bg) -- Устанавливаем фон явно
        g.fill(btnX, btnY, btnWidth, btnHeight, " ") -- Заполняем фон
        uoc.animatedButton(btnX, btnY, btnWidth, btnHeight, btn.name, hover, COLORS.button, COLORS.buttonActive, COLORS.text)
    end
    local arrowBtnW = 4
    local arrowBtnH = 3
    local arrowBtnY = 10 + (#btns * (btnHeight + btnPadding))
    local prevArrowBtnX = btnX
    local nextArrowBtnX = btnX + arrowBtnW + 1
    local maxPages = getMaxPages()
    local prevEnabled = (currentPage > 1)
    local prevHover = (buttonHover == "prevPage")
    local prevBg = prevHover and COLORS.buttonActive or COLORS.button
    g.setBackground(prevBg)
    g.fill(prevArrowBtnX, arrowBtnY, arrowBtnW, arrowBtnH, " ")
    uoc.animatedButton(prevArrowBtnX, arrowBtnY, arrowBtnW, arrowBtnH, "<-", prevHover,
        prevEnabled and COLORS.button or COLORS.border,
        prevEnabled and COLORS.buttonActive or COLORS.border,
        prevEnabled and COLORS.text or COLORS.search_hint)
    local nextEnabled = (currentPage < maxPages)
    local nextHover = (buttonHover == "nextPage")
    local nextBg = nextHover and COLORS.buttonActive or COLORS.button
    g.setBackground(nextBg)
    g.fill(nextArrowBtnX, arrowBtnY, arrowBtnW, arrowBtnH, " ")
    uoc.animatedButton(nextArrowBtnX, arrowBtnY, arrowBtnW, arrowBtnH, "->", nextHover,
        nextEnabled and COLORS.button or COLORS.border,
        nextEnabled and COLORS.buttonActive or COLORS.border,
        nextEnabled and COLORS.text or COLORS.search_hint)
    local sortBtnY = arrowBtnY + arrowBtnH + 2
    local sortBtnW = 12
    local sortIndicatorText = ""
    if settings.sortCriteria == "name" then
        sortIndicatorText = "Название"
    elseif settings.sortCriteria == "current" then
        sortIndicatorText = "В наличии"
    elseif settings.sortCriteria == "count" then
        sortIndicatorText = "Держать"
    elseif settings.sortCriteria == "craftSize" then
        sortIndicatorText = "За раз"
    elseif settings.sortCriteria == "category" then
        sortIndicatorText = "Категория"
    end
    sortIndicatorText = sortIndicatorText .. (settings.sortAscending and " ↑" or " ↓")
    local sortHover = (buttonHover == "sort")
    local sortBg = sortHover and COLORS.buttonActive or COLORS.button
    g.setBackground(sortBg)
    g.fill(btnX, sortBtnY, sortBtnW, arrowBtnH, " ")
    uoc.animatedButton(btnX, sortBtnY, sortBtnW, arrowBtnH,
        "Сортировать", sortHover, COLORS.button, COLORS.buttonActive, COLORS.text)
    uoc.drawText(btnX, sortBtnY + 1, sortIndicatorText, COLORS.text)
end

-- Новая функция для рисования рамки
local function drawMainLayoutFrame()
    local x, y = 1, 7 -- Начальные координаты таблицы
    local tableWidth = WIDTH - 25 + 2 -- Ширина таблицы с учетом границ
    local tableHeight = getItemsPerPage() + 3 -- Высота таблицы с учетом заголовков и нижней границы
    local frameX = x - 1
    local frameY = y - 1
    local frameWidth = tableWidth + 2
    local frameHeight = tableHeight + 2

    g.setForeground(COLORS.border)
    g.setBackground(COLORS.bg)
    uoc.roundRect(frameX, frameY, frameWidth, frameHeight, COLORS.border, COLORS.bg)

    -- Дополнительная рамка для кнопок, чтобы отделить их.
    -- Определяем область кнопок
    local btnWidth = 12
    local btnHeight = 3
    local btnX = WIDTH - btnWidth - 5
    local btnPadding = 2
    local numBtns = 5 -- Количество основных кнопок
    local arrowBtnH = 3
    local sortBtnH = 3

    local totalBtnAreaHeight = (numBtns * (btnHeight + btnPadding)) + arrowBtnH + btnPadding + sortBtnH + btnPadding + 4 -- +4 для отступов и нижней рамки
    local btnAreaY = 8 -- Чуть выше, чтобы включить заголовок
    local btnAreaWidth = btnWidth + 4 -- Ширина кнопок + отступы

    uoc.roundRect(btnX - 2, btnAreaY - 2, btnAreaWidth, totalBtnAreaHeight, COLORS.border, COLORS.bg)
    g.setForeground(COLORS.ok)
    uoc.drawText(btnX - 1, btnAreaY - 1, "Действия", COLORS.ok, true)
end


local function drawInputScreen()
    clear()
    local baseY = HEIGHT - 15
    local title = (inputMode == "add") and "Добавление предмета" or "Изменение: " .. (dataItems[selectedItem].name or "<?>")
    uoc.drawText(2, baseY, title, COLORS.ok)
    uoc.drawText(2, baseY + 1, "Вставьте предмет в 1-й слот ME интерфейса (только для добавления).", COLORS.text) -- Обновленный текст

    local fields = {
        {label = "Название:", value = inputFields.name or "", x = 2, y = baseY + 3, w = 40, key = "name"},
        {label = "Категория:", value = inputFields.category or "", x = 2, y = baseY + 5, w = 40, key = "category"},
        {label = "Держать:", value = inputFields.count or "", x = 2, y = baseY + 7, w = 20, key = "count"},
        {label = "Крафт за раз:", value = inputFields.craftSize or "", x = 2, y = baseY + 9, w = 20, key = "craftSize"},
    }

    for i, field in ipairs(fields) do
        local isActive = (i == currentField and inputActive)
        uoc.roundRect(field.x, field.y, field.w, 3, COLORS.input_border, COLORS.input_bg)
        g.setForeground(COLORS.text)
        g.set(field.x + 1, field.y, field.label)
        g.setBackground(COLORS.input_bg)
        g.fill(field.x + 1, field.y + 1, field.w - 2, 1, " ")
        g.setForeground(isActive and COLORS.ok or COLORS.input_text)
        local display = field.value
        if display == "" and not isActive then
            display = "Введите значение..."
        end
        if isActive then
            display = display .. "_"
        end
        local maxlen = field.w - 4
        if unicode.len(display) > maxlen then
            display = unicode.sub(display, unicode.len(display) - maxlen + 1)
        end
        g.set(field.x + 2, field.y + 1, display)
    end
    g.setBackground(COLORS.bg)
    g.setForeground(COLORS.text)
    -- uoc.drawText(2, baseY + 12, "Enter: пропустить/подтвердить, Esc: вернуться в главное меню", COLORS.text) -- Удалена строка с подсказками
end

local function draw()
    if changeitem then
        drawInputScreen()
    else
        clear()
        drawHeader()
        drawMainLayoutFrame() -- Рисуем рамку
        drawItems()
        drawSearchBar()
        drawLogs()
        drawButtons()
    end
end

-------------------- IO и действия --------------------
local function reload()
    local ok, res = pcall(uoc.loadf, DATA_FILE)
    if not ok then
        addLog(logs, "ERROR: Ошибка загрузки BD.txt: " .. tostring(res), "ERROR")
        dataItems = {}
        settings = {sortCriteria = "name", sortAscending = true}
    else
        res = res or {items = {}, settings = {sortCriteria = "name", "sortAscending" = true}} -- Исправлено: "sortAscending" в кавычках
        dataItems = res.items or {}
        settings = res.settings or {sortCriteria = "name", "sortAscending" = true} -- Исправлено: "sortAscending" в кавычках
    end
    clampPage()
    for _, item in ipairs(dataItems) do
        local qty = 0
        local stackList = {}
        local ok, res = pcall(me.getItemsInNetwork, {id = item.id, damage = item.dmg})
        if ok then stackList = res or {} end
        if stackList and stackList.n and stackList.n > 0 then
            for _, stack in ipairs(stackList) do
                if stack.name == item.id and (item.dmg == nil or stack.damage == item.dmg) then
                    qty = qty + (stack.size or stack.qty or 0)
                end
            end
        else
            local ok2, d = pcall(me.getItemDetail, {id = item.id, dmg = item.dmg})
            if ok2 and d then
                qty = qty + (d.qty or d.size or 0)
            end
        end
        local craftingJobs_ok, craftingJobs = pcall(me.getCraftingJobs)
        if craftingJobs_ok and craftingJobs and craftingJobs.n then
            for _, job in ipairs(craftingJobs) do
                if job.output and job.output.id == item.id and
                   (item.dmg == nil or job.output.damage == item.dmg) then
                    qty = qty + (job.output.size or job.output.qty or 0)
                    if lastRequestedItem and lastRequestedItem.id == item.id and
                       (lastRequestedItem.dmg == nil or lastRequestedItem.dmg == item.dmg) then
                        lastRequestedItem = nil
                        lastRequestTime = 0
                    end
                end
            end
        end
        item.current = qty
    end
    if lastRequestedItem and computer.uptime() - lastRequestTime > 30 then
        addLog(logs, "WARN: Таймаут ожидания для '" .. (lastRequestedItem.id or "<??>") .. "'. Сброс lastRequestedItem.", "WARN")
        lastRequestedItem = nil
        lastRequestTime = 0
    end
end

local function save()
    local ok, err = pcall(uoc.savef, DATA_FILE, {items = dataItems, settings = settings})
    if not ok then
        addLog(logs, "ERROR: Ошибка сохранения: " .. tostring(err), "ERROR")
    end
end

local function resetSelection()
    search = ""
    currentPage = 1
    selectedItem = nil
end

local function addItem()
    changeitem = true
    inputMode = "add"
    inputFields = {name = "", category = "", count = "", craftSize = ""}
    currentField = 1
    inputActive = true
    draw()
end

local function editItem()
    if not selectedItem then 
        addLog(logs, "ERROR: Не выбран предмет!", "ERROR")
        return
    end
    local item = dataItems[selectedItem]
    changeitem = true
    inputMode = "edit"
    inputFields = {
        name = item.name or "",
        category = item.category or "",
        count = tostring(item.count or 0),
        craftSize = tostring(item.craftSize or 1)
    }
    currentField = 1
    inputActive = true
    draw()
end

local function saveItem()
    if inputMode == "add" then
        local stack = nil
        local ok, res = pcall(me.getStackInSlot, 1)
        if ok then stack = res end
        if stack then
            local name = inputFields.name
            local category = inputFields.category
            table.insert(dataItems, {
                name = name ~= "" and name or stack.label or stack.id,
                category = category ~= "" and category or "Без категории",
                id = stack.id,
                dmg = stack.dmg,
                count = tonumber(inputFields.count) or 0,
                craftSize = tonumber(inputFields.craftSize) or 1
            })
            save()
            addLog(logs, "INFO: Добавлен предмет: " .. (name ~= "" and name or stack.label or stack.id) .. " (Категория: " .. (category ~= "" and category or "Без категории") .. ")", "INFO")
            currentPage = getMaxPages()
            selectedItem = nil
        else
            addLog(logs, "ERROR: Нет предмета в слоте 1!", "ERROR")
        end
    elseif inputMode == "edit" then
        local item = dataItems[selectedItem]
        if inputFields.name and inputFields.name ~= "" then item.name = inputFields.name end
        if inputFields.category and inputFields.category ~= "" then item.category = inputFields.category end
        if inputFields.count and inputFields.count ~= "" then item.count = tonumber(inputFields.count) or item.count end
        if inputFields.craftSize and inputFields.craftSize ~= "" then item.craftSize = tonumber(inputFields.craftSize) or item.craftSize end
        save()
        addLog(logs, "INFO: Изменено: " .. item.name .. " (Категория: " .. (item.category or "Без категории") .. ")", "INFO")
    end
    changeitem = false
    inputMode = nil
    inputFields = {}
    currentField = 1
    inputActive = false
    draw()
end

local function cancelInput()
    changeitem = false
    inputMode = nil
    inputFields = {}
    currentField = 1
    inputActive = false
    draw()
end

local function removeItem()
    if not selectedItem then 
        addLog(logs, "ERROR: Не выбран предмет!", "ERROR")
        return
    end
    addLog(logs, "WARN: Удалён: " .. (dataItems[selectedItem].name or "<??>"), "WARN")
    table.remove(dataItems, selectedItem)
    selectedItem = nil
    clampPage()
    save()
    draw()
end

local function doCraft()
    isCrafting = true
    craftStatus = "Автокрафт..."
    save()
    addLog(logs, "INFO: Запущен автокрафт", "INFO")
    draw()
end

local function stopCraft()
    isCrafting = false
    craftStatus = "Остановлено"
    addLog(logs, "WARN: Остановлен автокрафт", "WARN")
    draw()
end

local function craftAll()
    isCrafting = true
    craftStatus = "Крафт всех..."
    addLog(logs, "INFO: Запущен крафт всех предметов", "INFO")
    local craftMade = false
    for i, item in ipairs(dataItems) do
        if tryCraftItem(item) then craftMade = true end
    end
    if not craftMade then
        craftStatus = "Все предметы в норме"
        addLog(logs, "INFO: Нет предметов для крафта", "INFO")
    end
    draw()
end

local function tryCraftItem(itemToCraft)
    local count = tonumber(itemToCraft.count) or 0
    local current = tonumber(itemToCraft.current) or 0
    if current >= count then return false end
    if lastRequestedItem and lastRequestedItem.id == itemToCraft.id and (itemToCraft.dmg == nil or lastRequestedItem.dmg == itemToCraft.dmg) then
        addLog(logs, "INFO: Предмет '" .. (itemToCraft.name or "<??>") .. "' недавно запрошен. Ожидание.", "INFO")
        craftStatus = "Ожидание: " .. (itemToCraft.name or "<??>")
        return false
    end
    local cpus_ok, cpus = pcall(me.getCpus)
    if not cpus_ok then
        addLog(logs, "ERROR: Ошибка получения CPU: " .. tostring(cpus), "ERROR")
        craftStatus = "Ошибка: ME CPU"
        return false
    end
    cpus = cpus or {}
    local freeCpu = nil
    for _, cpu in ipairs(cpus) do
        if not cpu.busy then freeCpu = cpu.name break end
    end
    if freeCpu then
        local craftables_ok, craftables = pcall(me.getCraftables, {name = itemToCraft.id, damage = itemToCraft.dmg})
        if not craftables_ok then
            addLog(logs, "ERROR: Ошибка получения рецептов: " .. tostring(craftables), "ERROR")
            craftStatus = "Ошибка: ME Рецепты"
            return false
        end
        craftables = craftables or {n = 0}
        if craftables.n and craftables.n >= 1 then
            local actualAE2RecipeOutput = (craftables[1].output and craftables[1].output.size) or 1
            if actualAE2RecipeOutput == 0 then actualAE2RecipeOutput = 1 end
            local quantityToRequest = tonumber(itemToCraft.craftSize) or 1
            if quantityToRequest == 0 then quantityToRequest = 1 end
            local estimatedActualOutputFromAE2 = math.ceil(quantityToRequest / actualAE2RecipeOutput) * actualAE2RecipeOutput
            if current + estimatedActualOutputFromAE2 >= count then
                addLog(logs, "INFO: Предмет '" .. (itemToCraft.name or "<??>") .. "' достигнет цели (" .. estimatedActualOutputFromAE2 .. "x).", "INFO")
                craftStatus = "Достаточно: " .. (itemToCraft.name or "<??>")
                return false
            end
            if quantityToRequest > 0 then
                local succ, req = pcall(function() return craftables[1].request(quantityToRequest, false, freeCpu) end)
                if succ and req then
                    local actualCommittedAmount = req.size or req.qty or quantityToRequest
                    craftStatus = "Крафт: " .. (itemToCraft.name or "<??>")
                    addLog(logs, "INFO: Запрос крафта " .. quantityToRequest .. "x " .. (itemToCraft.name or "<??>") .. " на CPU " .. tostring(freeCpu), "INFO")
                    lastRequestedItem = {id = itemToCraft.id, dmg = itemToCraft.dmg, expectedOutput = actualCommittedAmount}
                    lastRequestTime = computer.uptime()
                    return true
                else
                    craftStatus = "Ошибка: крафт отклонен"
                    addLog(logs, "ERROR: Не удалось крафтить " .. (itemToCraft.name or "<??>") .. ": " .. tostring(req), "ERROR")
                    return false
                end
            else return false end
        else
            craftStatus = "Ошибка: нет рецепта " .. (itemToCraft.name or "<??>")
            addLog(logs, "ERROR: Нет рецепта для " .. (itemToCraft.name or "<??>"), "ERROR")
            return false
        end
    else
        craftStatus = "Ошибка: нет свободных CPU"
        addLog(logs, "ERROR: Нет свободных CPU", "ERROR")
        return false
    end
end

local function autoCraftLoop()
    while true do
        if isCrafting then
            local now = computer.uptime()
            if now >= nextCraftUpdate then
                local ok, err = pcall(reload)
                if not ok then
                    addLog(logs, "ERROR: Ошибка в reload: " .. tostring(err), "ERROR")
                    craftStatus = "Ошибка: обновление данных"
                else
                    local craftMadeThisCycle = false
                    for i, item in ipairs(dataItems) do
                        if not craftMadeThisCycle then
                            if tryCraftItem(item) then craftMadeThisCycle = true break end
                        end
                    end
                    save()
                    nextCraftUpdate = now + 30
                end
            end
        end
        draw()
        os.sleep(0.5)
    end
end

-------------------- События --------------------
local function updateButtonHover(x, y)
    local btnWidth = 12
    local btnHeight = 3
    local btnX = WIDTH - btnWidth - 5
    local btnPadding = 2
    local btns = {
        {name = "Крафт всех", action = "craftAll"},
        {name = "Удалить", action = "delete"},
        {name = "Изменить", action = "edit"},
        {name = isCrafting and "Остановить" or "Автокрафт", action = "toggleCraft"},
        {name = "Добавить", action = "add"},
    }
    for i, btn in ipairs(btns) do
        local btnY = 10 + (i - 1) * (btnHeight + btnPadding)
        if x >= btnX and x <= btnX + btnWidth - 1 and y >= btnY and y <= btnY + btnHeight - 1 then return btn.action end
    end
    local arrowBtnW = 4
    local arrowBtnH = 3
    local arrowBtnY = 10 + (#btns * (btnHeight + btnPadding))
    local prevArrowBtnX = btnX
    local nextArrowBtnX = btnX + arrowBtnW + 1
    local sortBtnY = arrowBtnY + arrowBtnH + 2
    local sortBtnW = 12
    if x >= prevArrowBtnX and x <= prevArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        return "prevPage"
    elseif x >= nextArrowBtnX and x <= nextArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        return "nextPage"
    elseif x >= btnX and x <= btnX + sortBtnW - 1 and y >= sortBtnY and y <= sortBtnY + arrowBtnH - 1 then
        return "sort"
    end
    return nil
end

local function handleKeyEvent(e)
    local eventType, _, code, char = e[1], e[2], e[3], e[4] -- Исправлена ошибка: извлечение code и char из e
    if changeitem then
        local fields = {
            {key = "name"}, {key = "category"}, {key = "count"}, {key = "craftSize"}
        }
        if code == 28 then -- Enter key
            currentField = currentField + 1
            if currentField > #fields then -- All fields filled or skipped
                saveItem()
            else
                draw() -- Redraw to show next active field
            end
        elseif code == 1 or code == 29 then -- Escape key
            cancelInput()
        elseif code == 42 then -- Backspace
            local currentFieldKey = fields[currentField].key
            inputFields[currentFieldKey] = unicode.sub(inputFields[currentFieldKey], 1, unicode.len(inputFields[currentFieldKey]) - 1)
            draw()
        elseif char and unicode.len(char) == 1 then
            local currentFieldKey = fields[currentField].key
            inputFields[currentFieldKey] = (inputFields[currentFieldKey] or "") .. char
            draw()
        end
    else -- Main menu
        if code == 28 then -- Enter key for main menu (for selected item action)
            if selectedItem then
                local item = dataItems[selectedItem]
                if tryCraftItem(item) then
                    addLog(logs, "INFO: Запрошен крафт " .. (item.name or "<??>"), "INFO")
                else
                    addLog(logs, "ERROR: Не удалось начать крафт " .. (item.name or "<??>"), "ERROR")
                end
            end
        elseif code == 200 then -- Up arrow
            local filtered = getFilteredAndSortedItems()
            local perPage = getItemsPerPage()
            local startIndex = (currentPage - 1) * perPage
            local currentFilteredIndex = 0
            if selectedItem then
                for i, item in ipairs(filtered) do
                    if item == dataItems[selectedItem] then
                        currentFilteredIndex = i
                        break
                    end
                end
            end

            if currentFilteredIndex > 1 then
                selectedItem = nil
                for k, v in ipairs(dataItems) do
                    if v == filtered[currentFilteredIndex - 1] then 
                        selectedItem = k 
                        break 
                    end
                end
            elseif currentPage > 1 then
                currentPage = currentPage - 1
                selectedItem = nil
                local visibleItems = getFilteredAndSortedItems()
                selectedItem = nil
                for k, v in ipairs(dataItems) do
                    if v == visibleItems[math.min(perPage, #visibleItems)] then 
                        selectedItem = k 
                        break 
                    end
                end
            end
        elseif code == 208 then -- Down arrow
            local filtered = getFilteredAndSortedItems()
            local perPage = getItemsPerPage()
            local startIndex = (currentPage - 1) * perPage
            local currentFilteredIndex = 0
            if selectedItem then
                for i, item in ipairs(filtered) do
                    if item == dataItems[selectedItem] then
                        currentFilteredIndex = i
                        break
                    end
                end
            end

            if currentFilteredIndex > 0 and currentFilteredIndex < #filtered then
                selectedItem = nil
                for k, v in ipairs(dataItems) do
                    if v == filtered[currentFilteredIndex + 1] then 
                        selectedItem = k 
                        break 
                    end
                end
            elseif currentPage < getMaxPages() then
                currentPage = currentPage + 1
                selectedItem = nil
                local visibleItems = getFilteredAndSortedItems()
                selectedItem = nil
                for k, v in ipairs(dataItems) do
                    if v == visibleItems[1] then 
                        selectedItem = k 
                        break 
                    end
                end
            end
        elseif code == 203 then -- Left arrow
            if currentPage > 1 then
                currentPage = currentPage - 1
                selectedItem = nil
            end
        elseif code == 205 then -- Right arrow
            if currentPage < getMaxPages() then
                currentPage = currentPage + 1
                selectedItem = nil
            end
        elseif code == 42 then -- Backspace for search
            if searchActive then
                search = unicode.sub(search, 1, unicode.len(search) - 1)
                resetSelection()
            end
        elseif char and unicode.len(char) == 1 then
            if searchActive then
                search = search .. char
                resetSelection()
            end
        end
    end
    draw()
end

-- Main event loop
local function mainLoop()
    while true do
        local e = {event.pull(0.05)} -- Pull event with a small timeout
        if e[1] == "key" then
            handleKeyEvent(e)
        elseif e[1] == "mouse_click" then
            local _, _, x, y, button = e
            if changeitem then -- In input mode, handle clicks on fields
                local baseY = HEIGHT - 15
                local fields = {
                    {x = 2, y = baseY + 3, w = 40, h = 3, key = "name"},
                    {x = 2, y = baseY + 5, w = 40, h = 3, key = "category"},
                    {x = 2, y = baseY + 7, w = 20, h = 3, key = "count"},
                    {x = 2, y = baseY + 9, w = 20, h = 3, key = "craftSize"},
                }
                local fieldClicked = false
                for i, field in ipairs(fields) do
                    if x >= field.x and x < field.x + field.w and y >= field.y and y < field.y + field.h then
                        currentField = i
                        inputActive = true
                        fieldClicked = true
                        break
                    end
                end
                if not fieldClicked then
                    inputActive = false -- Deactivate input if clicked outside fields
                end
                draw()
            else -- In main menu
                local btnWidth = 12
                local btnHeight = 3
                local btnX = WIDTH - btnWidth - 5
                local btnPadding = 2
                local btns = {
                    {name = "Крафт всех", action = "craftAll"},
                    {name = "Удалить", action = "delete"},
                    {name = "Изменить", action = "edit"},
                    {name = isCrafting and "Остановить" or "Автокрафт", action = "toggleCraft"},
                    {name = "Добавить", action = "add"},
                }

                local handledButton = false
                for i, btn in ipairs(btns) do
                    local btnY = 10 + (i - 1) * (btnHeight + btnPadding)
                    if x >= btnX and x <= btnX + btnWidth - 1 and y >= btnY and y <= btnY + btnHeight - 1 then
                        if btn.action == "add" then
                            addItem()
                        elseif btn.action == "edit" then
                            editItem()
                        elseif btn.action == "delete" then
                            removeItem()
                        elseif btn.action == "toggleCraft" then
                            if isCrafting then stopCraft() else doCraft() end
                        elseif btn.action == "craftAll" then
                            craftAll()
                        end
                        handledButton = true
                        break
                    end
                end

                -- Handle arrow buttons
                if not handledButton then
                    local arrowBtnW = 4
                    local arrowBtnH = 3
                    local arrowBtnY = 10 + (#btns * (btnHeight + btnPadding))
                    local prevArrowBtnX = btnX
                    local nextArrowBtnX = btnX + arrowBtnW + 1

                    if x >= prevArrowBtnX and x <= prevArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
                        if currentPage > 1 then
                            currentPage = currentPage - 1
                            selectedItem = nil
                        end
                        handledButton = true
                    elseif x >= nextArrowBtnX and x <= nextArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
                        if currentPage < getMaxPages() then
                            currentPage = currentPage + 1
                            selectedItem = nil
                        end
                        handledButton = true
                    end
                end

                -- Handle sort button
                if not handledButton then
                    local sortBtnY = arrowBtnY + arrowBtnH + 2
                    local sortBtnW = 12
                    if x >= btnX and x <= btnX + sortBtnW - 1 and y >= sortBtnY and y <= sortBtnY + arrowBtnH - 1 then
                        local sortOptions = {"name", "current", "count", "craftSize", "category"}
                        local currentSortIndex = 1
                        for i, opt in ipairs(sortOptions) do
                            if opt == settings.sortCriteria then
                                currentSortIndex = i
                                break
                            end
                        end
                        local nextSortIndex = currentSortIndex + 1
                        if nextSortIndex > #sortOptions then
                            nextSortIndex = 1
                            settings.sortAscending = not settings.sortAscending
                        end
                        settings.sortCriteria = sortOptions[nextSortIndex]
                        save()
                        handledButton = true
                    end
                end

                -- Handle search bar click
                local searchX, searchY = 2, HEIGHT - 10
                local searchW, searchH = WIDTH - 20, 3
                if x >= searchX and x < searchX + searchW and y >= searchY and y < searchY + searchH then
                    searchActive = true
                else
                    searchActive = false
                end

                -- Handle table row click for selection
                local tableX, tableY = 1, 8
                local perPage = getItemsPerPage()
                local totalWidth = WIDTH - 25
                local startIndex = (currentPage - 1) * perPage + 1
                if x >= tableX and x < tableX + totalWidth + 2 and y >= tableY + 3 and y < tableY + 3 + perPage then
                    local rowClicked = y - (tableY + 3) + 1
                    local itemIndex = startIndex + rowClicked - 1
                    local filteredAndSortedItems = getFilteredAndSortedItems()
                    if itemIndex >= startIndex and itemIndex <= math.min(#filteredAndSortedItems, startIndex + perPage - 1) then
                        local clickedItem = filteredAndSortedItems[itemIndex]
                        for i, item in ipairs(dataItems) do
                            if item == clickedItem then
                                selectedItem = i
                                break
                            end
                        end
                    end
                end
                draw()
            end
        elseif e[1] == "mouse_scroll" then
            local _, _, _, _, delta = e
            if not changeitem then
                if delta > 0 then -- Scroll up
                    if searchActive then
                        logOffset = math.max(logOffset - 1, 0)
                    else
                        if currentPage > 1 then
                            currentPage = currentPage - 1
                            selectedItem = nil
                        end
                    end
                elseif delta < 0 then -- Scroll down
                    if searchActive then
                        logOffset = math.min(logOffset + 1, #logs - 5)
                    else
                        if currentPage < getMaxPages() then
                            currentPage = currentPage + 1
                            selectedItem = nil
                        end
                    end
                end
                draw()
            end
        elseif e[1] == "mouse_move" then
            if not changeitem then
                local _, _, x, y = e
                buttonHover = updateButtonHover(x, y)
                draw()
            end
        end
    end
end

-------------------- Старт --------------------
checkComponents()
bindGpu()
WIDTH, HEIGHT = g.maxResolution()
g.setResolution(WIDTH, HEIGHT)
addLog(logs, "INFO: Программа запущена", "INFO")
local ok, err = pcall(reload)
if not ok then
    addLog(logs, "ERROR: Ошибка при начальной загрузке: " .. tostring(err), "ERROR")
    draw()
    while true do os.sleep(1) end
end
draw()
local ok, err = pcall(function()
    parallel.run(autoCraftLoop, mainLoop)
end)
if not ok then
    addLog(logs, "ERROR: Фатальная ошибка в главной петле: " .. tostring(err), "ERROR")
    draw()
    os.sleep(5)
end
