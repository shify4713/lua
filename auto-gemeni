-- /home/auto-gemeni.txt
local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode")
local term = require("term")
local computer = require("computer")
local g = component.gpu
local me = component.me_interface

--[[ КОНСТАНТЫ И НАСТРОЙКИ ]]--
local DATA_FILE = "/home/BD.txt"
local LIB_PATH = "/lib/ultimateOC.lua"
-- URL для скачивания библиотеки, если ее нет (не используется в текущей версии, но полезно для установки)
-- local LIB_URL = "https://raw.githubusercontent.com/shify4713/lua/refs/heads/main/lib-gemeni"

local ITEMS_PER_PAGE = 5 -- Количество элементов на странице
local LOG_LINES = 5    -- Количество строк для логов
local LOG_MAX_HISTORY = 100 -- Максимальное количество записей в истории логов

-- Цвета UI
local COLOR_BG = 0x000000         -- Черный фон
local COLOR_BTN_NORMAL = 0x6A0DAD -- Пурпурный
local COLOR_BTN_HOVER = 0x9932CC  -- Более светлый пурпурный
local COLOR_TEXT_NORMAL = 0xFFFFFF -- Белый текст
local COLOR_INPUT_BG = 0x333333   -- Темно-серый фон поля ввода
local COLOR_INPUT_BORDER = 0xAAAAAA -- Светло-серый бордер поля ввода
local COLOR_SELECTED_ITEM = 0x00BFFF -- Ярко-голубой для выбранного элемента
local COLOR_HEADER = 0x8BE9FD     -- Светло-голубой для заголовков
local COLOR_LOG = 0x8BE9FD        -- Цвет текста логов
local COLOR_STATUS_OK = 0x00FF00  -- Зеленый для "OK" статуса
local COLOR_STATUS_WARN = 0xFFFF00 -- Желтый для "WARN" статуса
local COLOR_STATUS_ERROR = 0xFF0000 -- Красный для "ERROR" статуса

--[[ ИНИЦИАЛИЗАЦИЯ ]]--
local uoc = {}
local ultimateOC_success, ultimateOC_err = pcall(function()
    uoc = dofile(LIB_PATH)
end)

if not ultimateOC_success then
    io.stderr:write("Ошибка при загрузке ultimateOC.lua: " .. tostring(ultimateOC_err) .. "\\n")
    os.exit(1)
end

-- Переменные состояния UI
local logs = {}
local dataItems = {}
local selectedItem = nil -- Индекс выбранного элемента в dataItems
local WIDTH, HEIGHT
local currentPage = 1
local searchActive = false
local searchTerm = ""
local searchInputBuffer = ""
local buttonHover = nil
local logOffset = 0
local me_interface_available = false
local redrawNeeded = true -- Флаг для контроля перерисовки

--[[ ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ]]--

-- Функция для добавления логов
local function addLog(message, logType)
    logType = logType or "INFO"
    local timestamp = os.date("%H:%M:%S")
    local formattedMessage = string.format("[%s][%s] %s", logType, timestamp, message)
    table.insert(logs, formattedMessage)
    term.write(formattedMessage .. "\n") -- Вывод в терминал для немедленной обратной связи
    
    -- Ограничиваем размер истории логов
    if #logs > LOG_MAX_HISTORY then
        table.remove(logs, 1)
    end
    -- Автоматически прокручиваем логи вниз при добавлении нового сообщения
    if #logs > LOG_LINES then
        logOffset = #logs - LOG_LINES
    else
        logOffset = 0
    end
    redrawNeeded = true
end

-- Проверка доступности компонентов
local function checkComponents()
    if not component.isAvailable("gpu") then
        addLog("Ошибка: GPU недоступен", "CRITICAL")
        os.exit(1)
    end
    if not component.isAvailable("screen") then
        addLog("Ошибка: Экран недоступен", "CRITICAL")
        os.exit(1)
    end
    if not component.isAvailable("me_interface") then
        me_interface_available = false
        addLog("Внимание: ME-интерфейс недоступен. Функционал крафта будет ограничен.", "WARN")
    else
        me_interface_available = true
        addLog("ME-интерфейс доступен", "INFO")
    end
end

-- Привязка GPU к экрану
local function bindGpu()
    local screen = component.list("screen")()
    if not screen then
        addLog("Ошибка: Не найден экран для привязки GPU", "CRITICAL")
        os.exit(1)
    end
    local success, err = pcall(g.bind, screen)
    if not success then
        addLog("Ошибка: Не удалось привязать GPU к экрану: " .. tostring(err), "CRITICAL")
        os.exit(1)
    end
    addLog("GPU успешно привязан к экрану", "INFO")
end

-- Функция для получения информации о предмете из ME-интерфейса
local function getItemInfo(name)
    if not me_interface_available then return nil end
    local items = me.getItemsInNetwork()
    for _, item in ipairs(items) do
        if item.name == name then
            return item
        end
    end
    return nil
end

-- Функция для очистки экрана
local function clearScreen()
    g.setBackground(COLOR_BG)
    g.fill(1, 1, WIDTH, HEIGHT, " ")
end

-- Функция для сохранения данных
local function savef()
    local success, err = uoc.savef(DATA_FILE, dataItems)
    if success then
        addLog("Данные сохранены", "INFO")
    else
        addLog("Ошибка сохранения данных: " .. tostring(err), "ERROR")
    end
end

-- Функция для загрузки данных
local function loadf()
    local loadedData, err = uoc.loadf(DATA_FILE)
    if loadedData then
        dataItems = loadedData
        addLog("Данные загружены", "INFO")
    elseif err then
        if err == "Файл пуст" then
            dataItems = {}
            addLog("Файл данных пуст, созданы новые данные", "WARN")
        else
            dataItems = {}
            addLog("Ошибка загрузки данных: " .. tostring(err) .. ". Созданы новые данные.", "ERROR")
        end
    else
        dataItems = {}
        addLog("Файл данных не найден, созданы новые данные", "INFO")
    end
end

-- Функция для удаления элемента
local function deleteItem(index)
    if index and dataItems[index] then
        local itemName = dataItems[index].name
        table.remove(dataItems, index)
        selectedItem = nil
        savef()
        addLog("Элемент удален: " .. itemName, "INFO")
        -- Корректируем текущую страницу, если удален последний элемент на странице
        local maxPages = math.max(1, math.ceil(#dataItems / ITEMS_PER_PAGE))
        if currentPage > maxPages then
            currentPage = maxPages
        end
        redrawNeeded = true
    end
end

-- Функция для редактирования элемента
local function editItem(index, newName, newCount)
    if index and dataItems[index] then
        dataItems[index].name = newName
        dataItems[index].count = newCount
        savef()
        addLog("Элемент отредактирован: " .. newName .. ", " .. newCount, "INFO")
        redrawNeeded = true
    end
end

-- Функция для добавления нового элемента
local function addItem(name, count)
    local item = { name = name, count = count }
    table.insert(dataItems, item)
    savef()
    addLog("Элемент добавлен: " .. name .. ", " .. count, "INFO")
    redrawNeeded = true
end

-- Функция для проверки и автокрафта
local function autoCraft(itemToCraft)
    if not me_interface_available then
        addLog("Невозможно выполнить автокрафт: ME-интерфейс недоступен.", "WARN")
        return
    end

    addLog("Начат автокрафт для: " .. itemToCraft.name .. " (x" .. itemToCraft.count .. ")", "INFO")
    local success, err = pcall(function()
        local itemInfo = getItemInfo(itemToCraft.name)
        if not itemInfo then
            addLog("Предмет " .. itemToCraft.name .. " не найден в ME-сети. Проверьте ME-интерфейс или название.", "ERROR")
            return
        end

        local currentCount = itemInfo.size or 0
        local neededCount = itemToCraft.count

        if currentCount < neededCount then
            local craftAmount = neededCount - currentCount
            addLog("Требуется скрафтить " .. craftAmount .. " " .. itemToCraft.name, "INFO")
            local result, reason = me.craft(itemInfo, craftAmount)
            if result then
                addLog("Успешно запущен крафт " .. craftAmount .. " " .. itemToCraft.name, "SUCCESS")
            else
                addLog("Не удалось запустить крафт " .. itemToCraft.name .. ": " .. tostring(reason), "ERROR")
            end
        else
            addLog(itemToCraft.name .. " (x" .. currentCount .. ") уже достаточно в системе.", "INFO")
        end
    end)
    if not success then
        addLog("Ошибка автокрафта для " .. itemToCraft.name .. ": " .. tostring(err), "ERROR")
    end
    redrawNeeded = true
end

-- Функция для обновления данных об элементах (получения текущего количества)
local function updateItemCounts()
    if not me_interface_available then
        addLog("Невозможно обновить количество предметов: ME-интерфейс недоступен.", "WARN")
        for i, item in ipairs(dataItems) do
            dataItems[i].currentCount = nil -- Или 0, в зависимости от желаемого отображения
        end
        redrawNeeded = true
        return
    end

    addLog("Обновление количества предметов...", "INFO")
    local current_me_items = {}
    local success, items = pcall(me.getItemsInNetwork)
    if success and items then
        for _, item_info in ipairs(items) do
            current_me_items[item_info.name] = item_info.size
        end
    else
        addLog("Не удалось получить список предметов из ME-сети: " .. tostring(items), "ERROR")
    end

    for i, item in ipairs(dataItems) do
        dataItems[i].currentCount = current_me_items[item.name] or 0
    end
    addLog("Количество предметов обновлено.", "INFO")
    redrawNeeded = true
end

-- Перезагрузка данных (для кнопки "Перезагрузить данные")
local function reload()
    loadf()
    updateItemCounts()
    addLog("Данные перезагружены и обновлены.", "INFO")
    redrawNeeded = true
end

-- Основной цикл автокрафта
local function autoCraftLoop()
    addLog("Запуск цикла автокрафта...", "INFO")
    while true do
        updateItemCounts()
        for _, item in ipairs(dataItems) do
            if item.currentCount and item.currentCount < item.count then
                autoCraft(item)
                os.sleep(0.5) -- Небольшая пауза между отдельными крафтами
            end
        end
        if redrawNeeded then
            draw() -- Обновить UI после цикла крафта, если были изменения
        end
        os.sleep(10) -- Проверять каждые 10 секунд (можно настроить)
    end
end


--[[ Отрисовка UI ]]--
local function draw()
    if not redrawNeeded then return end -- Избегаем лишних перерисовок
    clearScreen()

    -- Заголовок
    uoc.drawText(math.floor(WIDTH / 2 - unicode.len("Ultimate AE2 Auto-Crafter") / 2), 1, "Ultimate AE2 Auto-Crafter", COLOR_HEADER, true)
    uoc.drawText(math.floor(WIDTH / 2 - unicode.len("by SHIFY") / 2), 2, "by SHIFY", COLOR_HEADER)

    -- Индикатор состояния ME-интерфейса
    local meStatusText = me_interface_available and "ME OK" or "ME ERROR"
    local meStatusColor = me_interface_available and COLOR_STATUS_OK or COLOR_STATUS_ERROR
    uoc.drawText(WIDTH - unicode.len(meStatusText) - 1, 1, meStatusText, meStatusColor)


    -- Область кнопок (справа)
    local buttonX = WIDTH - 20
    local buttonWidth = 18
    local buttonHeight = 3
    local startY = 4

    local buttons_def = { -- Определение кнопок для отрисовки и обработки
        {text = "Добавить (F1)", action = "add"},
        {text = "Удалить (F2)", action = "delete"},
        {text = "Изменить (F3)", action = "edit"},
        {text = "Крафт (F4)", action = "craft"},
        {text = "Перезагрузить", action = "reload"},
        {text = "Выход", action = "exit"}
    }

    local currentButtonY = startY
    for i, btn in ipairs(buttons_def) do
        local isHovered = buttonHover == i
        uoc.animatedButton(buttonX, currentButtonY, buttonWidth, buttonHeight, btn.text, isHovered, COLOR_BTN_NORMAL, COLOR_BTN_HOVER, COLOR_TEXT_NORMAL)
        currentButtonY = currentButtonY + buttonHeight + 1
    end

    -- Область поиска (слева, ниже заголовка)
    local searchX = 1
    local searchY = 4
    local searchWidth = WIDTH - buttonWidth - 2 -- Оставить место для кнопок и отступов
    local searchHeight = 3

    -- Поле поиска
    g.setForeground(COLOR_INPUT_BORDER)
    g.setBackground(COLOR_INPUT_BG)
    g.fill(searchX, searchY, searchWidth, searchHeight, " ")
    uoc.drawText(searchX + 1, searchY + 1, "Поиск: " .. (searchActive and (searchInputBuffer .. "_") or searchTerm), COLOR_TEXT_NORMAL)

    -- Область списка элементов
    local listX = searchX
    local listY = searchY + searchHeight + 1
    local listWidth = searchWidth
    local listHeight = HEIGHT - listY - LOG_LINES - 2 -- Оставить место для пагинации и логов

    -- Заголовки таблицы
    local headerY = listY
    g.setBackground(COLOR_BG)
    g.setForeground(COLOR_HEADER)
    uoc.drawText(listX + 1, headerY, "Имя предмета", COLOR_HEADER, true)
    uoc.drawText(listX + math.floor(listWidth * 0.5), headerY, "Требуется", COLOR_HEADER, true)
    uoc.drawText(listX + math.floor(listWidth * 0.75), headerY, "В наличии", COLOR_HEADER, true)

    local itemDisplayY = headerY + 1
    local filteredItems = {}
    if searchTerm ~= "" then
        for _, item in ipairs(dataItems) do
            if unicode.lower(item.name):find(unicode.lower(searchTerm)) then
                table.insert(filteredItems, item)
            end
        end
    else
        filteredItems = dataItems
    end

    local maxPages = math.max(1, math.ceil(#filteredItems / ITEMS_PER_PAGE))
    local startIndex = (currentPage - 1) * ITEMS_PER_PAGE + 1
    local endIndex = math.min(startIndex + ITEMS_PER_PAGE - 1, #filteredItems)
    local visibleItems = {}
    for i = startIndex, endIndex do
        table.insert(visibleItems, filteredItems[i])
    end

    -- Отрисовка элементов списка
    for i = 1, ITEMS_PER_PAGE do
        local displayY = itemDisplayY + i - 1
        local item = visibleItems[i]

        -- Очистить строку перед рисованием
        g.setBackground(COLOR_BG)
        g.fill(listX, displayY, listWidth, 1, " ")

        if item then
            local isSelected = false
            -- Проверяем, является ли текущий отображаемый элемент выбранным
            if selectedItem then
                -- Нужно найти выбранный элемент среди всех dataItems
                for k, v in ipairs(dataItems) do
                    if v == item and k == selectedItem then
                        isSelected = true
                        break
                    end
                end
            end

            g.setBackground(isSelected and COLOR_SELECTED_ITEM or COLOR_BG)
            g.fill(listX, displayY, listWidth, 1, " ") -- Перезаливка фона для подсветки

            g.setForeground(COLOR_TEXT_NORMAL)
            uoc.drawText(listX + 1, displayY, item.name, COLOR_TEXT_NORMAL)
            uoc.drawText(listX + math.floor(listWidth * 0.5), displayY, tostring(item.count), COLOR_TEXT_NORMAL)
            
            local currentCountText = tostring(item.currentCount or "N/A")
            local countColor = COLOR_STATUS_WARN -- По умолчанию
            if item.currentCount == nil then
                countColor = COLOR_STATUS_WARN -- "N/A"
            elseif item.currentCount < item.count then
                countColor = COLOR_STATUS_ERROR -- Красный, если количество недостаточно
            else
                countColor = COLOR_STATUS_OK -- Зеленый, если количество достаточно
            end
            uoc.drawText(listX + math.floor(listWidth * 0.75), displayY, currentCountText, countColor)
        end
    end

    -- Пагинация
    local paginationY = listY + listHeight + 1
    local pageText = string.format("Страница %d/%d", currentPage, maxPages)
    uoc.drawText(math.floor(WIDTH / 2 - unicode.len(pageText) / 2), paginationY, pageText, COLOR_TEXT_NORMAL)

    -- Область логов (снизу)
    local logY = HEIGHT - LOG_LINES + 1
    g.setBackground(0x1A1A1A) -- Темно-серый фон для логов
    g.fill(1, logY, WIDTH, LOG_LINES, " ") -- Очищаем всю область логов
    uoc.drawLogs(1, logY, logs, LOG_LINES, COLOR_LOG, logOffset)

    g.set(1, 1, "") -- Сброс позиции курсора
    redrawNeeded = false -- Сброс флага после отрисовки
end

--[[ ОБРАБОТЧИКИ СОБЫТИЙ ]]--

local function handleButtonAction(action)
    if action == "add" then
        addLog("Режим добавления элемента...", "INFO")
        searchActive = false
        draw() -- Обновить UI перед запросом ввода
        local name = term.read("Введите имя предмета: ")
        if not name or unicode.len(name) == 0 then addLog("Имя не может быть пустым. Отменено.", "WARN"); draw(); return end
        local count_str = term.read("Введите требуемое количество: ")
        local count = tonumber(count_str)
        if not count or count <= 0 then addLog("Неверное количество. Отменено.", "WARN"); draw(); return end
        addItem(name, count)
        draw()
    elseif action == "delete" then
        if selectedItem then
            deleteItem(selectedItem)
        else
            addLog("Сначала выберите элемент для удаления.", "WARN")
        end
    elseif action == "edit" then
        if selectedItem then
            addLog("Режим редактирования элемента: " .. dataItems[selectedItem].name, "INFO")
            searchActive = false
            draw() -- Обновить UI перед запросом ввода
            local currentName = dataItems[selectedItem].name
            local currentCount = dataItems[selectedItem].count

            local newName = term.read("Новое имя (" .. currentName .. ", Enter для пропуска): ")
            newName = (newName == "" or newName == nil) and currentName or newName

            local newCount_str = term.read("Новое кол-во (" .. currentCount .. ", Enter для пропуска): ")
            local newCount = tonumber(newCount_str)
            newCount = (newCount_str == "" or newCount_str == nil) and currentCount or newCount

            if newName ~= currentName or newCount ~= currentCount then
                editItem(selectedItem, newName, newCount)
            else
                addLog("Изменений нет. Отменено.", "INFO")
            end
            draw()
        else
            addLog("Сначала выберите элемент для редактирования.", "WARN")
        end
    elseif action == "craft" then
        if selectedItem then
            autoCraft(dataItems[selectedItem])
        else
            addLog("Сначала выберите элемент для крафта.", "WARN")
        end
    elseif action == "reload" then
        reload()
    elseif action == "exit" then
        addLog("Завершение программы.", "INFO")
        clearScreen()
        os.exit()
    end
    redrawNeeded = true
end


event.listen("mouse_click", function(x, y, button)
    if button == 1 then -- Левый клик
        -- Проверка кнопок
        local buttonX = WIDTH - 20
        local buttonWidth = 18
        local buttonHeight = 3
        local startY = 4

        local buttons_def = {
            {action = "add"},
            {action = "delete"},
            {action = "edit"},
            {action = "craft"},
            {action = "reload"},
            {action = "exit"}
        }

        local currentButtonY = startY
        for i, btn in ipairs(buttons_def) do
            if x >= buttonX and x < buttonX + buttonWidth and
               y >= currentButtonY and y < currentButtonY + buttonHeight then
                handleButtonAction(btn.action)
                return
            end
            currentButtonY = currentButtonY + buttonHeight + 1
        end

        -- Проверка области поиска
        local searchX = 1
        local searchY = 4
        local searchWidth = WIDTH - buttonWidth - 2
        local searchHeight = 3
        if x >= searchX and x < searchX + searchWidth and
           y >= searchY and y < searchY + searchHeight then
            searchActive = true
            searchInputBuffer = searchTerm -- Начать буферизацию с текущего поискового запроса
            addLog("Поле поиска активировано. Введите текст (Enter для подтверждения): ", "INFO")
            redrawNeeded = true
        else
            if searchActive then -- Деактивировать поиск, только если он был активен и клик был вне поля
                searchActive = false
                searchTerm = searchInputBuffer
                addLog("Поиск: '" .. searchTerm .. "'", "INFO")
                currentPage = 1 -- Сбросить страницу при поиске
                selectedItem = nil -- Снять выделение при поиске
                redrawNeeded = true
            end
        end

        -- Проверка области списка для выбора элемента
        local listX = searchX
        local listY = searchY + searchHeight + 1
        local itemDisplayY = listY + 1 -- Учитываем заголовок
        local listHeightForItems = ITEMS_PER_PAGE -- Высота области для отображения ITEMS_PER_PAGE элементов

        if x >= listX and x < listX + listWidth and
           y >= itemDisplayY and y < itemDisplayY + listHeightForItems then
            local clickedRelativeY = y - itemDisplayY
            local clickedVisibleIndex = clickedRelativeY + 1
            
            local filteredItems = {}
            if searchTerm ~= "" then
                for _, item in ipairs(dataItems) do
                    if unicode.lower(item.name):find(unicode.lower(searchTerm)) then
                        table.insert(filteredItems, item)
                    end
                end
            else
                filteredItems = dataItems
            end

            local startIndex = (currentPage - 1) * ITEMS_PER_PAGE + 1
            local itemIndexInFiltered = startIndex + clickedVisibleIndex - 1

            if itemIndexInFiltered >= 1 and itemIndexInFiltered <= #filteredItems then
                local clickedItem = filteredItems[itemIndexInFiltered]
                -- Найти оригинальный индекс кликнутого элемента в dataItems
                for k, v in ipairs(dataItems) do
                    if v == clickedItem then
                        selectedItem = k
                        addLog("Выбран элемент: " .. v.name, "INFO")
                        break
                    end
                end
                redrawNeeded = true
            end
        end
    end
end)

event.listen("mouse_move", function(x, y)
    local buttonX = WIDTH - 20
    local buttonWidth = 18
    local buttonHeight = 3
    local startY = 4
    local currentButtonY = startY
    local newButtonHover = nil
    
    local buttons_def = { -- Определение кнопок для проверки наведения
        {}, {}, {}, {}, {}, {} -- Просто заглушки для индексации
    }

    for i = 1, #buttons_def do
        if x >= buttonX and x < buttonX + buttonWidth and
           y >= currentButtonY and y < currentButtonY + buttonHeight then
            newButtonHover = i
            break
        end
        currentButtonY = currentButtonY + buttonHeight + 1
    end
    if newButtonHover ~= buttonHover then
        buttonHover = newButtonHover
        redrawNeeded = true
    end
end)

event.listen("key_down", function(_, _, key, char)
    if searchActive then
        if key == 28 then -- Enter
            searchActive = false
            searchTerm = searchInputBuffer
            addLog("Поиск: '" .. searchTerm .. "'", "INFO")
            currentPage = 1 -- Сбросить страницу при поиске
            selectedItem = nil -- Снять выделение при поиске
        elseif key == 14 then -- Backspace
            searchInputBuffer = unicode.sub(searchInputBuffer, 1, unicode.len(searchInputBuffer) - 1)
        elseif char and unicode.len(char) == 1 then -- Любой одиночный символ
            searchInputBuffer = searchInputBuffer .. char
        end
    else
        -- Навигация по списку
        local filteredItems = {}
        if searchTerm ~= "" then
            for _, item in ipairs(dataItems) do
                if unicode.lower(item.name):find(unicode.lower(searchTerm)) then
                    table.insert(filteredItems, item)
                end
            end
        else
            filteredItems = dataItems
        end
        local numFiltered = #filteredItems

        if key == 200 then -- Стрелка вверх
            if numFiltered > 0 then
                if selectedItem then
                    local currentFilteredIndex = 0
                    -- Находим индекс выбранного элемента в отфильтрованном списке
                    for i, item in ipairs(filteredItems) do
                        if dataItems[selectedItem] == item then
                            currentFilteredIndex = i
                            break
                        end
                    end

                    if currentFilteredIndex > 1 then
                        selectedItem = nil
                        for k,v in ipairs(dataItems) do
                            if v == filteredItems[currentFilteredIndex - 1] then
                                selectedItem = k
                                break
                            end
                        end
                    else -- Если это первый элемент в отфильтрованном списке, перейти к последнему
                        selectedItem = nil
                        for k,v in ipairs(dataItems) do
                            if v == filteredItems[numFiltered] then
                                selectedItem = k
                                break
                            end
                        end
                    end
                else -- Если ничего не выбрано, выбрать последний элемент
                    selectedItem = nil
                    for k,v in ipairs(dataItems) do
                        if v == filteredItems[numFiltered] then
                            selectedItem = k
                            break
                        end
                    end
                end
            end
        elseif key == 208 then -- Стрелка вниз
            if numFiltered > 0 then
                if selectedItem then
                    local currentFilteredIndex = 0
                    for i, item in ipairs(filteredItems) do
                        if dataItems[selectedItem] == item then
                            currentFilteredIndex = i
                            break
                        end
                    end

                    if currentFilteredIndex < numFiltered then
                        selectedItem = nil
                        for k,v in ipairs(dataItems) do
                            if v == filteredItems[currentFilteredIndex + 1] then
                                selectedItem = k
                                break
                            end
                        end
                    else -- Если это последний элемент в отфильтрованном списке, перейти к первому
                        selectedItem = nil
                        for k,v in ipairs(dataItems) do
                            if v == filteredItems[1] then
                                selectedItem = k
                                break
                            end
                        end
                    end
                else -- Если ничего не выбрано, выбрать первый элемент
                    selectedItem = nil
                    for k,v in ipairs(dataItems) do
                        if v == filteredItems[1] then
                            selectedItem = k
                            break
                        end
                    end
                end
            end
        elseif key == 203 then -- Стрелка влево (для пагинации)
            if currentPage > 1 then
                currentPage = currentPage - 1
                selectedItem = nil
            end
        elseif key == 205 then -- Стрелка вправо (для пагинации)
            local maxPages = math.max(1, math.ceil(numFiltered / ITEMS_PER_PAGE))
            if currentPage < maxPages then
                currentPage = currentPage + 1
                selectedItem = nil
            end
        elseif key == 200 then -- Стрелка вверх (для логов, если не в режиме поиска)
            logOffset = math.min(logOffset + 1, math.max(0, #logs - LOG_LINES))
        elseif key == 208 then -- Стрелка вниз (для логов, если не в режиме поиска)
            logOffset = math.max(logOffset - 1, 0)
        elseif key == 59 then -- F1 (Добавить)
            handleButtonAction("add")
        elseif key == 60 then -- F2 (Удалить)
            handleButtonAction("delete")
        elseif key == 61 then -- F3 (Изменить)
            handleButtonAction("edit")
        elseif key == 62 then -- F4 (Крафт)
            handleButtonAction("craft")
        end
    end
    redrawNeeded = true
end)

-------------------- Старт программы --------------------
checkComponents()
bindGpu()
WIDTH, HEIGHT = g.maxResolution()
g.setResolution(WIDTH, HEIGHT)
addLog("Программа Ultimate AE2 Auto-Crafter запущена.", "INFO")

-- Начальная загрузка и отрисовка
local ok, err = pcall(reload)
if not ok then
    addLog("Ошибка при начальной загрузке данных: " .. tostring(err), "ERROR")
    -- Если произошла ошибка загрузки, остаемся в основном цикле для отображения ошибок.
end

-- Запуск цикла автокрафта в отдельном потоке (coroutine)
-- Это позволит UI оставаться отзывчивым, пока происходит крафт в фоне.
local autoCraftThread = coroutine.create(autoCraftLoop)

-- Основной цикл UI и обработки событий
while true do
    -- Выполняем шаг автокрафта
    local _, autoCraftStatus, autoCraftError = coroutine.resume(autoCraftThread)
    if not autoCraftStatus and autoCraftError then
        addLog("Фатальная ошибка в потоке автокрафта: " .. tostring(autoCraftError), "CRITICAL")
        break -- Выход из программы при фатальной ошибке в потоке крафта
    end

    -- Отрисовка, если нужно
    if redrawNeeded then
        draw()
    end

    -- Обработка событий
    local e = {event.pull(0.05)} -- Ждем событие 50 мс или продолжаем
    if e[1] then
        if e[1] == "mouse_click" then
            event.push(e[1], e[2], e[3], e[4]) -- Передаем аргументы
        elseif e[1] == "mouse_drag" then
            event.push(e[1], e[2], e[3], e[4], e[5], e[6])
        elseif e[1] == "mouse_move" then
            event.push(e[1], e[2], e[3])
        elseif e[1] == "key_down" then
            event.push(e[1], e[2], e[3], e[4])
        elseif e[1] == "term_resize" then
            WIDTH, HEIGHT = g.maxResolution()
            g.setResolution(WIDTH, HEIGHT)
            redrawNeeded = true
        end
    end
end
