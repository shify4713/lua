-- auto-gemeni.lua
local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode")
local term = require("term")
local computer = require("computer")
local g = component.gpu
local me = component.me_interface

-- Пути и библиотека
local DATA_FILE = "/home/BD.txt"
local LIB_PATH = "/lib/ultimateOC.lua"
local LIB_URL = "https://raw.githubusercontent.com/shify4713/lua/main/ultimateOC.lua"

-- Загружаем библиотеку ultimateOC
-- Проверяем, существует ли файл библиотеки
if not fs.exists(LIB_PATH) then
    io.stderr:write("Библиотека ultimateOC.lua не найдена по пути: " .. LIB_PATH .. "\n")
    io.stderr:write("Попытка загрузки с GitHub...\n")
    local success, err = shell.exec("wget", LIB_URL, LIB_PATH)
    if not success then
        io.stderr:write("Ошибка: Не удалось загрузить ultimateOC.lua с GitHub: " .. tostring(err) .. "\n")
        os.exit(1)
    else
        io.stderr:write("ultimateOC.lua успешно загружен.\n")
    end
end

-- Теперь пытаемся загрузить библиотеку
local ok, ultimateOC = pcall(require, LIB_PATH)
if not ok then
    io.stderr:write("Ошибка: Не удалось загрузить библиотеку ultimateOC.lua: " .. tostring(ultimateOC) .. "\n")
    io.stderr:write("Пожалуйста, проверьте файл " .. LIB_PATH .. " на наличие синтаксических ошибок.\n")
    os.exit(1)
end

local uoc = ultimateOC -- Используем более короткое имя для удобства

-- ... (остальной ваш код без изменений) ...
-- Проверка доступности компонентов
local function checkComponents()
    if not component.isAvailable("gpu") then
        io.stderr:write("Ошибка: GPU недоступен\n")
        os.exit(1)
    end
    if not component.isAvailable("screen") then
        io.stderr:write("Ошибка: Экран недоступен\n")
        os.exit(1)
    end
    if not component.isAvailable("me_interface") then
        io.stderr:write("Ошибка: ME-интерфейс недоступен\n")
        os.exit(1)
    end
end

-- Привязка GPU к экрану
local function bindGpu()
    local screen = component.list("screen")()
    if not screen then
        io.stderr:write("Ошибка: Не найден экран для привязки GPU\n")
        os.exit(1)
    end
    local success, err = pcall(g.bind, screen)
    if not success then
        io.stderr:write("Ошибка: Не удалось привязать GPU к экрану: " .. tostring(err) .. "\n")
        os.exit(1)
    end
end

-- Глобальные переменные и настройки
local WIDTH, HEIGHT
local dataItems = {}
local logs = {}
local selectedItem = nil
local currentPage = 1
local search = ""
local searchActive = false
local changeitem = false
local isCrafting = false
local craftStatus = "Ожидание"
local nextCraftUpdate = 0
local logOffset = 0
local buttonHover = nil -- Переменная для отслеживания наведения мыши
local lastDrawTime = 0 -- Для отслеживания времени последней полной перерисовки

local settings = {
    sortCriteria = "name",
    sortAscending = true,
}

-- Цвета
local COLORS = {
    background = 0x1A1B26,
    foreground = 0xC0CAF5,
    border = 0x7AA2F7,
    buttonBg = 0x414868,
    buttonActive = 0x7DCFFF,
    buttonHover = 0x9DEDFF,
    error = 0xF7768E,
    info = 0xBB9AF7,
    warning = 0xFFC970,
    ok = 0x9ECE6A,
    subText = 0xBB9AF7,
    selectedRow = 0x364177,
    progressBg = 0x2A2E44,
    progressBar = 0x9ECE6A,
}

-- Вспомогательная функция для добавления логов
function addLog(tbl, message, type)
    if #tbl >= 100 then -- Ограничиваем количество логов
        table.remove(tbl, 1)
    end
    table.insert(tbl, string.format("[%s] %s: %s", os.date("%H:%M:%S"), type or "INFO", message))
end

-- Вспомогательная функция для сохранения данных
function save()
    uoc.savef(DATA_FILE, {items = dataItems, settings = settings})
end

-- Вспомогательная функция для загрузки данных
function load()
    local loadedData = uoc.loadf(DATA_FILE)
    if loadedData then
        dataItems = loadedData.items or {}
        settings = loadedData.settings or {sortCriteria = "name", sortAscending = true}
    end
end

-- Функция для получения количества элементов на странице
function getItemsPerPage()
    return math.max(1, HEIGHT - 10 - 10) -- Высота экрана минус отступы сверху/снизу и панель поиска
end

-- Функция для получения максимального количества страниц
function getMaxPages()
    local filteredItems = getFilteredAndSortedItems()
    local perPage = getItemsPerPage()
    return math.max(1, math.ceil(#filteredItems / perPage))
end

-- Функция для фильтрации и сортировки элементов
function getFilteredAndSortedItems()
    local filtered = {}
    for _, item in ipairs(dataItems) do
        local matchesSearch = true
        if search ~= "" then
            matchesSearch = string.find(string.lower(item.name or ""), string.lower(search)) or
                            string.find(string.lower(item.category or ""), string.lower(search))
        end
        if matchesSearch then
            table.insert(filtered, item)
        end
    end

    table.sort(filtered, function(a, b)
        local valA = a[settings.sortCriteria]
        local valB = b[settings.sortCriteria]

        if type(valA) == "number" and type(valB) == "number" then
            return settings.sortAscending and (valA < valB) or (valA > valB)
        else
            valA = tostring(valA or "")
            valB = tostring(valB or "")
            if settings.sortAscending then
                return valA < valB
            else
                return valA > valB
            end
        end
    end)
    return filtered
end

-- Функция для получения текущего количества предметов из ME-сети
function getCurrentItemCount(itemName)
    local items = me.getItemsInME()
    for _, item in ipairs(items) do
        if item.label == itemName then
            return item.size
        end
    end
    return 0
end

-- Функция для получения количества доступных для крафта
function getCraftableCount(itemName)
    local patterns = me.getCraftableItems()
    for _, pattern in ipairs(patterns) do
        if pattern.label == itemName then
            return pattern.count
        end
    end
    return 0
end

-- Функция для обновления данных ME-сети и логирования
function reload()
    addLog(logs, "INFO: Обновление данных ME-сети...", "INFO")
    local meItems = me.getItemsInME()
    local craftableItems = me.getCraftableItems()

    for i, item in ipairs(dataItems) do
        item.current = 0
        for _, meItem in ipairs(meItems) do
            if meItem.label == item.name then
                item.current = meItem.size
                break
            end
        end

        item.craftable = 0
        for _, craftableItem in ipairs(craftableItems) do
            if craftableItem.label == item.name then
                item.craftable = craftableItem.count
                break
            end
        end
    end
    addLog(logs, "INFO: Данные ME-сети обновлены", "INFO")
end

-- Функция для отрисовки кнопок
local function drawButtons()
    local btnWidth = 12
    local btnHeight = 3
    local btnX = WIDTH - btnWidth - 5
    local btnPadding = 2

    local btns = {
        {name = "Крафт всех", action = "craftAll", enabled = true},
        {name = "Удалить", action = "delete", enabled = selectedItem ~= nil},
        {name = "Изменить", action = "edit", enabled = selectedItem ~= nil},
        {name = isCrafting and "Остановить" or "Автокрафт", action = "toggleCraft", enabled = true},
        {name = "Добавить", action = "add", enabled = true},
    }

    g.setBackground(COLORS.background) -- Убедимся, что фон под кнопками очищается
    for i, btn in ipairs(btns) do
        local btnY = 10 + (i - 1) * (btnHeight + btnPadding)
        local bgColor = COLORS.buttonBg
        local textColor = COLORS.foreground
        if not btn.enabled then
            textColor = COLORS.subText -- Неактивный цвет
        elseif buttonHover == btn.action then
            bgColor = COLORS.buttonHover
        end
        uoc.animatedButton(btnX, btnY, btnWidth, btnHeight, btn.name, bgColor, textColor, COLORS.border, nil)
    end

    -- Стрелки для переключения страниц
    local arrowBtnW = 4
    local arrowBtnH = 3
    local arrowBtnY = 10 + (#btns * (btnHeight + btnPadding))

    local prevArrowBtnX = btnX
    local nextArrowBtnX = btnX + arrowBtnW + 1

    local prevEnabled = currentPage > 1
    local nextEnabled = currentPage < getMaxPages()

    local prevBg = COLORS.buttonBg
    local prevTxtColor = COLORS.foreground
    if not prevEnabled then prevTxtColor = COLORS.subText end
    if buttonHover == "prevPage" and prevEnabled then prevBg = COLORS.buttonHover end
    uoc.animatedButton(prevArrowBtnX, arrowBtnY, arrowBtnW, arrowBtnH, "<", prevBg, prevTxtColor, COLORS.border, nil)

    local nextBg = COLORS.buttonBg
    local nextTxtColor = COLORS.foreground
    if not nextEnabled then nextTxtColor = COLORS.subText end
    if buttonHover == "nextPage" and nextEnabled then nextBg = COLORS.buttonHover end
    uoc.animatedButton(nextArrowBtnX, arrowBtnY, arrowBtnW, arrowBtnH, ">", nextBg, nextTxtColor, COLORS.border, nil)

    -- Кнопка сортировки
    local sortBtnY = arrowBtnY + arrowBtnH + 2
    local sortBtnW = 12
    local sortName = string.sub(settings.sortCriteria, 1, 1):upper() .. string.sub(settings.sortCriteria, 2)
    local sortSubText = settings.sortAscending and "ASC" or "DESC"
    local sortBg = COLORS.buttonBg
    if buttonHover == "sort" then sortBg = COLORS.buttonHover end
    uoc.animatedButton(btnX, sortBtnY, sortBtnW, arrowBtnH, sortName, sortBg, COLORS.foreground, COLORS.border, sortSubText)
end


-- Функция для отрисовки таблицы элементов
local function drawItems()
    local perPage = getItemsPerPage()
    local filteredAndSortedItems = getFilteredAndSortedItems()
    local startIndex = (currentPage - 1) * perPage + 1
    local endIndex = math.min(startIndex + perPage - 1, #filteredAndSortedItems)

    local columnWidths = {
        name = math.floor((WIDTH - 20) * 0.3), -- 30%
        category = math.floor((WIDTH - 20) * 0.2), -- 20%
        current = math.floor((WIDTH - 20) * 0.15), -- 15%
        count = math.floor((WIDTH - 20) * 0.15), -- 15%
        craftSize = math.floor((WIDTH - 20) * 0.2), -- 20%
    }
    local itemsStartY = 10 -- Начальная Y-координата для списка
    g.setBackground(COLORS.background)
    g.fill(2, itemsStartY, WIDTH - 20, HEIGHT - 10 - itemsStartY, " ") -- Очищаем область таблицы

    for i = startIndex, endIndex do
        local item = filteredAndSortedItems[i]
        local rowY = itemsStartY + (i - startIndex)
        local bgColor = COLORS.background
        local textColor = COLORS.foreground

        -- Проверяем, является ли текущий элемент выбранным
        if selectedItem == i then
            bgColor = COLORS.selectedRow
        end

        g.setBackground(bgColor)
        g.fill(2, rowY, WIDTH - 20, 1, " ") -- Заливаем фон строки

        local currentX = 2
        local function drawCell(text, width)
            local trimmedText = unicode.sub(text, 1, width)
            g.setForeground(textColor)
            g.set(currentX, rowY, trimmedText)
            currentX = currentX + width
        end

        drawCell(item.name or "", columnWidths.name)
        drawCell(item.category or "", columnWidths.category)
        drawCell(tostring(item.current or 0), columnWidths.current)
        drawCell(tostring(item.count or 0), columnWidths.count)
        drawCell(tostring(item.craftSize or 0), columnWidths.craftSize)
    end
end

-- Функция для отрисовки логов
local function drawLogs()
    local logAreaY = HEIGHT - 8 -- Начальная Y-координата для логов
    local logAreaHeight = 5 -- Количество строк логов

    g.setBackground(COLORS.background)
    g.fill(2, logAreaY, WIDTH - 4, logAreaHeight, " ") -- Очищаем область логов

    uoc.drawLogs(2, logAreaY, logs, logAreaHeight, COLORS.foreground, logOffset)
end

-- Функция для отрисовки панели поиска
local function drawSearch()
    local searchBarY = HEIGHT - 4
    local searchBarX = 2
    local searchBarWidth = WIDTH - 20
    g.setBackground(COLORS.background)
    g.fill(searchBarX, searchBarY, searchBarWidth, 1, " ") -- Очищаем фон
    local cursorChar = searchActive and "_" or ""
    uoc.drawText(searchBarX, searchBarY, "Поиск: " .. search .. cursorChar, COLORS.foreground)

    -- Кнопка очистки поиска
    local clearBtnX = searchBarX + searchBarWidth - 3
    g.setBackground(COLORS.buttonBg)
    g.setForeground(COLORS.foreground)
    g.set(clearBtnX, searchBarY, "[X]")
end

-- Главная функция отрисовки всего экрана
local function draw()
    g.setBackground(COLORS.background)
    g.clear() -- Очищаем весь экран

    -- Заголовок
    uoc.drawText(2, 2, "Система Автокрафта ME", COLORS.info, true)
    uoc.drawText(2, 3, "Статус: " .. craftStatus,
        (craftStatus:find("Ошибка") and COLORS.error) or (isCrafting and COLORS.ok) or COLORS.info)

    -- Прогресс бар
    if uoc.progressBar then
        uoc.progressBar(2, 5, WIDTH - 20, isCrafting and 0.9 or 0, COLORS.progressBg, COLORS.progressBar, COLORS.border)
    end

    drawButtons()
    drawItems()
    drawLogs()
    drawSearch()

    -- Информация о странице
    local pageInfo = string.format("Страница %d/%d", currentPage, getMaxPages())
    uoc.drawText(2, HEIGHT - 10, pageInfo, COLORS.foreground)

    g.present() -- Отображаем все изменения на экране
    lastDrawTime = computer.uptime() -- Обновляем время последней полной перерисовки
end

-- Функции CRUD (создание, чтение, обновление, удаление)

-- Добавление нового элемента
local function addItem()
    local newItem = {
        name = "",
        category = "",
        count = 0,
        craftSize = 0,
        current = 0,
        craftable = 0,
    }
    local function promptForInput(promptText, defaultValue)
        draw() -- Очищаем экран перед запросом
        uoc.drawText(2, HEIGHT - 2, promptText .. (defaultValue ~= nil and " [" .. tostring(defaultValue) .. "]" or ""), COLORS.info)
        g.present()
        local input = io.read()
        g.setBackground(COLORS.background)
        g.fill(2, HEIGHT - 2, WIDTH - 4, 1, " ") -- Очищаем строку запроса
        g.present()
        return input == "" and defaultValue or input
    end

    changeitem = true
    newItem.name = promptForInput("Введите название предмета (например, Silicon):")
    if not newItem.name or newItem.name == "" then changeitem = false; draw(); return end
    newItem.category = promptForInput("Введите категорию (например, Component):")
    if not newItem.category then newItem.category = "" end
    newItem.count = tonumber(promptForInput("Введите желаемое количество (число):", 0)) or 0
    newItem.craftSize = tonumber(promptForInput("Введите размер крафта (число):", 1)) or 1
    changeitem = false
    table.insert(dataItems, newItem)
    save()
    addLog(logs, "INFO: Добавлен новый предмет: " .. newItem.name, "INFO")
    reload()
    draw()
end

-- Редактирование элемента
local function editItem()
    if not selectedItem then return end
    local item = dataItems[selectedItem]
    local function promptForInput(promptText, defaultValue)
        draw() -- Очищаем экран перед запросом
        uoc.drawText(2, HEIGHT - 2, promptText .. (defaultValue ~= nil and " [" .. tostring(defaultValue) .. "]" or ""), COLORS.info)
        g.present()
        local input = io.read()
        g.setBackground(COLORS.background)
        g.fill(2, HEIGHT - 2, WIDTH - 4, 1, " ") -- Очищаем строку запроса
        g.present()
        return input == "" and defaultValue or input
    end

    changeitem = true
    addLog(logs, "INFO: Редактирование предмета: " .. item.name, "INFO")
    item.name = promptForInput("Введите новое название предмета:", item.name) or item.name
    item.category = promptForInput("Введите новую категорию:", item.category) or item.category
    item.count = tonumber(promptForInput("Введите новое желаемое количество:", item.count)) or item.count
    item.craftSize = tonumber(promptForInput("Введите новый размер крафта:", item.craftSize)) or item.craftSize
    changeitem = false
    save()
    addLog(logs, "INFO: Предмет изменен: " .. item.name, "INFO")
    reload()
    draw()
end

-- Удаление элемента
local function removeItem()
    if not selectedItem then return end
    local itemName = dataItems[selectedItem].name
    table.remove(dataItems, selectedItem)
    selectedItem = nil
    save()
    addLog(logs, "INFO: Предмет удален: " .. itemName, "INFO")
    reload()
    draw()
end

-- Функции крафта

-- Попытка скрафтить один предмет
function tryCraftItem(item)
    if item.current < item.count then
        local needed = item.count - item.current
        local craftAmount = math.min(needed, item.craftSize)
        if craftAmount <= 0 then return false end

        addLog(logs, "INFO: Запрос на крафт " .. craftAmount .. "x " .. item.name, "INFO")
        local success, reason = me.craft(item.name, craftAmount)
        if success then
            addLog(logs, "ОК: Скрафчено " .. craftAmount .. "x " .. item.name, "OK")
            craftStatus = "Крафтится: " .. item.name .. " x" .. craftAmount
            reload() -- Обновляем данные после успешного крафта
            return true
        else
            addLog(logs, "ERROR: Не удалось скрафтить " .. item.name .. ": " .. tostring(reason), "ERROR")
            craftStatus = "Ошибка крафта: " .. item.name
            return false
        end
    end
    return false
end

-- Запуск автокрафта
function doCraft()
    if isCrafting then return end
    isCrafting = true
    craftStatus = "Запущено"
    addLog(logs, "INFO: Автокрафт запущен", "INFO")
    draw() -- Обновляем интерфейс после запуска
end

-- Остановка автокрафта
function stopCraft()
    isCrafting = false
    craftStatus = "Остановлено"
    addLog(logs, "INFO: Автокрафт остановлен", "INFO")
    draw() -- Обновляем интерфейс после остановки
end

-- Крафт всех недостающих предметов
function craftAll()
    addLog(logs, "INFO: Запрос на крафт всех недостающих предметов", "INFO")
    reload()
    local anyCrafted = false
    for _, item in ipairs(dataItems) do
        if item.current < item.count then
            local needed = item.count - item.current
            if needed > 0 then
                local success, reason = me.craft(item.name, needed)
                if success then
                    addLog(logs, "ОК: Скрафчено " .. needed .. "x " .. item.name, "OK")
                    anyCrafted = true
                else
                    addLog(logs, "ERROR: Не удалось скрафтить " .. item.name .. ": " .. tostring(reason), "ERROR")
                end
            end
        end
    end
    if anyCrafted then
        addLog(logs, "INFO: Все доступные крафты выполнены.", "INFO")
    else
        addLog(logs, "INFO: Ничего не требовалось крафтить или все крафты невозможны.", "INFO")
    end
    reload()
    draw()
end

-- Главный цикл автокрафта
local function autoCraftLoop()
    while true do
        if isCrafting then
            local now = computer.uptime()
            if now >= nextCraftUpdate then
                local ok, err = pcall(reload)
                if not ok then
                    addLog(logs, "ERROR: Ошибка в reload: " .. tostring(err), "ERROR")
                    craftStatus = "Ошибка: обновление данных"
                    draw() -- Перерисовываем при ошибке
                else
                    local oldCraftStatus = craftStatus -- Сохраняем старый статус
                    local craftMadeThisCycle = false
                    for i, item in ipairs(dataItems) do
                        if not craftMadeThisCycle then -- Крафтим по одному за цикл, чтобы не перегружать
                            if tryCraftItem(item) then
                                craftMadeThisCycle = true
                                break
                            end
                        end
                    end
                    save()
                    nextCraftUpdate = now + 30 -- Обновляем данные ME-сети каждые 30 секунд

                    -- Перерисовываем весь экран только если статус изменился или был крафт
                    if oldCraftStatus ~= craftStatus or craftMadeThisCycle then
                        draw()
                    else
                        -- Иначе обновляем только статус и логи
                        drawLogs()
                        uoc.drawText(2, 3, "Статус: " .. craftStatus,
                            (craftStatus:find("Ошибка") and COLORS.error) or (isCrafting and COLORS.ok) or COLORS.info)
                        if uoc.progressBar then
                            uoc.progressBar(2, 5, WIDTH - 20, isCrafting and 0.9 or 0, COLORS.progressBg, COLORS.progressBar, COLORS.border)
                        end
                        g.present() -- Обновляем экран с частичными изменениями
                    end
                end
            end
        else
            -- Если автокрафт не активен, но прошло достаточно времени с последней полной прорисовки
            -- или если были изменения, вызванные mouse_move/touch, они уже должны были вызвать draw()/drawButtons()
            -- Мы все равно будем обновлять статус и логи, чтобы они не застывали
            local now = computer.uptime()
            if now >= nextCraftUpdate then -- Регулярное обновление ME, даже если не крафтим
                local ok, err = pcall(reload)
                if not ok then
                    addLog(logs, "ERROR: Ошибка в reload (не в режиме крафта): " .. tostring(err), "ERROR")
                    craftStatus = "Ошибка: обновление данных"
                end
                draw() -- Вызываем полную перерисовку при обновлении данных ME, даже если не крафтим
                nextCraftUpdate = now + 30
            end
        end
        os.sleep(0.1) -- Уменьшаем задержку для лучшей отзывчивости
    end
end

-- Обработчики событий
event.listen("key_down", function(_, _, key, _, _, unicodeChar)
    if changeitem then
        if key == 28 then -- Enter
            -- Обрабатывается в promptForInput
        elseif key == 14 then -- Backspace
            -- Обрабатывается в promptForInput
        elseif unicodeChar then
            -- Обрабатывается в promptForInput
        end
        return
    end

    if searchActive then
        if key == 28 then -- Enter
            searchActive = false
        elseif key == 14 then -- Backspace
            search = unicode.sub(search, 1, unicode.len(search) - 1)
            currentPage = 1
            selectedItem = nil
        elseif unicodeChar then
            search = search .. unicode.char(unicodeChar)
            currentPage = 1
            selectedItem = nil
        end
    else
        if key == 28 then -- Enter
            -- Do nothing for now, as there's no explicit "enter" action outside search/prompts
        elseif key == 200 and selectedItem then -- Up arrow
            local filteredAndSortedItems = getFilteredAndSortedItems()
            local perPage = getItemsPerPage()
            local startIndex = (currentPage - 1) * perPage + 1
            local idxOnPage = selectedItem - startIndex
            if idxOnPage > 0 then
                selectedItem = selectedItem - 1
            elseif currentPage > 1 then
                currentPage = currentPage - 1
                local newStartIndex = (currentPage - 1) * perPage + 1
                selectedItem = newStartIndex + perPage - 1
            end
        elseif key == 208 and selectedItem then -- Down arrow
            local filteredAndSortedItems = getFilteredAndSortedItems()
            local perPage = getItemsPerPage()
            local startIndex = (currentPage - 1) * perPage + 1
            local idxOnPage = selectedItem - startIndex
            if idxOnPage < perPage - 1 and selectedItem < #filteredAndSortedItems then
                selectedItem = selectedItem + 1
            elseif currentPage < getMaxPages() then
                currentPage = currentPage + 1
                local newStartIndex = (currentPage - 1) * perPage + 1
                selectedItem = newStartIndex
            end
        elseif key == 203 then -- Left arrow
            if currentPage > 1 then
                currentPage = currentPage - 1
                selectedItem = nil
            end
        elseif key == 205 then -- Right arrow
            if currentPage < getMaxPages() then
                currentPage = currentPage + 1
                selectedItem = nil
            end
        elseif key == 200 and not searchActive then -- Up arrow for logs
            logOffset = math.min(logOffset + 1, #logs - 5)
        elseif key == 208 and not searchActive then -- Down arrow for logs
            logOffset = math.max(logOffset - 1, 0)
        end
    end
    -- Перерисовываем весь экран, если произошли изменения, влияющие на таблицу или логи
    draw()
end)

local function updateButtonHover(x, y)
    local btnWidth = 12
    local btnHeight = 3
    local btnX = WIDTH - btnWidth - 5
    local btnPadding = 2
    local btns = {
        {name = "Крафт всех", action = "craftAll"},
        {name = "Удалить", action = "delete"},
        {name = "Изменить", action = "edit"},
        {name = isCrafting and "Остановить" or "Автокрафт", action = "toggleCraft"},
        {name = "Добавить", action = "add"},
    }
    for i, btn in ipairs(btns) do
        local btnY = 10 + (i - 1) * (btnHeight + btnPadding)
        if x >= btnX and x <= btnX + btnWidth - 1 and y >= btnY and y <= btnY + btnHeight - 1 then
            return btn.action
        end
    end
    local arrowBtnW = 4
    local arrowBtnH = 3
    local arrowBtnY = 10 + (#btns * (btnHeight + btnPadding))
    local prevArrowBtnX = btnX
    local nextArrowBtnX = btnX + arrowBtnW + 1
    local sortBtnY = arrowBtnY + arrowBtnH + 2
    local sortBtnW = 12
    if x >= prevArrowBtnX and x <= prevArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        return "prevPage"
    elseif x >= nextArrowBtnX and x <= nextArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        return "nextPage"
    elseif x >= btnX and x <= btnX + sortBtnW - 1 and y >= sortBtnY and y <= sortBtnY + arrowBtnH - 1 then
        return "sort"
    end
    return nil
end

event.listen("mouse_move", function(_, _, x, y)
    if changeitem then return end
    local newButtonHover = updateButtonHover(x, y)
    if newButtonHover ~= buttonHover then -- Перерисовываем только если статус наведения изменился
        buttonHover = newButtonHover
        drawButtons() -- Перерисовываем только кнопки
        g.present() -- Обновляем экран, чтобы изменения были видны немедленно
    end
end)

event.listen("touch", function(_, _, x, y, _, _)
    if changeitem then return end
    local handled = false -- Флаг, чтобы знать, обработано ли событие
    local btnWidth = 12
    local btnHeight = 3
    local btnX = WIDTH - btnWidth - 5
    local btnPadding = 2
    local btns = {
        {name = "Крафт всех", action = "craftAll"},
        {name = "Удалить", action = "delete"},
        {name = "Изменить", action = "edit"},
        {name = isCrafting and "Остановить" or "Автокрафт", action = "toggleCraft"},
        {name = "Добавить", action = "add"},
    }
    for i, btn in ipairs(btns) do
        local btnY = 10 + (i - 1) * (btnHeight + btnPadding)
        if x >= btnX and x <= btnX + btnWidth - 1 and y >= btnY and y <= btnY + btnHeight - 1 then
            if btn.action == "delete" then removeItem()
            elseif btn.action == "edit" then editItem()
            elseif btn.action == "toggleCraft" then if isCrafting then stopCraft() else doCraft() end
            elseif btn.action == "add" then addItem()
            elseif btn.action == "craftAll" then craftAll()
            end
            buttonHover = nil -- Сбрасываем наведение после клика
            drawButtons() -- Перерисовываем только кнопки после действия
            handled = true
            break
        end
    end
    if handled then return end -- Если кнопка обработана, выходим

    local arrowBtnW = 4
    local arrowBtnH = 3
    local arrowBtnY = 10 + (#btns * (btnHeight + btnPadding))

    local prevArrowBtnX = btnX
    local nextArrowBtnX = btnX + arrowBtnW + 1
    local sortBtnY = arrowBtnY + arrowBtnH + 2
    local sortBtnW = 12

    if x >= prevArrowBtnX and x <= prevArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        if currentPage > 1 then
            currentPage = currentPage - 1
            selectedItem = nil
            buttonHover = nil
            draw() -- Здесь перерисовываем весь экран, так как изменился контент таблицы
        end
        handled = true
    elseif x >= nextArrowBtnX and x <= nextArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        local maxPages = getMaxPages()
        if currentPage < maxPages then
            currentPage = currentPage + 1
            selectedItem = nil
            buttonHover = nil
            draw() -- Здесь перерисовываем весь экран, так как изменился контент таблицы
        end
        handled = true
    elseif x >= btnX and x <= btnX + sortBtnW - 1 and y >= sortBtnY and y <= sortBtnY + arrowBtnH - 1 then
        local criteriaList = {"name", "category", "current", "count", "craftSize"}
        local currentCriteriaIndex = 1
        for i, v in ipairs(criteriaList) do
            if v == settings.sortCriteria then
                currentCriteriaIndex = i
                break
            end
            if i == #criteriaList and v ~= settings.sortCriteria then
                currentCriteriaIndex = 0
            end
        end
        currentCriteriaIndex = currentCriteriaIndex + 1
        if currentCriteriaIndex > #criteriaList then
            currentCriteriaIndex = 1
            settings.sortAscending = not settings.sortAscending
        else
            settings.sortAscending = true
        end
        settings.sortCriteria = criteriaList[currentCriteriaIndex]
        currentPage = 1
        selectedItem = nil
        buttonHover = nil
        save()
        draw() -- Здесь перерисовываем весь экран, так как изменилась сортировка
        handled = true
    end
    if handled then return end

    -- Обработка кликов по строке поиска
    if y >= HEIGHT - 4 and y <= HEIGHT - 4 then -- Только одна строка для поиска
        local searchBarX = 2
        local searchBarWidth = WIDTH - 20
        local clearBtnX = searchBarX + searchBarWidth - 3

        if x >= clearBtnX and x <= clearBtnX + 2 and search ~= "" then -- Клик по [X]
            search = ""
            currentPage = 1
            selectedItem = nil
            buttonHover = nil
            draw()
            return
        elseif x >= searchBarX and x <= searchBarX + searchBarWidth - 1 then -- Клик по полю поиска
            searchActive = true
            buttonHover = nil
            draw()
            return
        end
    end
    
    -- Сброс searchActive если клик не по поиску
    searchActive = false

    -- Обработка кликов по элементам таблицы
    local filteredAndSortedItems = getFilteredAndSortedItems()
    local perPage = getItemsPerPage()
    local startIndex = (currentPage - 1) * perPage + 1
    local itemsStartY = 10
    local itemsEndY = itemsStartY + perPage - 1
  
    if y >= itemsStartY and y <= itemsEndY then
        local idxOnPage = y - itemsStartY
        local actualIndexInFiltered = startIndex + idxOnPage
        if filteredAndSortedItems[actualIndexInFiltered] then
            for k, v in ipairs(dataItems) do
                if v == filteredAndSortedItems[actualIndexInFiltered] then 
                    selectedItem = k
                    break 
                end
            end
        end
        buttonHover = nil
        draw()
        return
    end
    buttonHover = nil
    draw() -- Если клик не обработан нигде выше, перерисовываем на всякий случай
end)


-------------------- Старт --------------------
checkComponents()
bindGpu()
WIDTH, HEIGHT = g.maxResolution()
g.setResolution(WIDTH, HEIGHT)
addLog(logs, "INFO: Программа запущена", "INFO")
local ok, err = pcall(reload)
if not ok then
    addLog(logs, "ERROR: Ошибка при начальной загрузке: " .. tostring(err), "ERROR")
    draw()
    while true do os.sleep(1) end
end
draw() -- Начальная полная отрисовка
local ok, err = pcall(autoCraftLoop)
if not ok then
    addLog(logs, "ERROR: Фатальная ошибка в autoCraftLoop: " .. tostring(err), "ERROR")
    draw()
    while true do os.sleep(1) end
end
