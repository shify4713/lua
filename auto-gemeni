local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode")
local term = require("term")
local computer = require("computer")

local g = component.gpu
local me = component.me_interface

-- Пути и библиотека
local DATA_FILE = "/home/BD.txt"
local LIB_PATH = "/lib/ultimateOC.lua"
local LIB_URL = "https://raw.githubusercontent.com/shify4713/lua/refs/heads/main/ultimateOC.lua"

-- Загружаем библиотеку
local M = require(LIB_PATH) -- Теперь M содержит все функции из ultimateOC.lua, включая M.drawText

-- Проверка доступности компонентов
local function checkComponents()
    if not component.isAvailable("gpu") then
        io.stderr:write("Ошибка: GPU недоступен\n")
        os.exit(1)
    end
    if not component.isAvailable("screen") then
        io.stderr:write("Ошибка: Экран недоступен\n")
        os.exit(1)
    end
    if not component.isAvailable("me_interface") then
        io.stderr:write("Ошибка: ME-интерфейс недоступен\n")
        os.exit(1)
    end
end

-- Привязка GPU к экрану
local function bindGpu()
    local screen = component.list("screen")()
    if not screen then
        io.stderr:write("Ошибка: Не найден экран для привязки GPU\n")
        os.exit(1)
    end
    local success, err = pcall(g.bind, screen)
    if not success then
        io.stderr:write("Ошибка: Не удалось привязать GPU к экрану: "..tostring(err).."\n")
        os.stderr:write("Попробуйте использовать 'gpu.bind <адрес экрана>'\n")
        os.exit(1)
    end
end

-- Получить все предметы из ME-интерфейса
local function getItems()
    local success, items = pcall(me.getItemsInNetwork)
    if not success then
        M.addLog(logs, "ERROR: Не удалось получить предметы из ME-интерфейса: "..tostring(items), "ERROR")
        return {}
    end
    -- Фильтруем предметы, оставляя только те, у которых есть подкомпоненты (т.е. крафтовые)
    local craftableItems = {}
    for _, item in ipairs(items) do
        if item.components and #item.components > 0 then
            table.insert(craftableItems, item)
        end
    end
    -- Сортируем по названию
    table.sort(craftableItems, function(a, b) return unicode.lower(a.label or "") < unicode.lower(b.label or "") end)
    return craftableItems
end

-- Проверяет, можно ли крафтить предмет
local function canCraft(item)
    local success, can = pcall(me.isCraftable, item.name)
    if not success then
        M.addLog(logs, "ERROR: Ошибка проверки возможности крафта: "..tostring(can), "ERROR")
        return false
    end
    return can
end

-- Выполняет крафт предмета
local function craftItem(item, amount)
    local success, result = pcall(me.craft, item.name, amount)
    if not success then
        M.addLog(logs, "ERROR: Ошибка крафта "..item.label..": "..tostring(result), "ERROR")
        return false
    end
    M.addLog(logs, "INFO: Заказан крафт "..amount.."x "..item.label, "INFO")
    return true
end

-- Переменные состояния
local WIDTH, HEIGHT
local logs = {}
local dataItems = {}
local filteredItems = {}
local currentPage = 1
local itemsPerPage = 15
local selectedItem = nil -- Теперь хранит индекс в filteredItems или nil
local currentScreen = "main"
local searchActive = false
local searchTerm = ""
local inputBuffer = ""
local logOffset = 0 -- Для скролла логов


-- Загрузка/Сохранение данных
local function loadData()
    dataItems = M.loadf(DATA_FILE)
    M.addLog(logs, "INFO: Данные загружены из "..DATA_FILE, "INFO")
end

local function saveData()
    M.savef(DATA_FILE, dataItems)
    M.addLog(logs, "INFO: Данные сохранены в "..DATA_FILE, "INFO")
end

-- Обновление списка предметов
local function reload()
    dataItems = getItems()
    filteredItems = M.filterItems(dataItems, searchTerm)
    currentPage = 1
    selectedItem = nil
    saveData() -- Сохраняем обновленный список предметов
end

-- Функции отрисовки
local function clearScreen()
    g.setBackground(0x282A36)
    g.setForeground(0xF8F8F2)
    g.fill(1, 1, WIDTH, HEIGHT, " ")
end

local function drawMainMenu()
    clearScreen()
    M.drawText(math.floor((WIDTH - unicode.len("Главное меню")) / 2), 1, "Главное меню", 0x50FA7B)

    local buttonY = 3
    -- Передаем координаты кнопок в M.drawText для обработки мерцания
    M.drawText(math.floor((WIDTH - unicode.len("1. Добавить/Изменить предмет")) / 2), buttonY, "1. Добавить/Изменить предмет", 0xFF79C6)
    M.drawText(math.floor((WIDTH - unicode.len("2. Запустить автокрафт")) / 2), buttonY + 2, "2. Запустить автокрафт", 0x8BE9FD)
    M.drawText(math.floor((WIDTH - unicode.len("3. Настройки")) / 2), buttonY + 4, "3. Настройки", 0xF1FA8C)
    M.drawText(math.floor((WIDTH - unicode.len("4. Выход")) / 2), buttonY + 6, "4. Выход", 0xFF5555)

    M.drawLogs(1, HEIGHT - 5, M.scrollArray(logs, logOffset, 5), 5)
end

local function drawAddEditScreen()
    clearScreen()
    M.drawText(math.floor((WIDTH - unicode.len("Добавить/Изменить предмет")) / 2), 1, "Добавить/Изменить предмет", 0xFF79C6)

    local startY = 3
    local visibleItems = M.scrollArray(filteredItems, currentPage * itemsPerPage - itemsPerPage + 1, itemsPerPage)
    local maxPages = math.max(1, math.ceil(#filteredItems / itemsPerPage))

    M.drawText(2, startY, "Поиск: " .. searchTerm .. (searchActive and "_" or ""), 0xF1FA8C)
    startY = startY + 2

    for i, item in ipairs(visibleItems) do
        local globalIndex = (currentPage - 1) * itemsPerPage + i
        local isSelected = (selectedItem == globalIndex)
        local prefix = isSelected and "> " or "  "
        local color = isSelected and 0xFFB86C or 0xF8F8F2
        M.drawText(2, startY + i - 1, prefix .. item.label .. " (" .. item.count .. ")", color)
    end

    M.drawText(2, HEIGHT - 7, "Страница: " .. currentPage .. "/" .. maxPages, 0xBD93F9)
    M.drawText(2, HEIGHT - 5, "Ввод: " .. inputBuffer .. "_", 0x8BE9FD)
    M.drawLogs(1, HEIGHT - 3, M.scrollArray(logs, logOffset, 3), 3)

    -- Кнопки
    M.drawText(2, HEIGHT - 1, " [F1] Назад  [F2] Обновить  [F3] Поиск  [Enter] Изменить/Добавить  [Del] Удалить", 0x50FA7B)
end

local function drawSettingsScreen()
    clearScreen()
    M.drawText(math.floor((WIDTH - unicode.len("Настройки")) / 2), 1, "Настройки", 0xF1FA8C)

    -- Здесь будут опции настроек
    M.drawText(2, 3, "Скоро здесь что-то будет...", 0xF8F8F2)

    M.drawLogs(1, HEIGHT - 5, M.scrollArray(logs, logOffset, 5), 5)
    M.drawText(2, HEIGHT - 1, "[F1] Назад", 0x50FA7B)
end

local function drawAutoCraftScreen()
    clearScreen()
    M.drawText(math.floor((WIDTH - unicode.len("Автокрафт")) / 2), 1, "Автокрафт", 0x8BE9FD)

    local startY = 3
    local visibleItems = M.scrollArray(dataItems, currentPage * itemsPerPage - itemsPerPage + 1, itemsPerPage)
    local maxPages = math.max(1, math.ceil(#dataItems / itemsPerPage))

    for i, item in ipairs(visibleItems) do
        local craftable = canCraft(item)
        local color = craftable and 0x50FA7B or 0xFF5555
        M.drawText(2, startY + i - 1, item.label .. " (" .. item.count .. ") - " .. (craftable and "Можно" or "Нельзя"), color)
    end

    M.drawText(2, HEIGHT - 7, "Страница: " .. currentPage .. "/" .. maxPages, 0xBD93F9)
    M.drawLogs(1, HEIGHT - 5, M.scrollArray(logs, logOffset, 5), 5)
    M.drawText(2, HEIGHT - 1, "[F1] Назад", 0x50FA7B)
end


local function draw()
    if currentScreen == "main" then
        drawMainMenu()
    elseif currentScreen == "addEdit" then
        drawAddEditScreen()
    elseif currentScreen == "settings" then
        drawSettingsScreen()
    elseif currentScreen == "autoCraft" then
        drawAutoCraftScreen()
    end
end

-- Обработка ввода для добавления/изменения
local function handleAddEditInput(line)
    if not selectedItem then
        -- Поиск существующего элемента
        local foundIndex = nil
        for i, item in ipairs(dataItems) do
            if unicode.lower(item.label) == unicode.lower(line) then
                foundIndex = i
                break
            end
        end

        if foundIndex then
            selectedItem = foundIndex
            inputBuffer = tostring(dataItems[selectedItem].count) -- Предлагаем текущее количество для редактирования
            M.addLog(logs, "INFO: Выбран предмет: "..dataItems[selectedItem].label..". Введите новое количество:", "INFO")
        else
            -- Если не нашли, это новый предмет, спрашиваем количество
            M.addLog(logs, "INFO: Предмет не найден. Введите количество для нового предмета '"..line.."':", "INFO")
            -- Временно храним информацию о новом предмете, пока не получим количество
            selectedItem = {label = line, count = 0, isNew = true}
            inputBuffer = "" -- Очищаем буфер для ввода количества
        end
    else
        -- Если selectedItem уже есть (либо был выбран, либо это новый, для которого вводим количество)
        local amount = tonumber(line)
        if amount and amount >= 0 then
            if selectedItem.isNew then -- Это новый предмет
                selectedItem.count = amount
                -- Нужно найти правильное место для вставки нового предмета в dataItems,
                -- чтобы сохранить сортировку. Для простоты пока вставляем в конец.
                table.insert(dataItems, {label = selectedItem.label, count = amount, name = "new_item_" .. math.random(10000)}) -- Добавим временное имя
                M.addLog(logs, "INFO: Добавлен новый предмет: "..selectedItem.label.." ("..amount..")", "INFO")
            else -- Это существующий предмет, меняем количество
                dataItems[selectedItem].count = amount
                M.addLog(logs, "INFO: Изменено количество для "..dataItems[selectedItem].label.." на "..amount, "INFO")
            end
            saveData()
            reload()
            selectedItem = nil -- Сбрасываем выбранный предмет
            currentScreen = "main" -- Возвращаемся в главное меню
            M.addLog(logs, "INFO: Возврат в главное меню.", "INFO")
        else
            M.addLog(logs, "ERROR: Неверное количество. Введите число.", "ERROR")
        end
    end
end


-------------------- Главный цикл событий --------------------
local function autoCraftLoop()
    while true do
        local _, _, _, mouseX, mouseY, button = event.pull("touch")
        local name, key, char, code = event.pull("key_down")

        -- Сбрасываем состояние наведения курсора перед каждой отрисовкой
        M.buttonHover = nil
        M.buttonHoverY = nil

        if currentScreen == "main" then
            local buttonY = 3
            local buttons = {
                {text = "1. Добавить/Изменить предмет", y = buttonY},
                {text = "2. Запустить автокрафт", y = buttonY + 2},
                {text = "3. Настройки", y = buttonY + 4},
                {text = "4. Выход", y = buttonY + 6},
            }
            if mouseX and mouseY then
                for _, btn in ipairs(buttons) do
                    local btnX = math.floor((WIDTH - unicode.len(btn.text)) / 2)
                    if mouseX >= btnX and mouseX < btnX + unicode.len(btn.text) and mouseY == btn.y then
                        M.buttonHover = btnX
                        M.buttonHoverY = btn.y
                        break
                    end
                end
            end

            if key == 2 or key == 49 then -- 1
                currentScreen = "addEdit"
                reload()
            elseif key == 3 or key == 50 then -- 2
                currentScreen = "autoCraft"
                reload()
            elseif key == 4 or key == 51 then -- 3
                currentScreen = "settings"
            elseif key == 5 or key == 52 then -- 4
                M.addLog(logs, "INFO: Выход из программы.", "INFO")
                break
            elseif mouseX and mouseY and button == 1 then
                if M.buttonHover == math.floor((WIDTH - unicode.len(buttons[1].text)) / 2) and M.buttonHoverY == buttons[1].y then
                    currentScreen = "addEdit"
                    reload()
                elseif M.buttonHover == math.floor((WIDTH - unicode.len(buttons[2].text)) / 2) and M.buttonHoverY == buttons[2].y then
                    currentScreen = "autoCraft"
                    reload()
                elseif M.buttonHover == math.floor((WIDTH - unicode.len(buttons[3].text)) / 2) and M.buttonHoverY == buttons[3].y then
                    currentScreen = "settings"
                elseif M.buttonHover == math.floor((WIDTH - unicode.len(buttons[4].text)) / 2) and M.buttonHoverY == buttons[4].y then
                    M.addLog(logs, "INFO: Выход из программы.", "INFO")
                    break
                end
            end
        elseif currentScreen == "addEdit" then
            local btnText = " [F1] Назад  [F2] Обновить  [F3] Поиск  [Enter] Изменить/Добавить  [Del] Удалить"
            local btnX = 2
            local btnY = HEIGHT - 1
            if mouseX and mouseY then
                if mouseX >= btnX and mouseX < btnX + unicode.len(btnText) and mouseY == btnY then
                    M.buttonHover = btnX
                    M.buttonHoverY = btnY
                end
            end

            if key == 59 then -- F1 (Назад)
                currentScreen = "main"
                inputBuffer = ""
                searchTerm = ""
                selectedItem = nil
                M.addLog(logs, "INFO: Возврат в главное меню.", "INFO")
            elseif key == 60 then -- F2 (Обновить)
                reload()
                M.addLog(logs, "INFO: Список предметов обновлен.", "INFO")
            elseif key == 61 then -- F3 (Поиск)
                searchActive = not searchActive
                inputBuffer = searchTerm -- Заполняем буфер текущим поисковым запросом
                if searchActive then
                    M.addLog(logs, "INFO: Режим поиска активен.", "INFO")
                else
                    M.addLog(logs, "INFO: Режим поиска отключен.", "INFO")
                end
            elseif key == 28 then -- Enter
                if searchActive then
                    searchTerm = inputBuffer
                    filteredItems = M.filterItems(dataItems, searchTerm)
                    currentPage = 1
                    selectedItem = nil
                    searchActive = false
                    inputBuffer = ""
                    M.addLog(logs, "INFO: Применен поиск: '"..searchTerm.."'", "INFO")
                elseif inputBuffer ~= "" then
                    handleAddEditInput(inputBuffer)
                    inputBuffer = ""
                    selectedItem = nil -- Сбрасываем выбранный элемент
                    -- Возврат на главное меню будет осуществлен внутри handleAddEditInput
                else
                    -- Если inputBuffer пуст, и это Enter, но не в поиске, то это "пропуск" или начало редактирования.
                    -- Если выбран элемент, то переходим к его редактированию (вывод текущего значения в буфер)
                    if selectedItem and filteredItems[selectedItem] then
                        inputBuffer = tostring(filteredItems[selectedItem].count)
                        M.addLog(logs, "INFO: Введите новое количество для "..filteredItems[selectedItem].label..":", "INFO")
                    else
                        M.addLog(logs, "INFO: Введите название нового предмета или выберите существующий.", "INFO")
                    end
                end
            elseif key == 42 then -- Backspace
                if searchActive or inputBuffer ~= "" then
                    inputBuffer = unicode.sub(inputBuffer, 1, unicode.len(inputBuffer) - 1)
                end
            elseif key == 211 then -- Delete
                if selectedItem and filteredItems[selectedItem] then
                    local itemLabel = filteredItems[selectedItem].label
                    -- Найти реальный индекс в dataItems, чтобы удалить правильно
                    local realIndex = nil
                    for i, v in ipairs(dataItems) do
                        if v.label == itemLabel then
                            realIndex = i
                            break
                        end
                    end
                    if realIndex then
                        table.remove(dataItems, realIndex)
                        saveData()
                        reload()
                        selectedItem = nil
                        M.addLog(logs, "INFO: Предмет '"..itemLabel.."' удален.", "INFO")
                        currentScreen = "main" -- Возвращаемся в главное меню
                        M.addLog(logs, "INFO: Возврат в главное меню.", "INFO")
                    else
                        M.addLog(logs, "ERROR: Не удалось найти предмет для удаления.", "ERROR")
                    end
                else
                    M.addLog(logs, "WARN: Ничего не выбрано для удаления.", "WARN")
                end
            elseif char and unicode.len(char) == 1 then
                if searchActive or (not searchActive and not selectedItem) or (not searchActive and selectedItem and inputBuffer ~= "") then
                    inputBuffer = inputBuffer .. char
                end
            elseif key == 200 then -- Up arrow
                if selectedItem then
                    selectedItem = math.max(1, selectedItem - 1)
                    if selectedItem < (currentPage - 1) * itemsPerPage + 1 then
                        currentPage = math.max(1, currentPage - 1)
                    end
                elseif #filteredItems > 0 then
                    selectedItem = #filteredItems
                    currentPage = math.max(1, math.ceil(#filteredItems / itemsPerPage))
                end
            elseif key == 208 then -- Down arrow
                if selectedItem then
                    selectedItem = math.min(#filteredItems, selectedItem + 1)
                    if selectedItem > currentPage * itemsPerPage then
                        currentPage = currentPage + 1
                    end
                elseif #filteredItems > 0 then
                    selectedItem = 1
                    currentPage = 1
                end
            elseif key == 203 then -- Left arrow
                if currentPage > 1 then
                    currentPage = currentPage - 1
                    selectedItem = nil
                end
            elseif key == 205 then -- Right arrow
                local maxPages = math.max(1, math.ceil(#filteredItems / itemsPerPage))
                if currentPage < maxPages then
                    currentPage = currentPage + 1
                    selectedItem = nil
                end
            elseif mouseX and mouseY and button == 1 then -- Обработка клика по элементу списка
                local startY = 5 -- Начальная Y-координата списка предметов
                local clickedItemIndex = mouseY - startY + 1
                if clickedItemIndex >= 1 and clickedItemIndex <= itemsPerPage then
                    local globalIndex = (currentPage - 1) * itemsPerPage + clickedItemIndex
                    if globalIndex <= #filteredItems then
                        selectedItem = globalIndex
                        inputBuffer = tostring(filteredItems[selectedItem].count)
                        M.addLog(logs, "INFO: Выбран предмет: "..filteredItems[selectedItem].label, "INFO")
                    end
                end
            end
        elseif currentScreen == "settings" then
            local btnText = "[F1] Назад"
            local btnX = 2
            local btnY = HEIGHT - 1
            if mouseX and mouseY then
                if mouseX >= btnX and mouseX < btnX + unicode.len(btnText) and mouseY == btnY then
                    M.buttonHover = btnX
                    M.buttonHoverY = btnY
                end
            end
            if key == 59 then -- F1 (Назад)
                currentScreen = "main"
                M.addLog(logs, "INFO: Возврат в главное меню.", "INFO")
            end
        elseif currentScreen == "autoCraft" then
            local btnText = "[F1] Назад"
            local btnX = 2
            local btnY = HEIGHT - 1
            if mouseX and mouseY then
                if mouseX >= btnX and mouseX < btnX + unicode.len(btnText) and mouseY == btnY then
                    M.buttonHover = btnX
                    M.buttonHoverY = btnY
                end
            end
            if key == 59 then -- F1 (Назад)
                currentScreen = "main"
                M.addLog(logs, "INFO: Возврат в главное меню.", "INFO")
            elseif mouseX and mouseY and button == 1 then
                local startY = 3
                local clickedItemIndex = mouseY - startY + 1
                local globalIndex = (currentPage - 1) * itemsPerPage + clickedItemIndex
                if globalIndex >= 1 and globalIndex <= #dataItems then
                    local itemToCraft = dataItems[globalIndex]
                    if itemToCraft then
                        M.addLog(logs, "INFO: Попытка крафта: "..itemToCraft.label, "INFO")
                        if canCraft(itemToCraft) then
                            craftItem(itemToCraft, 1) -- Крафтим по 1 штуке для примера
                        else
                            M.addLog(logs, "WARN: Невозможно крафтить "..itemToCraft.label, "WARN")
                        end
                    end
                end
            end
        end

        -- Общая обработка прокрутки логов
        if key == 200 and not searchActive then -- Up arrow for logs
            logOffset = math.min(logOffset + 1, math.max(0, #logs - 5))
        elseif key == 208 and not searchActive then -- Down arrow for logs
            logOffset = math.max(logOffset - 1, 0)
        end

        draw()
    end
end

-------------------- Старт --------------------
checkComponents()
bindGpu()
WIDTH, HEIGHT = g.maxResolution()
g.setResolution(WIDTH, HEIGHT)
M.addLog(logs, "INFO: Программа запущена", "INFO")
local ok, err = pcall(reload)
if not ok then
    M.addLog(logs, "ERROR: Ошибка при начальной загрузке: " .. tostring(err), "ERROR")
    draw()
    while true do os.sleep(1) end
end
draw()
local ok, err = pcall(autoCraftLoop)
if not ok then
    M.addLog(logs, "ERROR: Фатальная ошибка в autoCraftLoop: " .. tostring(err), "ERROR")
    draw()
    while true do os.sleep(1) end
end
