local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode")
local term = require("term")
local computer = require("computer")
local g = component.gpu
local me = component.me_interface
local serialization = require("serialization")

-- Пути и библиотека
local DATA_FILE = "/home/BD.txt"
local LIB_PATH = "/lib/ultimateOC.lua"
local LIB_URL = "https://raw.githubusercontent.com/shify4713/lua/refs/heads/main/ultimateOC.lua"

-- Загрузка или загрузка ultimateOC.lua, если отсутствует
if not fs.exists(LIB_PATH) then
    io.stdout:write("Загрузка ultimateOC.lua...\n")
    local success, err = shell.execute("wget -f " .. LIB_URL .. " " .. LIB_PATH)
    if not success then
        io.stderr:write("Ошибка загрузки ultimateOC.lua: " .. tostring(err) .. "\n")
        os.exit(1)
    end
end
local M = require("ultimateOC") -- Переименовываем M чтобы избежать конфликтов, но ultimateOC уже использует M

-- Проверка доступности компонентов
local function checkComponents()
    if not component.isAvailable("gpu") then
        io.stderr:write("Ошибка: GPU недоступен\n")
        os.exit(1)
    end
    if not component.isAvailable("screen") then
        io.stderr:write("Ошибка: Экран недоступен\n")
        os.exit(1)
    end
    if not component.isAvailable("me_interface") then
        io.stderr:write("Ошибка: ME-интерфейс недоступен\n")
        os.exit(1)
    end
end

-- Привязка GPU к экрану
local function bindGpu()
    local screen = component.list("screen")()
    if not screen then
        io.stderr:write("Ошибка: Не найден экран для привязки GPU\n")
        os.exit(1)
    end
    local success, err = pcall(g.bind, screen)
    if not success then
        io.stderr:write("Ошибка привязки GPU к экрану: " .. tostring(err) .. "\n")
        os.exit(1)
    end
end

-- Глобальные переменные
local WIDTH, HEIGHT
local items = {} -- Загруженные предметы для автокрафта
local logs = {}
local selectedItem = nil -- Выбранный предмет для просмотра/изменения
local currentPage = 1
local itemsPerPage = 10 -- Количество предметов на странице
local logOffset = 0 -- Смещение для прокрутки логов
local buttonHover = nil
local currentMode = "MAIN_MENU" -- "MAIN_MENU", "ADD_ITEM_MODE", "EDIT_ITEM_SELECT_MODE", "EDIT_ITEM_INPUT_MODE", "DELETE_ITEM_SELECT_MODE"
local inputData = {} -- Временные данные для добавления/изменения
local editIndex = nil -- Индекс элемента, который редактируется
local currentInputStep = 1 -- 1: Название, 2: Количество, 3: Размер крафта

-- Цвета
local C_BG = 0x282A36
local C_TEXT = 0xF8F8F2
local C_HIGHLIGHT = 0x6272A4
local C_BUTTON = 0x44475A
local C_BUTTON_HOVER = 0xBD93F9
local C_BUTTON_TEXT = 0xFFFFFF
local C_ERROR = 0xFF5555
local C_INFO = 0x8BE9FD
local C_WARN = 0xFFB86C

-- Функции для работы с данными
local function loadItems()
    items = M.loadf(DATA_FILE) -- Используем M.loadf из ultimateOC
    if not items then items = {} end
    M.addLog(logs, "Загружено " .. #items .. " предметов.", "INFO")
end

local function saveItems()
    local ok, err = pcall(M.savef, DATA_FILE, items) -- Используем M.savef из ultimateOC
    if not ok then
        M.addLog(logs, "Ошибка сохранения BD.txt: " .. tostring(err), "ERROR")
    else
        M.addLog(logs, "BD.txt успешно сохранено.", "INFO")
    end
end

-- Перезагрузка данных и интерфейса
local function reload()
    loadItems()
    currentPage = 1
    selectedItem = nil
    currentMode = "MAIN_MENU"
    inputData = {}
    editIndex = nil
    currentInputStep = 1
end

-- Добавление нового предмета или обновление существующего
local function addItem(name, count, craftSize)
    if not name or name == "" then
        M.addLog(logs, "Название предмета не может быть пустым.", "ERROR")
        return false
    end
    if not tonumber(count) or count <= 0 then
        M.addLog(logs, "Количество поддержания должно быть положительным числом.", "ERROR")
        return false
    end
    if not tonumber(craftSize) or craftSize <= 0 then
        M.addLog(logs, "Размер крафта должен быть положительным числом.", "ERROR")
        return false
    end

    local itemFound = false
    if editIndex then -- Редактирование существующего
        items[editIndex].name = name
        items[editIndex].count = tonumber(count)
        items[editIndex].craftSize = tonumber(craftSize)
        M.addLog(logs, "Предмет '" .. name .. "' обновлен.", "INFO")
        itemFound = true
    else -- Добавление нового
        for i, item in ipairs(items) do
            if unicode.lower(item.name) == unicode.lower(name) then
                items[i].count = tonumber(count)
                items[i].craftSize = tonumber(craftSize)
                M.addLog(logs, "Предмет '" .. name .. "' уже существует. Обновлено.", "INFO")
                itemFound = true
                break
            end
        end
        if not itemFound then
            table.insert(items, { name = name, count = tonumber(count), craftSize = tonumber(craftSize) })
            M.addLog(logs, "Предмет '" .. name .. "' добавлен.", "INFO")
        end
    end
    saveItems()
    return true
end

-- Удаление предмета
local function deleteItem(index)
    if index and items[index] then
        local name = items[index].name
        table.remove(items, index)
        saveItems()
        M.addLog(logs, "Предмет '" .. name .. "' удален.", "INFO")
        if #items == 0 then
            currentPage = 1
        else
            -- Если удалили последний элемент на странице, переходим на предыдущую
            local maxPages = math.max(1, math.ceil(#items / itemsPerPage))
            if currentPage > maxPages then
                currentPage = maxPages
            end
        end
        selectedItem = nil -- Сбросить выбранный элемент после удаления
        return true
    end
    return false
end

-- Функции отрисовки
local function drawMenu()
    g.setBackground(C_BG)
    g.setResolution(WIDTH, HEIGHT)
    g.fill(1, 1, WIDTH, HEIGHT, " ")

    local headerText = "--- Auto-Gemini Craft ---"
    M.drawText(math.floor((WIDTH - unicode.len(headerText)) / 2), 1, headerText, C_TEXT)

    local startY = 3
    local maxPages = math.max(1, math.ceil(#items / itemsPerPage))
    local startIndex = (currentPage - 1) * itemsPerPage + 1
    local endIndex = math.min(startIndex + itemsPerPage - 1, #items)

    M.drawText(1, startY - 1, "Список предметов (Страница " .. currentPage .. "/" .. maxPages .. "):", C_INFO)

    if #items == 0 then
        M.drawText(1, startY, "Нет предметов для автокрафта. Добавьте новые.", C_WARN)
    else
        for i = startIndex, endIndex do
            local item = items[i]
            local displayIndex = i - startIndex + 1
            local line = string.format("%d. %s (Мин: %d, Крафт: %d)", i, item.name, item.count, item.craftSize)
            local itemColor = C_TEXT
            if i == selectedItem then
                itemColor = C_HIGHLIGHT
            end
            M.drawText(2, startY + displayIndex, line, itemColor)
        end
    end

    -- Кнопки
    local buttonY = HEIGHT - 10
    local buttonWidth = 15
    local buttonHeight = 3
    local buttonSpacing = 2

    local currentX = 2

    -- Кнопка "Добавить"
    M.drawButton(g, currentX, buttonY, buttonWidth, buttonHeight, C_BUTTON, C_BUTTON_TEXT, "Добавить", buttonHover == "add")
    if buttonHover == "add" then g.setBackground(C_BUTTON_HOVER) end
    g.set(currentX + 1, buttonY + 1, "Добавить")
    g.setBackground(C_BG)

    currentX = currentX + buttonWidth + buttonSpacing

    -- Кнопка "Изменить" (только если выбран элемент)
    if selectedItem then
        M.drawButton(g, currentX, buttonY, buttonWidth, buttonHeight, C_BUTTON, C_BUTTON_TEXT, "Изменить", buttonHover == "edit")
        if buttonHover == "edit" then g.setBackground(C_BUTTON_HOVER) end
        g.set(currentX + 1, buttonY + 1, "Изменить")
        g.setBackground(C_BG)
    end

    currentX = currentX + buttonWidth + buttonSpacing

    -- Кнопка "Удалить" (только если выбран элемент)
    if selectedItem then
        M.drawButton(g, currentX, buttonY, buttonWidth, buttonHeight, C_BUTTON, C_BUTTON_TEXT, "Удалить", buttonHover == "delete")
        if buttonHover == "delete" then g.setBackground(C_BUTTON_HOVER) end
        g.set(currentX + 1, buttonY + 1, "Удалить")
        g.setBackground(C_BG)
    end

    currentX = currentX + buttonWidth + buttonSpacing

    -- Кнопка "Выйти"
    M.drawButton(g, currentX, buttonY, buttonWidth, buttonHeight, C_BUTTON, C_BUTTON_TEXT, "Выйти", buttonHover == "exit")
    if buttonHover == "exit" then g.setBackground(C_BUTTON_HOVER) end
    g.set(currentX + 1, buttonY + 1, "Выйти")
    g.setBackground(C_BG)

    -- Область логов
    M.drawLogs(1, HEIGHT - 5, logs, 5, C_INFO) -- 5 последних логов
    g.setCursor(1,1) -- Сброс курсора, чтобы не мешал
end

local function drawInputPrompt(prompt, currentText)
    g.setBackground(C_BG)
    g.setResolution(WIDTH, HEIGHT)
    g.fill(1, 1, WIDTH, HEIGHT, " ")

    M.drawText(2, 2, prompt, C_TEXT)
    M.drawText(2, 4, "> " .. currentText, C_HIGHLIGHT)
    g.setCursor(unicode.len("> " .. currentText) + 1, 4)
    g.showCursor(true)

    -- Отображение логов снизу
    M.drawLogs(1, HEIGHT - 5, logs, 5, C_INFO)
end

local function drawEditSelectMenu()
    g.setBackground(C_BG)
    g.setResolution(WIDTH, HEIGHT)
    g.fill(1, 1, WIDTH, HEIGHT, " ")

    local headerText = "--- Выберите предмет для изменения ---"
    M.drawText(math.floor((WIDTH - unicode.len(headerText)) / 2), 1, headerText, C_TEXT)

    local startY = 3
    local maxPages = math.max(1, math.ceil(#items / itemsPerPage))
    local startIndex = (currentPage - 1) * itemsPerPage + 1
    local endIndex = math.min(startIndex + itemsPerPage - 1, #items)

    M.drawText(1, startY - 1, "Список предметов (Страница " .. currentPage .. "/" .. maxPages .. "):", C_INFO)

    if #items == 0 then
        M.drawText(1, startY, "Нет предметов для автокрафта.", C_WARN)
    else
        for i = startIndex, endIndex do
            local item = items[i]
            local displayIndex = i - startIndex + 1
            local line = string.format("%d. %s (Мин: %d, Крафт: %d)", i, item.name, item.count, item.craftSize)
            local itemColor = C_TEXT
            if i == selectedItem then
                itemColor = C_HIGHLIGHT
            end
            M.drawText(2, startY + displayIndex, line, itemColor)
        end
    end

    -- Кнопки навигации по страницам
    local buttonY = HEIGHT - 8
    local buttonWidth = 10
    local buttonHeight = 3
    local currentX = 2

    M.drawButton(g, currentX, buttonY, buttonWidth, buttonHeight, C_BUTTON, C_BUTTON_TEXT, "Назад", buttonHover == "back")
    if buttonHover == "back" then g.setBackground(C_BUTTON_HOVER) end
    g.set(currentX + 1, buttonY + 1, "Назад")
    g.setBackground(C_BG)

    currentX = currentX + buttonWidth + 2

    if currentPage > 1 then
        M.drawButton(g, currentX, buttonY, buttonWidth, buttonHeight, C_BUTTON, C_BUTTON_TEXT, "<<", buttonHover == "prevPage")
        if buttonHover == "prevPage" then g.setBackground(C_BUTTON_HOVER) end
        g.set(currentX + 1, buttonY + 1, "<<")
        g.setBackground(C_BG)
    end
    currentX = currentX + buttonWidth + 2

    if currentPage < maxPages then
        M.drawButton(g, currentX, buttonY, buttonWidth, buttonHeight, C_BUTTON, C_BUTTON_TEXT, ">>", buttonHover == "nextPage")
        if buttonHover == "nextPage" then g.setBackground(C_BUTTON_HOVER) end
        g.set(currentX + 1, buttonY + 1, ">>")
        g.setBackground(C_BG)
    end

    M.drawLogs(1, HEIGHT - 5, logs, 5, C_INFO)
    g.setCursor(1,1)
end

-- Главная функция отрисовки
local function draw()
    if currentMode == "MAIN_MENU" then
        drawMenu()
    elseif currentMode == "ADD_ITEM_MODE" or currentMode == "EDIT_ITEM_INPUT_MODE" then
        local prompt
        local currentText
        if currentInputStep == 1 then
            prompt = "Введите название предмета (Enter для подтверждения):"
            currentText = inputData.name or ""
        elseif currentInputStep == 2 then
            prompt = "Введите желаемое количество поддержания (Enter для подтверждения):"
            currentText = tostring(inputData.count or "")
        elseif currentInputStep == 3 then
            prompt = "Введите количество для крафта за раз (Enter для подтверждения):"
            currentText = tostring(inputData.craftSize or "")
        end
        drawInputPrompt(prompt, currentText)
    elseif currentMode == "EDIT_ITEM_SELECT_MODE" or currentMode == "DELETE_ITEM_SELECT_MODE" then
        drawEditSelectMenu()
    end
end

-- Обработка ввода текста (аналогично pre craft)
local function getTextInput(prompt, initialValue)
    local currentText = initialValue or ""
    g.showCursor(true)
    while true do
        drawInputPrompt(prompt, currentText)
        local _, _, _, char, code, _, _, _ = event.pull("keyboard")
        if code == 28 then -- Enter
            g.showCursor(false)
            return currentText
        elseif code == 42 then -- Backspace
            currentText = unicode.sub(currentText, 1, unicode.len(currentText) - 1)
        elseif char and unicode.len(char) == 1 then -- Одиночный символ
            currentText = currentText .. char
        elseif char and unicode.len(char) > 1 then -- Unicode символ (многобайтовый)
            currentText = currentText .. char
        end
    end
end

-- Основной цикл автокрафта (упрощенный для примера, без логики крафта)
local function autoCraftLoop()
    while true do
        -- Здесь будет логика проверки и запуска крафта
        -- Для демонстрации UI просто приостанавливаемся
        os.sleep(1)
        -- Можно добавить сюда M.addLog для имитации работы
        -- M.addLog(logs, "Проверка ME системы...", "DEBUG")
    end
end

-- Главный цикл обработки событий
event.listen("mouse_click", function(_, x, y, button, _, _, _, _, _, _)
    if currentMode == "MAIN_MENU" then
        -- Обработка кнопок в главном меню
        local buttonY = HEIGHT - 10
        local buttonWidth = 15
        local buttonHeight = 3
        local buttonSpacing = 2

        local currentX = 2

        -- Добавить
        if x >= currentX and x < currentX + buttonWidth and y >= buttonY and y < buttonY + buttonHeight then
            currentMode = "ADD_ITEM_MODE"
            inputData = {}
            editIndex = nil
            currentInputStep = 1
            M.addLog(logs, "Режим: Добавление нового предмета.", "INFO")
        end
        currentX = currentX + buttonWidth + buttonSpacing

        -- Изменить
        if selectedItem and x >= currentX and x < currentX + buttonWidth and y >= buttonY and y < buttonY + buttonHeight then
            currentMode = "EDIT_ITEM_INPUT_MODE"
            editIndex = selectedItem
            inputData = {
                name = items[selectedItem].name,
                count = items[selectedItem].count,
                craftSize = items[selectedItem].craftSize
            }
            currentInputStep = 1 -- Начинаем с названия
            M.addLog(logs, "Режим: Изменение предмета '" .. items[selectedItem].name .. "'.", "INFO")
        end
        currentX = currentX + buttonWidth + buttonSpacing

        -- Удалить
        if selectedItem and x >= currentX and x < currentX + buttonWidth and y >= buttonY and y < buttonY + buttonHeight then
            if deleteItem(selectedItem) then
                selectedItem = nil -- Сбросить выбранный элемент после удаления
                currentMode = "MAIN_MENU" -- Вернуться в главное меню
            else
                M.addLog(logs, "Не удалось удалить предмет.", "ERROR")
            end
        end
        currentX = currentX + buttonWidth + buttonSpacing

        -- Выйти
        if x >= currentX and x < currentX + buttonWidth and y >= buttonY and y < buttonY + buttonHeight then
            computer.shutdown()
        end

        -- Выбор предмета из списка
        local startY = 4
        local startIndex = (currentPage - 1) * itemsPerPage + 1
        for i = 1, itemsPerPage do
            local itemIndex = startIndex + i - 1
            if itemIndex <= #items then
                local itemY = startY + i
                if x >= 2 and x < WIDTH - 1 and y == itemY then
                    selectedItem = itemIndex
                    break
                end
            end
        end

    elseif currentMode == "EDIT_ITEM_SELECT_MODE" then
        -- Выбор предмета из списка для изменения
        local startY = 4
        local startIndex = (currentPage - 1) * itemsPerPage + 1
        for i = 1, itemsPerPage do
            local itemIndex = startIndex + i - 1
            if itemIndex <= #items then
                local itemY = startY + i
                if x >= 2 and x < WIDTH - 1 and y == itemY then
                    selectedItem = itemIndex
                    currentMode = "EDIT_ITEM_INPUT_MODE"
                    editIndex = selectedItem
                    inputData = {
                        name = items[selectedItem].name,
                        count = items[selectedItem].count,
                        craftSize = items[selectedItem].craftSize
                    }
                    currentInputStep = 1
                    M.addLog(logs, "Выбран предмет для изменения: '" .. items[selectedItem].name .. "'", "INFO")
                    break
                end
            end
        end
        -- Кнопки навигации
        local buttonY = HEIGHT - 8
        local buttonWidth = 10
        local buttonHeight = 3
        local currentX = 2

        -- Назад
        if x >= currentX and x < currentX + buttonWidth and y >= buttonY and y < buttonY + buttonHeight then
            currentMode = "MAIN_MENU"
            selectedItem = nil
            M.addLog(logs, "Возврат в главное меню.", "INFO")
        end
        currentX = currentX + buttonWidth + 2
        -- Предыдущая страница
        if currentPage > 1 and x >= currentX and x < currentX + buttonWidth and y >= buttonY and y < buttonY + buttonHeight then
            currentPage = currentPage - 1
            selectedItem = nil
        end
        currentX = currentX + buttonWidth + 2
        -- Следующая страница
        local maxPages = math.max(1, math.ceil(#items / itemsPerPage))
        if currentPage < maxPages and x >= currentX and x < currentX + buttonWidth and y >= buttonY and y < buttonY + buttonHeight then
            currentPage = currentPage + 1
            selectedItem = nil
        end

    end -- End of currentMode checks
    draw()
end)

event.listen("mouse_drag", function(_, x, y, button, _, _, _, _, _, _)
    buttonHover = nil
    if currentMode == "MAIN_MENU" then
        local buttonY = HEIGHT - 10
        local buttonWidth = 15
        local buttonHeight = 3
        local buttonSpacing = 2
        local currentX = 2

        if x >= currentX and x < currentX + buttonWidth and y >= buttonY and y < buttonY + buttonHeight then buttonHover = "add" end
        currentX = currentX + buttonWidth + buttonSpacing
        if selectedItem and x >= currentX and x < currentX + buttonWidth and y >= buttonY and y < buttonY + buttonHeight then buttonHover = "edit" end
        currentX = currentX + buttonWidth + buttonSpacing
        if selectedItem and x >= currentX and x < currentX + buttonWidth and y >= buttonY and y < buttonY + buttonHeight then buttonHover = "delete" end
        currentX = currentX + buttonWidth + buttonSpacing
        if x >= currentX and x < currentX + buttonWidth and y >= buttonY and y < buttonY + buttonHeight then buttonHover = "exit" end
    elseif currentMode == "EDIT_ITEM_SELECT_MODE" then
        local buttonY = HEIGHT - 8
        local buttonWidth = 10
        local buttonHeight = 3
        local currentX = 2

        if x >= currentX and x < currentX + buttonWidth and y >= buttonY and y < buttonY + buttonHeight then buttonHover = "back" end
        currentX = currentX + buttonWidth + 2
        local maxPages = math.max(1, math.ceil(#items / itemsPerPage))
        if currentPage > 1 and x >= currentX and x < currentX + buttonWidth and y >= buttonY and y < buttonY + buttonHeight then buttonHover = "prevPage" end
        currentX = currentX + buttonWidth + 2
        if currentPage < maxPages and x >= currentX and x < currentX + buttonWidth and y >= buttonY and y < buttonY + buttonHeight then buttonHover = "nextPage" end
    end
    draw()
end)

event.listen("mouse_up", function(_, x, y, button, _, _, _, _, _, _)
    buttonHover = nil
    draw()
end)

event.listen("key_down", function(_, _, key, _, _, _, _, _, arg)
    if currentMode == "ADD_ITEM_MODE" or currentMode == "EDIT_ITEM_INPUT_MODE" then
        local char = arg.char
        if key == 28 then -- Enter
            if currentInputStep == 1 then
                inputData.name = getTextInput("Введите название предмета (Enter для подтверждения):", inputData.name)
                currentInputStep = 2
            elseif currentInputStep == 2 then
                local countStr = getTextInput("Введите желаемое количество поддержания (Enter для подтверждения):", tostring(inputData.count or ""))
                inputData.count = tonumber(countStr)
                if not inputData.count or inputData.count <= 0 then
                    M.addLog(logs, "Ошибка: Количество должно быть положительным числом. Повторите ввод.", "ERROR")
                    inputData.count = nil -- Сбросить, чтобы запросить заново
                    return -- Остаться на этом шаге
                end
                currentInputStep = 3
            elseif currentInputStep == 3 then
                local craftSizeStr = getTextInput("Введите количество для крафта за раз (Enter для подтверждения):", tostring(inputData.craftSize or ""))
                inputData.craftSize = tonumber(craftSizeStr)
                if not inputData.craftSize or inputData.craftSize <= 0 then
                    M.addLog(logs, "Ошибка: Размер крафта должен быть положительным числом. Повторите ввод.", "ERROR")
                    inputData.craftSize = nil -- Сбросить, чтобы запросить заново
                    return -- Остаться на этом шаге
                end

                if addItem(inputData.name, inputData.count, inputData.craftSize) then
                    currentMode = "MAIN_MENU"
                    inputData = {}
                    editIndex = nil
                    currentInputStep = 1
                    selectedItem = nil -- Сбросить выбранный элемент
                else
                    M.addLog(logs, "Не удалось добавить/обновить предмет. Проверьте введенные данные.", "ERROR")
                    -- Возможно, здесь нужно вернуться на предыдущий шаг или оставить на текущем
                    -- Для простоты, оставим на текущем шаге, пока не введут корректно
                end
            end
        elseif key == 42 then -- Backspace
            if currentInputStep == 1 then
                inputData.name = unicode.sub(inputData.name or "", 1, unicode.len(inputData.name or "") - 1)
            elseif currentInputStep == 2 then
                inputData.count = unicode.sub(tostring(inputData.count or ""), 1, unicode.len(tostring(inputData.count or "")) - 1)
            elseif currentInputStep == 3 then
                inputData.craftSize = unicode.sub(tostring(inputData.craftSize or ""), 1, unicode.len(tostring(inputData.craftSize or "")) - 1)
            end
        elseif char and unicode.len(char) >= 1 then -- Ввод символов (включая Unicode)
            if currentInputStep == 1 then
                inputData.name = (inputData.name or "") .. char
            elseif currentInputStep == 2 then
                local num = tonumber((inputData.count or "") .. char)
                if num ~= nil then
                    inputData.count = num
                end
            elseif currentInputStep == 3 then
                local num = tonumber((inputData.craftSize or "") .. char)
                if num ~= nil then
                    inputData.craftSize = num
                end
            end
        end
    elseif currentMode == "MAIN_MENU" or currentMode == "EDIT_ITEM_SELECT_MODE" then
        if key == 200 then -- Стрелка Вверх
            if selectedItem then
                selectedItem = math.max(1, selectedItem - 1)
                -- Переход на предыдущую страницу, если выбранный элемент ушел за пределы
                if selectedItem < (currentPage - 1) * itemsPerPage + 1 then
                    currentPage = math.max(1, currentPage - 1)
                end
            elseif #items > 0 then
                selectedItem = math.min(#items, (currentPage - 1) * itemsPerPage + 1) -- Выбираем первый элемент на текущей странице, если ничего не выбрано
            end
        elseif key == 208 then -- Стрелка Вниз
            if selectedItem then
                selectedItem = math.min(#items, selectedItem + 1)
                -- Переход на следующую страницу, если выбранный элемент ушел за пределы
                if selectedItem > currentPage * itemsPerPage then
                    currentPage = math.min(math.max(1, math.ceil(#items / itemsPerPage)), currentPage + 1)
                end
            elseif #items > 0 then
                selectedItem = math.min(#items, (currentPage - 1) * itemsPerPage + 1) -- Выбираем первый элемент на текущей странице, если ничего не выбрано
            end
        elseif key == 203 then -- Стрелка Влево (смена страницы)
            if currentPage > 1 then
                currentPage = currentPage - 1
                selectedItem = nil
            end
        elseif key == 205 then -- Стрелка Вправо (смена страницы)
            local maxPages = math.max(1, math.ceil(#items / itemsPerPage))
            if currentPage < maxPages then
                currentPage = currentPage + 1
                selectedItem = nil
            end
        elseif key == 200 and arg.shift then -- Shift + Up для логов (прокрутка вверх)
            logOffset = math.min(logOffset + 1, #logs - 5)
        elseif key == 208 and arg.shift then -- Shift + Down для логов (прокрутка вниз)
            logOffset = math.max(logOffset - 1, 0)
        end
    end
    buttonHover = nil
    draw()
end)


-------------------- Старт --------------------
checkComponents()
bindGpu()
WIDTH, HEIGHT = g.getResolution()
g.setResolution(WIDTH, HEIGHT)
M.addLog(logs, "INFO: Программа запущена", "INFO")
local ok, err = pcall(reload)
if not ok then
    M.addLog(logs, "ERROR: Ошибка при начальной загрузке: " .. tostring(err), "ERROR")
    draw()
    while true do os.sleep(1) end
end
draw()
local ok, err = pcall(autoCraftLoop)
if not ok then
    M.addLog(logs, "ERROR: Фатальная ошибка в autoCraftLoop: " .. tostring(err), "ERROR")
    draw()
    while true do os.sleep(1) end
end
