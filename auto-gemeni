local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode")
local term = require("term")
local computer = require("computer")
local g = component.gpu
local me = component.me_interface
local serialization = require("serialization")

-- Пути и библиотека
local DATA_FILE = "/home/BD.txt"
local LIB_PATH = "/lib/ultimateOC.lua"
local LIB_URL = "https://raw.githubusercontent.com/shify4713/lua/refs/heads/main/ultimateOC.lua"

-- Загрузка или скачивание ultimateOC.lua
if not fs.exists(LIB_PATH) then
    io.write("Загрузка ultimateOC.lua...\n")
    local success, err = shell.execute("wget", LIB_URL, LIB_PATH)
    if not success then
        io.stderr:write("Ошибка загрузки ultimateOC.lua: " .. tostring(err) .. "\n")
        os.exit(1)
    end
end
local M = require("ultimateOC") -- Загружаем библиотеку

-- Проверка доступности компонентов
local function checkComponents()
    if not component.isAvailable("gpu") then
        io.stderr:write("Ошибка: GPU недоступен\n")
        os.exit(1)
    end
    if not component.isAvailable("screen") then
        io.stderr:write("Ошибка: Экран недоступен\n")
        os.exit(1)
    end
    if not component.isAvailable("me_interface") then
        io.stderr:write("Ошибка: ME-интерфейс недоступен\n")
        os.exit(1)
    end
end

-- Привязка GPU к экрану
local function bindGpu()
    local screen = component.list("screen")()
    if not screen then
        io.stderr:write("Ошибка: Не найден экран для привязки GPU\n")
        os.exit(1)
    end
    local success, err = pcall(g.bind, screen)
    if not success then
        io.stderr:write("Ошибка при привязке GPU к экрану: " .. tostring(err) .. "\n")
        os.exit(1)
    end
end

-- Глобальные переменные
local WIDTH, HEIGHT
local running = true
local logs = {}
local craftList = {}
local selectedItem = nil
local currentPage = 1
local logOffset = 0 -- Для прокрутки логов
local inputMode = nil -- 'addName', 'addCount', 'addCraftSize', 'changeName', 'changeCount', 'changeCraftSize'
local currentInput = ""
local inputPrompt = ""

-- Цвета
local COLOR_BACKGROUND = 0x282A36
local COLOR_FOREGROUND = 0xF8F8F2
local COLOR_ACCENT = 0x8BE9FD
local COLOR_ERROR = 0xFF5555
local COLOR_WARNING = 0xFFB86C
local COLOR_INFO = 0x50FA7B

-- Загрузка/Сохранение данных
local function loadData()
    craftList = M.loadf(DATA_FILE)
    if type(craftList) ~= "table" then
        craftList = {}
        M.addLog(logs, "Обнаружены поврежденные данные или пустой файл. Создан новый пустой список крафтов.", "WARN")
    else
        -- Убедимся, что каждый элемент имеет все необходимые поля
        for k, v in pairs(craftList) do
            v.craftSize = v.craftSize or 1
            v.minCount = v.minCount or 1
        end
    end
end

local function saveData()
    local ok, err = pcall(M.savef, DATA_FILE, craftList)
    if not ok then
        M.addLog(logs, "Ошибка сохранения данных: " .. tostring(err), "ERROR")
    end
end

-- Добавление лога
local function addLog(text, lvl)
    M.addLog(logs, text, lvl)
end

-- Обновление элементов на экране
local function draw()
    g.setBackground(COLOR_BACKGROUND)
    g.setForeground(COLOR_FOREGROUND)
    g.clear()

    -- Заголовок
    M.drawText(2, 1, "Auto-Gemeni Crafting Interface", COLOR_ACCENT)

    -- Список крафтов
    M.drawText(2, 3, "Список Крафтов:", COLOR_ACCENT)
    local itemsPerPage = math.floor((HEIGHT - 10) / 2) -- 2 строки на элемент
    local startIndex = (currentPage - 1) * itemsPerPage + 1
    local endIndex = math.min(startIndex + itemsPerPage - 1, #craftList)

    local displayIndex = 0
    local sortedKeys = {}
    for k in pairs(craftList) do table.insert(sortedKeys, k) end
    table.sort(sortedKeys) -- Сортируем для стабильного отображения

    for i = startIndex, endIndex do
        local key = sortedKeys[i]
        local item = craftList[key]
        if item then
            local yOffset = 4 + (displayIndex * 2)
            local isSelected = (selectedItem and selectedItem.name == key)

            local itemText = string.format("%s: %d (Крафт: %d)", key, item.minCount, item.craftSize)
            local itemColor = isSelected and COLOR_INFO or COLOR_FOREGROUND
            local bgColor = isSelected and 0x44475A or COLOR_BACKGROUND -- Цвет фона для выбранного элемента

            M.drawText(2, yOffset, itemText, itemColor, bgColor)
            displayIndex = displayIndex + 1
        end
    end

    -- Навигация по страницам
    local maxPages = math.max(1, math.ceil(#craftList / itemsPerPage))
    local pageInfo = string.format("Страница %d/%d", currentPage, maxPages)
    M.drawText(WIDTH - #pageInfo - 1, 1, pageInfo, COLOR_ACCENT)

    -- Логи
    M.drawText(2, HEIGHT - 7, "Логи:", COLOR_ACCENT)
    M.drawLogs(2, HEIGHT - 5, logs, 5, COLOR_FOREGROUND, logOffset)

    -- Кнопки и поля ввода
    local buttonY = 3
    local buttonX = math.floor(WIDTH / 2) + 5
    local buttonWidth = 20
    local buttonHeight = 1

    -- Кнопки действий
    M.drawButton(buttonX, buttonY, buttonWidth, buttonHeight, "Добавить предмет", "add_item", COLOR_ACCENT, COLOR_BACKGROUND)
    buttonY = buttonY + 2
    M.drawButton(buttonX, buttonY, buttonWidth, buttonHeight, "Изменить название", "change_name", COLOR_ACCENT, COLOR_BACKGROUND, selectedItem == nil)
    buttonY = buttonY + 2
    M.drawButton(buttonX, buttonY, buttonWidth, buttonHeight, "Изменить количество", "change_count", COLOR_ACCENT, COLOR_BACKGROUND, selectedItem == nil)
    buttonY = buttonY + 2
    M.drawButton(buttonX, buttonY, buttonWidth, buttonHeight, "Изменить размер крафта", "change_craft_size", COLOR_ACCENT, COLOR_BACKGROUND, selectedItem == nil)
    buttonY = buttonY + 2
    M.drawButton(buttonX, buttonY, buttonWidth, buttonHeight, "Удалить предмет", "remove_item", COLOR_ACCENT, COLOR_BACKGROUND, selectedItem == nil)
    buttonY = buttonY + 2
    M.drawButton(buttonX, buttonY, buttonWidth, buttonHeight, "Отменить", "cancel_input", COLOR_WARNING, COLOR_BACKGROUND, inputMode == nil)
    buttonY = buttonY + 2
    M.drawButton(buttonX, buttonY, buttonWidth, buttonHeight, "Выход", "exit", COLOR_ERROR, COLOR_BACKGROUND)

    -- Поле ввода
    if inputMode then
        local inputPromptY = HEIGHT - 8
        local inputFieldY = HEIGHT - 9
        local inputFieldX = 2
        local inputFieldWidth = WIDTH - 4

        M.drawText(inputFieldX, inputFieldY, inputPrompt, COLOR_ACCENT)
        g.setBackground(0x44475A)
        g.setForeground(COLOR_FOREGROUND)
        g.set(inputFieldX, inputFieldY + 1, string.rep(" ", inputFieldWidth)) -- Clear previous input
        M.drawText(inputFieldX, inputFieldY + 1, currentInput, COLOR_FOREGROUND)
    end
end

-- Функция для обработки добавления нового элемента
local function addNewItem(name, count, craftSize)
    if craftList[name] then
        addLog(string.format("Предмет '%s' уже существует в списке. Используйте 'Изменить'.", name), "WARN")
        return
    end
    craftList[name] = { minCount = tonumber(count) or 1, craftSize = tonumber(craftSize) or 1 }
    saveData()
    addLog(string.format("Добавлен предмет: %s (Мин. кол-во: %d, Размер крафта: %d)", name, craftList[name].minCount, craftList[name].craftSize), "INFO")
    selectedItem = { name = name }
end

-- Функция для обработки изменения существующего элемента
local function changeItem(key, field, newValue)
    if not craftList[key] then
        addLog(string.format("Предмет '%s' не найден.", key), "ERROR")
        return
    end

    local oldValue
    if field == "name" then
        if craftList[newValue] then
            addLog(string.format("Предмет с названием '%s' уже существует. Выберите другое название.", newValue), "WARN")
            return
        end
        oldValue = key
        local itemData = craftList[key]
        craftList[newValue] = itemData
        craftList[key] = nil
        selectedItem.name = newValue -- Обновляем выбранный элемент
        addLog(string.format("Название предмета '%s' изменено на '%s'.", oldValue, newValue), "INFO")
    elseif field == "count" then
        oldValue = craftList[key].minCount
        craftList[key].minCount = tonumber(newValue) or craftList[key].minCount
        addLog(string.format("Количество поддержания для '%s' изменено с %d на %d.", key, oldValue, craftList[key].minCount), "INFO")
    elseif field == "craftSize" then
        oldValue = craftList[key].craftSize
        craftList[key].craftSize = tonumber(newValue) or craftList[key].craftSize
        addLog(string.format("Размер крафта для '%s' изменен с %d на %d.", key, oldValue, craftList[key].craftSize), "INFO")
    end
    saveData()
end

-- Функция для удаления элемента
local function removeItem(key)
    if not craftList[key] then
        addLog(string.format("Предмет '%s' не найден.", key), "ERROR")
        return
    end
    craftList[key] = nil
    saveData()
    addLog(string.format("Предмет '%s' удален.", key), "INFO")
    selectedItem = nil
    -- После удаления возможно нужно пересчитать страницы или сбросить selectedItem
    local itemsPerPage = math.floor((HEIGHT - 10) / 2)
    local maxPages = math.max(1, math.ceil(#craftList / itemsPerPage))
    if currentPage > maxPages then
        currentPage = maxPages
    end
end

-- Главный цикл автокрафта (заглушка, оставлена как есть из исходного файла)
local function autoCraftLoop()
    while running do
        -- Здесь будет основная логика автокрафта
        -- Например, проверка ME-интерфейса и создание крафтов
        -- Для демонстрации пока просто выводим сообщение
        -- addLog("Выполняется проверка крафтов...", "DEBUG")
        os.sleep(5) -- Пауза для снижения нагрузки
    end
end

-- Инициализация GPU и разрешение
local function bindGpuAndSetResolution()
    bindGpu()
    WIDTH, HEIGHT = g.getResolution()
    g.setResolution(WIDTH, HEIGHT)
    g.setBackground(COLOR_BACKGROUND)
    g.setForeground(COLOR_FOREGROUND)
    g.clear()
end

-- Основная функция обработки событий
event.listen("mouse_click", function(_, x, y, button, _, _, player)
    -- Обработка кликов по кнопкам
    local action = M.checkButton(x, y)
    if action then
        if action == "add_item" then
            inputMode = 'addName'
            currentInput = ""
            inputPrompt = "Введите название нового предмета:"
            addLog("Режим добавления: Введите название предмета.", "INFO")
        elseif action == "change_name" and selectedItem then
            inputMode = 'changeName'
            currentInput = selectedItem.name
            inputPrompt = string.format("Изменить название для '%s' на:", selectedItem.name)
            addLog(string.format("Режим изменения названия для '%s'.", selectedItem.name), "INFO")
        elseif action == "change_count" and selectedItem then
            inputMode = 'changeCount'
            currentInput = tostring(craftList[selectedItem.name].minCount)
            inputPrompt = string.format("Изменить мин. количество для '%s' на:", selectedItem.name)
            addLog(string.format("Режим изменения мин. количества для '%s'.", selectedItem.name), "INFO")
        elseif action == "change_craft_size" and selectedItem then
            inputMode = 'changeCraftSize'
            currentInput = tostring(craftList[selectedItem.name].craftSize)
            inputPrompt = string.format("Изменить размер крафта для '%s' на:", selectedItem.name)
            addLog(string.format("Режим изменения размера крафта для '%s'.", selectedItem.name), "INFO")
        elseif action == "remove_item" and selectedItem then
            local confirm = M.showConfirmDialog(g, WIDTH, HEIGHT, "Удалить " .. selectedItem.name .. "?", "Да", "Нет")
            if confirm then
                removeItem(selectedItem.name)
            else
                addLog("Удаление отменено.", "INFO")
            end
        elseif action == "cancel_input" then
            inputMode = nil
            currentInput = ""
            inputPrompt = ""
            addLog("Режим ввода отменен.", "INFO")
        elseif action == "exit" then
            addLog("Завершение работы программы...", "INFO")
            running = false
        end
        draw()
        return -- Обработали клик по кнопке, выходим
    end

    -- Выбор элемента списка
    local itemsPerPage = math.floor((HEIGHT - 10) / 2)
    local startIndex = (currentPage - 1) * itemsPerPage + 1
    local displayIndex = 0
    local sortedKeys = {}
    for k in pairs(craftList) do table.insert(sortedKeys, k) end
    table.sort(sortedKeys)

    for i = startIndex, math.min(startIndex + itemsPerPage - 1, #craftList) do
        local key = sortedKeys[i]
        if key then
            local yOffset = 4 + (displayIndex * 2)
            if y == yOffset or y == yOffset + 1 then -- Если клик на строке элемента
                if selectedItem and selectedItem.name == key then
                    selectedItem = nil -- Снять выделение, если кликнули по тому же
                else
                    selectedItem = { name = key }
                end
                draw()
                return
            end
            displayIndex = displayIndex + 1
        end
    end
end)

event.listen("key_down", function(_, key, _, arg)
    if inputMode then
        if key == 28 then -- Enter
            if inputMode == 'addName' then
                if currentInput ~= "" then
                    local newItemName = currentInput
                    inputMode = 'addCount'
                    currentInput = "1" -- Дефолтное значение
                    inputPrompt = string.format("Введите мин. количество для '%s':", newItemName)
                    addLog(string.format("Введите мин. количество для '%s'.", newItemName), "INFO")
                else
                    addLog("Название предмета не может быть пустым.", "WARN")
                end
            elseif inputMode == 'addCount' then
                local count = tonumber(currentInput)
                if count and count > 0 then
                    local newItemName = inputPrompt:match("для '(.-)'") -- Извлекаем имя из промпта
                    inputMode = 'addCraftSize'
                    currentInput = "1" -- Дефолтное значение
                    inputPrompt = string.format("Введите размер крафта для '%s':", newItemName)
                    addLog(string.format("Введите размер крафта для '%s'.", newItemName), "INFO")
                else
                    addLog("Количество должно быть положительным числом.", "WARN")
                end
            elseif inputMode == 'addCraftSize' then
                local craftSize = tonumber(currentInput)
                if craftSize and craftSize > 0 then
                    local newItemName = inputPrompt:match("для '(.-)'") -- Извлекаем имя из промпта
                    addNewItem(newItemName, inputPrompt:match("мин. количество для '(.-)'") and tonumber(inputPrompt:match("мин. количество для '(.-)'")) or 1, craftSize) -- hacky way to get previous count. Needs better state management
                    inputMode = nil
                    currentInput = ""
                    inputPrompt = ""
                else
                    addLog("Размер крафта должен быть положительным числом.", "WARN")
                end
            elseif inputMode == 'changeName' and selectedItem then
                if currentInput ~= "" then
                    changeItem(selectedItem.name, "name", currentInput)
                    inputMode = nil
                    currentInput = ""
                    inputPrompt = ""
                else
                    addLog("Название предмета не может быть пустым.", "WARN")
                end
            elseif inputMode == 'changeCount' and selectedItem then
                local count = tonumber(currentInput)
                if count and count > 0 then
                    changeItem(selectedItem.name, "count", count)
                    inputMode = nil
                    currentInput = ""
                    inputPrompt = ""
                else
                    addLog("Количество должно быть положительным числом.", "WARN")
                end
            elseif inputMode == 'changeCraftSize' and selectedItem then
                local craftSize = tonumber(currentInput)
                if craftSize and craftSize > 0 then
                    changeItem(selectedItem.name, "craftSize", craftSize)
                    inputMode = nil
                    currentInput = ""
                    inputPrompt = ""
                else
                    addLog("Размер крафта должен быть положительным числом.", "WARN")
                end
            end
        elseif key == 14 then -- Backspace
            currentInput = unicode.sub(currentInput, 1, unicode.len(currentInput) - 1)
        elseif key == 42 then -- Tab
            -- Игнорируем Tab в режиме ввода
        elseif key == 1 then -- Escape
            inputMode = nil
            currentInput = ""
            inputPrompt = ""
            addLog("Ввод отменен пользователем.", "INFO")
        else -- Обычный ввод символов
            local char = term.getChar(key, arg.shift)
            if char then
                currentInput = currentInput .. char
            end
        end
        draw()
    else -- Режим навигации (без активного ввода)
        if key == 200 then -- Стрелка Вверх
            local itemsPerPage = math.floor((HEIGHT - 10) / 2)
            local sortedKeys = {}
            for k in pairs(craftList) do table.insert(sortedKeys, k) end
            table.sort(sortedKeys)

            if selectedItem then
                local currentIndex = 0
                for i, k in ipairs(sortedKeys) do
                    if k == selectedItem.name then
                        currentIndex = i
                        break
                    end
                end
                if currentIndex > 1 then
                    selectedItem = { name = sortedKeys[currentIndex - 1] }
                    -- Переход на предыдущую страницу, если выбранный элемент уходит за видимые пределы
                    local newIndexInPage = (currentIndex - 1) - ((currentPage - 1) * itemsPerPage)
                    if newIndexInPage < 1 then
                        currentPage = math.max(1, currentPage - 1)
                    end
                end
            elseif #craftList > 0 then
                selectedItem = { name = sortedKeys[1] } -- Выбираем первый элемент, если ничего не выбрано
            end
        elseif key == 208 then -- Стрелка Вниз
            local itemsPerPage = math.floor((HEIGHT - 10) / 2)
            local sortedKeys = {}
            for k in pairs(craftList) do table.insert(sortedKeys, k) end
            table.sort(sortedKeys)

            if selectedItem then
                local currentIndex = 0
                for i, k in ipairs(sortedKeys) do
                    if k == selectedItem.name then
                        currentIndex = i
                        break
                    end
                end
                if currentIndex < #craftList then
                    selectedItem = { name = sortedKeys[currentIndex + 1] }
                    -- Переход на следующую страницу, если выбранный элемент уходит за видимые пределы
                    local newIndexInPage = (currentIndex) - ((currentPage - 1) * itemsPerPage)
                    if newIndexInPage >= itemsPerPage then
                        currentPage = math.min(math.ceil(#craftList / itemsPerPage), currentPage + 1)
                    end
                end
            elseif #craftList > 0 then
                selectedItem = { name = sortedKeys[1] } -- Выбираем первый элемент, если ничего не выбрано
            end
        elseif key == 203 then -- Стрелка Влево (смена страницы)
            if currentPage > 1 then
                currentPage = currentPage - 1
                selectedItem = nil
            end
        elseif key == 205 then -- Стрелка Вправо (смена страницы)
            local itemsPerPage = math.floor((HEIGHT - 10) / 2)
            local maxPages = math.max(1, math.ceil(#craftList / itemsPerPage))
            if currentPage < maxPages then
                currentPage = currentPage + 1
                selectedItem = nil
            end
        elseif key == 200 and arg.shift then -- Shift + Up для логов (прокрутка вверх)
            logOffset = math.min(logOffset + 1, #logs - 5)
        elseif key == 208 and arg.shift then -- Shift + Down для логов (прокрутка вниз)
            logOffset = math.max(logOffset - 1, 0)
        end
    end
    draw()
end)

-- Проверка компонентов и инициализация
checkComponents()
bindGpuAndSetResolution()
M.addLog(logs, "INFO: Программа запущена", "INFO")

-- Начальная загрузка данных
local ok, err = pcall(loadData)
if not ok then
    addLog("ERROR: Ошибка при начальной загрузке: " .. tostring(err), "ERROR")
    draw()
    while true do os.sleep(1) end -- Оставить программу работающей для просмотра логов
end
draw()

-- Запуск основного цикла автокрафта в отдельном потоке (если есть luacurl, иначе в основном)
local autoCraftThread = computer.createThread(autoCraftLoop)

-- Главный цикл обработки событий UI
while running do
    local _, _, _, _, _, _, _, _, mouseX, mouseY = event.pull("touch", nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, true) -- Получаем позицию мыши для M.checkButtonHover
    M.checkButtonHover(mouseX, mouseY)
    draw()
    os.sleep(0.05) -- Небольшая пауза для снижения нагрузки на процессор
end

M.addLog(logs, "Программа завершена.", "INFO")
g.clear() -- Очистить экран при выходе
g.setResolution(WIDTH, HEIGHT) -- Сброс разрешения, если оно было изменено
g.set(1,1, "Программа завершена. Проверьте логи.")
