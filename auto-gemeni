local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode")
local term = require("term")
local computer = require("computer")
local g = component.gpu
local me = component.me_interface

-- Пути и библиотека
local DATA_FILE = "/home/BD.txt"
local LIB_PATH = "/lib/ultimateOC.lua"
local LIB_URL = "https://raw.githubusercontent.com/shify4713/lua/refs/heads/main/ultimateOC.lua"

-- Проверка доступности компонентов
local function checkComponents()
    if not component.isAvailable("gpu") then
        io.stderr:write("Ошибка: GPU недоступен\n")
        os.exit(1)
    end
    if not component.isAvailable("screen") then
        io.stderr:write("Ошибка: Экран недоступен\n")
        os.exit(1)
    end
    if not component.isAvailable("me_interface") then
        io.stderr:write("Ошибка: ME-интерфейс недоступен\n")
        os.exit(1)
    end
end

-- Привязка GPU к экрану
local function bindGpu()
    local screen = component.list("screen")()
    if not screen then
        io.stderr:write("Ошибка: Не найден экран для привязки GPU\n")
        os.exit(1)
    end
    local success, err = pcall(g.bind, screen)
    if not success then
        io.stderr:write("Ошибка при привязке GPU к экрану: " .. tostring(err) .. "\n")
        os.exit(1)
    end
end

-- Загрузка или скачивание библиотеки ultimateOC.lua
local function loadOrCreateLib()
    if not fs.exists(LIB_PATH) then
        addLog(logs, "INFO: Библиотека ultimateOC.lua не найдена. Скачивание...", "INFO")
        local ok, err = shell.execute("wget " .. LIB_URL .. " " .. LIB_PATH)
        if not ok then
            addLog(logs, "ERROR: Не удалось скачать библиотеку ultimateOC.lua: " .. tostring(err), "ERROR")
            os.exit(1)
        end
        addLog(logs, "INFO: Библиотека ultimateOC.lua успешно скачана.", "INFO")
    end
    _G.ultimateOC = require("ultimateOC")
end

-- Глобальные переменные
local WIDTH, HEIGHT
local craftItems = {}
local currentMode = "main" -- "main", "add_item", "craft_list"
local currentPage = 1
local selectedItem = nil
local logs = {}
local logOffset = 0 -- Для прокрутки логов
local buttonHover = nil
local activeInput = nil -- "name", "count", "craftSize"
local inputValues = {
    name = "",
    count = "",
    craftSize = ""
}

-- Инициализация логирования (раньше, чтобы сообщения о загрузке были видны)
-- Используем ultimateOC.addLog после того, как ultimateOC будет загружен
-- До временной загрузки ultimateOC, используем простой addLog
local function addLog(logs_tbl, text, lvl)
    lvl = lvl or "INFO"
    local now = os.date("!*t", os.time()+3*3600) -- МСК
    local t = string.format("[%02d:%02d:%02d][%s] %s", now.hour, now.min, now.sec, lvl, text)
    table.insert(logs_tbl, t)
    while #logs_tbl > 50 do table.remove(logs_tbl, 1) end
end


-- Загрузка и сохранение данных (используем функции из ultimateOC)
local function loadData()
    addLog(logs, "INFO: Загрузка данных из " .. DATA_FILE, "INFO")
    -- Проверяем, существует ли ultimateOC, так как loadData вызывается в reload, а reload
    -- может быть вызван до полной инициализации ultimateOC при первом запуске.
    if _G.ultimateOC and _G.ultimateOC.loadf then
        local ok, data = pcall(_G.ultimateOC.loadf, DATA_FILE)
        if not ok then
            addLog(logs, "WARNING: Не удалось загрузить данные: " .. tostring(data) .. ". Создание нового файла.", "WARNING")
            craftItems = {}
            return
        end
        craftItems = data
        addLog(logs, "INFO: Данные успешно загружены. Записей: " .. #craftItems, "INFO")
    else
        addLog(logs, "WARNING: ultimateOC.loadf не доступен, данные не загружены.", "WARNING")
        craftItems = {} -- Инициализируем пустым, если ultimateOC еще не загружен
    end
end

local function saveData()
    addLog(logs, "INFO: Сохранение данных в " .. DATA_FILE, "INFO")
    if _G.ultimateOC and _G.ultimateOC.savef then
        local ok, err = pcall(_G.ultimateOC.savef, DATA_FILE, craftItems)
        if not ok then
            addLog(logs, "ERROR: Не удалось сохранить данные: " .. tostring(err), "ERROR")
        else
            addLog(logs, "INFO: Данные успешно сохранены.", "INFO")
        end
    else
        addLog(logs, "ERROR: ultimateOC.savef не доступен, данные не сохранены.", "ERROR")
    end
end

-- Перезагрузка программы
local function reload()
    addLog(logs, "INFO: Перезагрузка программы...", "INFO")
    loadData()
    currentPage = 1
    selectedItem = nil
    addLog(logs, "INFO: Перезагрузка завершена.", "INFO")
end

-- Функции для управления предметами
local function addItem()
    local name = inputValues.name
    local count = tonumber(inputValues.count)
    local craftSize = tonumber(inputValues.craftSize)

    if not name or name == "" then
        addLog(logs, "ERROR: Имя предмета не может быть пустым.", "ERROR")
        return
    end
    if not count or count <= 0 then
        addLog(logs, "ERROR: Количество должно быть положительным числом.", "ERROR")
        return
    end
    if not craftSize or craftSize <= 0 then
        addLog(logs, "ERROR: Размер крафта должен быть положительным числом.", "ERROR")
        return
    end

    local newItem = {
        name = name,
        count = count,
        craftSize = craftSize,
        uuid = computer.address -- Добавляем UUID текущего компьютера
    }

    table.insert(craftItems, newItem)
    saveData()
    addLog(logs, "INFO: Предмет '" .. name .. "' добавлен.", "INFO")

    -- Очистка полей ввода после добавления
    inputValues.name = ""
    inputValues.count = ""
    inputValues.craftSize = ""
    activeInput = nil -- Сбросить активное поле

    currentMode = "main" -- Возврат в главное меню
end

local function removeItem()
    if selectedItem and craftItems[selectedItem] then
        addLog(logs, "INFO: Удаление предмета: " .. craftItems[selectedItem].name, "INFO")
        table.remove(craftItems, selectedItem)
        selectedItem = nil
        saveData()
    else
        addLog(logs, "WARNING: Выберите предмет для удаления.", "WARNING")
    end
end

-- Проверка и крафт
local function checkAndCraft(item)
    -- Эта функция должна содержать логику проверки наличия и крафта
    -- Используйте me:getItemsInNetwork() и me:craft()
    if not me then
        addLog(logs, "ERROR: ME-интерфейс недоступен для крафта.", "ERROR")
        return
    end

    local availableItems = {}
    local ok, items = pcall(me.getItemsInNetwork, me)
    if ok and items then
        for _, v in pairs(items) do
            availableItems[v.name] = (availableItems[v.name] or 0) + v.size
        end
    else
        addLog(logs, "ERROR: Не удалось получить список предметов в сети ME: " .. tostring(items), "ERROR")
        return
    end

    local currentCount = availableItems[item.name] or 0
    if currentCount < item.count then
        local needed = item.count - currentCount
        local craftCount = math.ceil(needed / item.craftSize) * item.craftSize -- Крафтим порциями крафта
        
        addLog(logs, "INFO: Недостаточно " .. item.name .. ". Нужно: " .. needed .. ". Крафтим: " .. craftCount, "INFO")

        local ok, err = pcall(me.craft, me, item.name, craftCount)
        if not ok then
            addLog(logs, "ERROR: Ошибка крафта " .. item.name .. ": " .. tostring(err), "ERROR")
        else
            addLog(logs, "INFO: Заказан крафт " .. craftCount .. "x " .. item.name, "INFO")
        end
    else
        addLog(logs, "DEBUG: " .. item.name .. " достаточно (" .. currentCount .. "/" .. item.count .. ")", "DEBUG")
    end
end

local function autoCraftLoop()
    while true do
        if currentMode == "main" or currentMode == "craft_list" then -- Проверяем крафты, пока не в режиме добавления
            for _, item in ipairs(craftItems) do
                checkAndCraft(item)
            end
        end
        os.sleep(10) -- Проверка каждые 10 секунд
    end
end

-- Отрисовка интерфейса
local function draw()
    g.setBackground(0x282A36)
    g.setForeground(0xF8F8F2)
    g.fill(1, 1, WIDTH, HEIGHT, " ")
    g.set(1, 1, "Auto-Gemini ME Crafting")

    if currentMode == "main" then
        ultimateOC.drawBox(1, 3, WIDTH, 1, 0x50FA7B)
        g.set(3, 3, "Главное меню")

        -- Кнопки
        ultimateOC.drawButton(2, 5, 20, 3, "Добавить предмет", 0x50FA7B, 0x282A36, buttonHover == "add_item")
        ultimateOC.drawButton(2, 9, 20, 3, "Удалить предмет", 0xFF6E67, 0x282A36, buttonHover == "remove_item")
        ultimateOC.drawButton(2, 13, 20, 3, "Список крафтов", 0x8BE9FD, 0x282A36, buttonHover == "craft_list")
        ultimateOC.drawButton(2, 17, 20, 3, "Выход", 0xFF5555, 0x282A36, buttonHover == "exit")

        -- Логи
        ultimateOC.drawBox(25, 3, WIDTH - 26, HEIGHT - 4, 0x6272A4)
        g.set(27, 3, "Логи:")
        ultimateOC.drawLogs(27, 5, logs, math.min(10, #logs - logOffset), 0xF8F8F2)

    elseif currentMode == "add_item" then
        ultimateOC.drawBox(1, 3, WIDTH, 1, 0x50FA7B)
        g.set(3, 3, "Добавить новый предмет")

        -- Поля ввода
        g.set(2, 5, "Название предмета:")
        ultimateOC.drawInput(2, 6, WIDTH - 4, inputValues.name, activeInput == "name", 0x44475A, 0xF8F8F2)

        g.set(2, 8, "Количество:")
        ultimateOC.drawInput(2, 9, WIDTH - 4, inputValues.count, activeInput == "count", 0x44475A, 0xF8F8F2)

        g.set(2, 11, "Размер крафта:")
        ultimateOC.drawInput(2, 12, WIDTH - 4, inputValues.craftSize, activeInput == "craftSize", 0x44475A, 0xF8F8F2)

        -- Кнопки "Сохранить" и "Назад"
        ultimateOC.drawButton(2, 14, 20, 3, "Сохранить", 0x50FA7B, 0x282A36, buttonHover == "save_item")
        ultimateOC.drawButton(25, 14, 20, 3, "Назад", 0xFF6E67, 0x282A36, buttonHover == "back_add_item")

        -- Логи также отображаются
        ultimateOC.drawBox(2, 18, WIDTH - 3, HEIGHT - 19, 0x6272A4)
        g.set(4, 18, "Логи:")
        ultimateOC.drawLogs(4, 20, logs, math.min(10, #logs - logOffset), 0xF8F8F2)

    elseif currentMode == "craft_list" then
        ultimateOC.drawBox(1, 3, WIDTH, 1, 0x8BE9FD)
        g.set(3, 3, "Список отслеживаемых предметов")

        -- Список предметов
        local itemsPerPage = math.floor((HEIGHT - 6) / 2) - 2 -- Adjusted for buttons at the bottom
        local startIndex = (currentPage - 1) * itemsPerPage + 1
        local endIndex = math.min(startIndex + itemsPerPage - 1, #craftItems)

        if #craftItems == 0 then
            g.set(2, 5, "Список пуст.")
        else
            for i = startIndex, endIndex do
                local item = craftItems[i]
                local display = string.format("[%d] %s (x%d) - Крафт: %d", i, item.name, item.count, item.craftSize)
                local isSelected = (i == selectedItem)
                ultimateOC.drawText(2, 5 + (i - startIndex), display, isSelected and 0xFFD700 or 0xF8F8F2)
            end
        end

        -- Навигация по страницам
        local maxPages = math.max(1, math.ceil(#craftItems / itemsPerPage))
        g.set(WIDTH - 10, HEIGHT - 3, string.format("Страница %d/%d", currentPage, maxPages))

        -- Кнопки "Назад" и "Удалить"
        ultimateOC.drawButton(2, HEIGHT - 3, 20, 3, "Назад", 0xFF6E67, 0x282A36, buttonHover == "back_craft_list")
        ultimateOC.drawButton(25, HEIGHT - 3, 20, 3, "Удалить выбранный", 0xFF5555, 0x282A36, buttonHover == "remove_item_list")

        -- Логи
        ultimateOC.drawBox(WIDTH / 2 + 5, 5, WIDTH / 2 - 5, HEIGHT - 4, 0x6272A4)
        g.set(WIDTH / 2 + 7, 5, "Логи:")
        ultimateOC.drawLogs(WIDTH / 2 + 7, 7, logs, math.min(10, #logs - logOffset), 0xF8F8F2)
    end
    g.setCursor(1,1) -- Hide cursor
end

-- Обработка событий мыши
local function handleClick(x, y, button)
    buttonHover = nil -- Сбросить состояние наведения при клике
    if button == 1 then -- Левая кнопка мыши
        if currentMode == "main" then
            if ultimateOC.isInside(x, y, 2, 5, 20, 3) then -- Добавить предмет
                currentMode = "add_item"
                addLog(logs, "INFO: Переход в режим добавления предмета.", "INFO")
                activeInput = "name" -- По умолчанию активируем поле имени
            elseif ultimateOC.isInside(x, y, 2, 9, 20, 3) then -- Удалить предмет (main menu)
                if selectedItem then
                    removeItem()
                else
                    addLog(logs, "WARNING: Выберите предмет из списка для удаления.", "WARNING")
                end
            elseif ultimateOC.isInside(x, y, 2, 13, 20, 3) then -- Список крафтов
                currentMode = "craft_list"
                addLog(logs, "INFO: Переход в режим списка крафтов.", "INFO")
                currentPage = 1
                selectedItem = nil
            elseif ultimateOC.isInside(x, y, 2, 17, 20, 3) then -- Выход
                addLog(logs, "INFO: Выход из программы.", "INFO")
                os.exit()
            end
        elseif currentMode == "add_item" then
            -- Проверка кликов по полям ввода
            if ultimateOC.isInside(x, y, 2, 6, WIDTH - 4, 1) then
                activeInput = "name"
            elseif ultimateOC.isInside(x, y, 2, 9, WIDTH - 4, 1) then
                activeInput = "count"
            elseif ultimateOC.isInside(x, y, 2, 12, WIDTH - 4, 1) then
                activeInput = "craftSize"
            else
                activeInput = nil -- Клик вне полей ввода
            end

            -- Кнопки
            if ultimateOC.isInside(x, y, 2, 14, 20, 3) then -- Сохранить
                addItem()
            elseif ultimateOC.isInside(x, y, 25, 14, 20, 3) then -- Назад
                currentMode = "main"
                addLog(logs, "INFO: Возврат в главное меню.", "INFO")
                -- Очистка полей ввода и активного поля при возврате
                inputValues.name = ""
                inputValues.count = ""
                inputValues.craftSize = ""
                activeInput = nil
            end
        elseif currentMode == "craft_list" then
            -- Выбор элемента из списка
            local itemsPerPage = math.floor((HEIGHT - 6) / 2) - 2
            local startIndex = (currentPage - 1) * itemsPerPage + 1
            local itemClicked = false
            for i = startIndex, math.min(startIndex + itemsPerPage - 1, #craftItems) do
                if ultimateOC.isInside(x, y, 2, 5 + (i - startIndex), WIDTH / 2 - 5, 1) then
                    selectedItem = i
                    addLog(logs, "INFO: Выбран предмет: " .. craftItems[selectedItem].name, "INFO")
                    itemClicked = true
                    break
                end
            end
            if not itemClicked then
                selectedItem = nil -- Деселектировать, если клик вне предметов
            end

            -- Кнопки
            if ultimateOC.isInside(x, y, 2, HEIGHT - 3, 20, 3) then -- Назад
                currentMode = "main"
                addLog(logs, "INFO: Возврат в главное меню.", "INFO")
                selectedItem = nil
            elseif ultimateOC.isInside(x, y, 25, HEIGHT - 3, 20, 3) then -- Удалить выбранный
                removeItem()
            end
            -- Перелистывание страниц стрелками вправо/влево, реализовано в handleKey
        end
    end
    draw()
end

-- Обработка движения мыши (для наведения)
local function handleHover(x, y)
    local oldButtonHover = buttonHover
    buttonHover = nil

    if currentMode == "main" then
        if ultimateOC.isInside(x, y, 2, 5, 20, 3) then buttonHover = "add_item"
        elseif ultimateOC.isInside(x, y, 2, 9, 20, 3) then buttonHover = "remove_item"
        elseif ultimateOC.isInside(x, y, 2, 13, 20, 3) then buttonHover = "craft_list"
        elseif ultimateOC.isInside(x, y, 2, 17, 20, 3) then buttonHover = "exit"
        end
    elseif currentMode == "add_item" then
        if ultimateOC.isInside(x, y, 2, 14, 20, 3) then buttonHover = "save_item"
        elseif ultimateOC.isInside(x, y, 25, 14, 20, 3) then buttonHover = "back_add_item"
        end
    elseif currentMode == "craft_list" then
        if ultimateOC.isInside(x, y, 2, HEIGHT - 3, 20, 3) then buttonHover = "back_craft_list"
        elseif ultimateOC.isInside(x, y, 25, HEIGHT - 3, 20, 3) then buttonHover = "remove_item_list"
        end
    end

    if buttonHover ~= oldButtonHover then
        draw() -- Перерисовать только если состояние наведения изменилось
    end
end

-- Обработка клавиатуры
local function handleKey(key, is_pressed, arg)
    if is_pressed then
        if currentMode == "add_item" then
            if activeInput then
                if key == 206 then -- Backspace (стирает последний символ)
                    if #inputValues[activeInput] > 0 then
                        inputValues[activeInput] = unicode.sub(inputValues[activeInput], 1, unicode.len(inputValues[activeInput]) - 1)
                    end
                elseif key == 28 then -- Enter (переключает поля или сохраняет)
                    if activeInput == "name" then
                        activeInput = "count"
                    elseif activeInput == "count" then
                        activeInput = "craftSize"
                    elseif activeInput == "craftSize" then
                        addItem() -- Триггер сохранения
                    end
                elseif key == 15 then -- Tab (переключает поля)
                    if activeInput == "name" then
                        activeInput = "count"
                    elseif activeInput == "count" then
                        activeInput = "craftSize"
                    elseif activeInput == "craftSize" then
                        activeInput = "name"
                    end
                else -- Любая другая клавиша для ввода
                    local char = unicode.char(key)
                    if char and char ~= "" then
                        if activeInput == "count" or activeInput == "craftSize" then
                            -- Для чисел разрешаем только цифры
                            if string.match(char, "%d") then
                                inputValues[activeInput] = inputValues[activeInput] .. char
                            end
                        else -- Для имени разрешаем все символы
                            inputValues[activeInput] = inputValues[activeInput] .. char
                        end
                    end
                end
            end
        else -- Главное меню или список крафтов
            if key == 200 then -- Стрелка Вверх
                if currentMode == "craft_list" then
                    local itemsPerPage = math.floor((HEIGHT - 6) / 2) - 2
                    local startIndex = (currentPage - 1) * itemsPerPage + 1
                    if selectedItem then
                        selectedItem = math.max(startIndex, selectedItem - 1)
                    else
                        selectedItem = startIndex
                    end
                end
            elseif key == 208 then -- Стрелка Вниз
                if currentMode == "craft_list" then
                    local itemsPerPage = math.floor((HEIGHT - 6) / 2) - 2
                    local endIndex = math.min((currentPage - 1) * itemsPerPage + itemsPerPage, #craftItems)
                    if selectedItem then
                        selectedItem = math.min(endIndex, selectedItem + 1)
                    else
                        selectedItem = (currentPage - 1) * itemsPerPage + 1
                    end
                end
            elseif key == 203 then -- Стрелка Влево (смена страницы)
                if currentMode == "craft_list" then
                    if currentPage > 1 then
                        currentPage = currentPage - 1
                        selectedItem = nil
                    end
                end
            elseif key == 205 then -- Стрелка Вправо (смена страницы)
                if currentMode == "craft_list" then
                    local itemsPerPage = math.floor((HEIGHT - 6) / 2) - 2
                    local maxPages = math.max(1, math.ceil(#craftItems / itemsPerPage))
                    if currentPage < maxPages then
                        currentPage = currentPage + 1
                        selectedItem = nil
                    end
                end
            elseif key == 200 and arg.shift then -- Shift + Up для логов (прокрутка вверх)
                logOffset = math.min(logOffset + 1, math.max(0, #logs - 10)) -- Adjust for 10 lines of logs
            elseif key == 208 and arg.shift then -- Shift + Down для логов (прокрутка вниз)
                logOffset = math.max(logOffset - 1, 0)
            end
        end
    end
    buttonHover = nil
    draw()
end


-------------------- Старт --------------------
checkComponents()
bindGpu()
WIDTH, HEIGHT = g.getResolution()
g.setResolution(WIDTH, HEIGHT)
addLog(logs, "INFO: Программа запущена", "INFO")
loadOrCreateLib() -- Загрузка или скачивание ultimateOC.lua (теперь ultimateOC будет доступен)

-- Теперь, когда ultimateOC загружен, мы можем использовать его функции addLog
-- Если вы хотите использовать ultimateOC.addLog для всех логов, можете
-- заменить временную функцию addLog выше на прямое использование ultimateOC.addLog.
-- Для согласованности, пока оставим текущую addLog, но убедитесь, что она
-- вызывает ultimateOC.addLog, если хотите использовать его фичи.
-- Например: addLog = ultimateOC.addLog

local ok, err = pcall(reload)
if not ok then
    addLog(logs, "ERROR: Ошибка при начальной загрузке: " .. tostring(err), "ERROR")
    draw()
    while true do os.sleep(1) end
end
draw()

-- Запуск основного цикла автокрафта в отдельном потоке (coroutine)
local autoCraftCoroutine = coroutine.create(autoCraftLoop)
local ok, err = coroutine.resume(autoCraftCoroutine)
if not ok then
    addLog(logs, "ERROR: Фатальная ошибка в autoCraftLoop: " .. tostring(err), "ERROR")
    draw()
    while true do os.sleep(1) end
end

-- Главный цикл обработки событий
while true do
    local _, name, arg1, arg2, arg3, arg4 = event.pull("interrupted", "touch", "key_down", "key_up", "mouse_scroll", "mouse_move")
    if name == "interrupted" then
        addLog(logs, "INFO: Программа прервана.", "INFO")
        break
    elseif name == "touch" then
        handleClick(arg1, arg2, arg3)
    elseif name == "key_down" then
        handleKey(arg1, true, {shift = arg2, ctrl = arg3, alt = arg4})
    elseif name == "key_up" then
        -- handleKey(arg1, false, {shift = arg2, ctrl = arg3, alt = arg4}) -- Можно обрабатывать key_up, если нужно для логики
    elseif name == "mouse_scroll" then
        if arg1 > 0 then -- Scroll up
            logOffset = math.min(logOffset + 1, math.max(0, #logs - 10))
        elseif arg1 < 0 then -- Scroll down
            logOffset = math.max(logOffset - 1, 0)
        end
        draw()
    elseif name == "mouse_move" then
        handleHover(arg1, arg2) -- Обработка наведения
    end
end
