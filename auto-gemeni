-- auto-gemeni.lua
local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode")
local term = require("term")
local computer = require("computer")
local g = component.gpu
local me = component.me_interface

-- Пути и библиотека
local DATA_FILE = "/home/BD.txt"
local LIB_PATH = "/lib/ultimateOC.lua"
local LIB_URL = "https://raw.githubusercontent.com/shify4713/lua/main/ultimateOC.lua"

-- Загружаем библиотеку ultimateOC
-- Проверяем, существует ли файл библиотеки
if not fs.exists(LIB_PATH) then
    io.stderr:write("Библиотека ultimateOC.lua не найдена по пути: " .. LIB_PATH .. "\n")
    io.stderr:write("Попытка загрузки с GitHub...\n")
    local success, err = shell.exec("wget", LIB_URL, LIB_PATH)
    if not success then
        io.stderr:write("Ошибка: Не удалось загрузить ultimateOC.lua с GitHub: " .. tostring(err) .. "\n")
        os.exit(1)
    else
        io.stderr:write("ultimateOC.lua успешно загружен.\n")
    end
end

-- Теперь пытаемся загрузить библиотеку
local uoc_loaded, uoc = pcall(require, LIB_PATH)
if not uoc_loaded then
    io.stderr:write("Ошибка: Не удалось загрузить библиотеку ultimateOC.lua: " .. tostring(uoc) .. "\n")
    io.stderr:write("Пожалуйста, проверьте файл " .. LIB_PATH .. " на наличие синтаксических ошибок.\n")
    os.exit(1)
end

-- Проверка доступности компонентов
local function checkComponents()
    local missing = {}
    if not component.isAvailable("gpu") then table.insert(missing, "GPU") end
    if not component.isAvailable("screen") then table.insert(missing, "Экран") end
    if not component.isAvailable("me_interface") then table.insert(missing, "ME-интерфейс") end

    if #missing > 0 then
        io.stderr:write("Ошибка: Отсутствуют необходимые компоненты: " .. table.concat(missing, ", ") .. "\n")
        os.exit(1)
    end
end

-- Привязка GPU к экрану
local function bindGpu()
    local screen = component.list("screen")()
    if not screen then
        io.stderr:write("Ошибка: Не найден экран для привязки GPU\n")
        os.exit(1)
    end
    local success, err = pcall(g.bind, screen)
    if not success then
        io.stderr:write("Ошибка: Не удалось привязать GPU к экрану: " .. tostring(err) .. "\n")
        os.exit(1)
    end
end

-- Глобальные переменные и настройки
local WIDTH, HEIGHT
local dataItems = {}
local logs = {}
local selectedItem = nil -- Индекс в dataItems, а не в отфильтрованном списке
local currentPage = 1
local search = ""
local searchActive = false
local changeitem = false -- Флаг для режима ввода (add/edit)
local isCrafting = false
local craftStatus = "Ожидание"
local nextCraftUpdate = 0 -- Время следующего полного обновления ME-данных
local logOffset = 0 -- Смещение для прокрутки логов
local buttonHover = nil -- Отслеживание наведения мыши для кнопок

local lastCraftingStatus = nil -- Для отслеживания изменения статуса крафта
local lastSelectedItemIndex = nil -- Для отслеживания изменения выбранного элемента (индекс в отфильтрованном списке)
local lastSearchValue = nil -- Для отслеживания изменения строки поиска

local settings = {
    sortCriteria = "name",
    sortAscending = true,
}

-- Цвета
local COLORS = {
    background = 0x1A1B26,
    foreground = 0xC0CAF5,
    border = 0x7AA2F7,
    buttonBg = 0x414868,
    buttonActive = 0x7DCFFF,
    buttonHover = 0x9DEDFF,
    error = 0xF7768E,
    info = 0xBB9AF7,
    warning = 0xFFC970,
    ok = 0x9ECE6A,
    subText = 0xBB9AF7,
    selectedRow = 0x364177,
    progressBg = 0x2A2E44,
    progressBar = 0x9ECE6A,
}

-- Вспомогательная функция для добавления логов
function addLog(tbl, message, type)
    local maxLogs = 100 -- Максимальное количество логов
    if #tbl >= maxLogs then
        table.remove(tbl, 1)
    end
    table.insert(tbl, string.format("[%s] %s: %s", os.date("%H:%M:%S"), type or "INFO", message))
    -- Если лог-окно прокручено до конца, прокручиваем его, чтобы видеть новые сообщения
    if logOffset == 0 then
        -- Это сложная часть, потому что мы не знаем, сколько строк занимает новое сообщение
        -- Проще всего сбросить offset, если он был в самом низу.
        -- Или же, если есть возможность, рассчитать, чтобы новый лог был виден
        -- Сейчас, если logOffset = 0 (показываем последние), новый лог будет виден.
        -- Если юзер прокрутил вверх, мы не будем его двигать.
    end
end

-- Вспомогательная функция для сохранения данных
function save()
    local success, err = uoc.savef(DATA_FILE, {items = dataItems, settings = settings})
    if not success then
        addLog(logs, "ERROR: Ошибка сохранения данных: " .. tostring(err), "ERROR")
    end
end

-- Вспомогательная функция для загрузки данных
function load()
    local loadedData, err = uoc.loadf(DATA_FILE)
    if loadedData then
        dataItems = loadedData.items or {}
        settings = loadedData.settings or {sortCriteria = "name", sortAscending = true}
    else
        addLog(logs, "WARNING: Не удалось загрузить данные из " .. DATA_FILE .. ": " .. tostring(err), "WARNING")
        dataItems = {} -- Инициализируем пустой таблицей, чтобы избежать ошибок
    end
end

-- Функция для получения количества элементов на странице
function getItemsPerPage()
    return math.max(1, HEIGHT - 10 - 10 - 1) -- Высота экрана минус отступы сверху/снизу и панель поиска и заголовки таблицы
end

-- Функция для получения максимального количества страниц
function getMaxPages()
    local filteredItems = getFilteredAndSortedItems()
    local perPage = getItemsPerPage()
    return math.max(1, math.ceil(#filteredItems / perPage))
end

-- Функция для фильтрации и сортировки элементов
function getFilteredAndSortedItems()
    local filtered = {}
    for _, item in ipairs(dataItems) do
        local matchesSearch = true
        if search ~= "" then
            local lowerSearch = string.lower(search)
            matchesSearch = (item.name and string.find(string.lower(item.name), lowerSearch)) or
                            (item.category and string.find(string.lower(item.category), lowerSearch))
        end
        if matchesSearch then
            table.insert(filtered, item)
        end
    end

    table.sort(filtered, function(a, b)
        local valA = a[settings.sortCriteria]
        local valB = b[settings.sortCriteria]

        if type(valA) == "number" and type(valB) == "number" then
            return settings.sortAscending and (valA < valB) or (valA > valB)
        else
            valA = tostring(valA or "")
            valB = tostring(valB or "")
            if settings.sortAscending then
                return valA < valB
            else
                return valA > valB
            end
        end
    end)
    return filtered
end

-- Функция для получения текущего количества предметов из ME-сети
function getCurrentItemCount(itemName)
    local items = me.getItemsInME()
    for _, item in ipairs(items) do
        if item.label == itemName then
            return item.size
        end
    end
    return 0
end

-- Функция для получения количества доступных для крафта
function getCraftableCount(itemName)
    local patterns = me.getCraftableItems()
    for _, pattern in ipairs(patterns) do
        if pattern.label == itemName then
            return pattern.count
        end
    end
    return 0
end

-- Функция для обновления данных ME-сети и логирования
function reload()
    addLog(logs, "INFO: Обновление данных ME-сети...", "INFO")
    local meItems = {}
    local craftableItems = {}

    -- Попытка получить данные из ME-интерфейса, обработка ошибок
    local ok, res = pcall(me.getItemsInME)
    if ok then
        meItems = res
    else
        addLog(logs, "ERROR: Ошибка при получении предметов из ME: " .. tostring(res), "ERROR")
        craftStatus = "Ошибка ME-интерфейса"
        return -- Не продолжаем, если ME не работает
    end

    ok, res = pcall(me.getCraftableItems)
    if ok then
        craftableItems = res
    else
        addLog(logs, "ERROR: Ошибка при получении крафтовых паттернов ME: " .. tostring(res), "ERROR")
        craftStatus = "Ошибка ME-интерфейса"
        return -- Не продолжаем, если ME не работает
    end

    for i, item in ipairs(dataItems) do
        item.current = 0
        for _, meItem in ipairs(meItems) do
            if meItem.label == item.name then
                item.current = meItem.size
                break
            end
        end

        item.craftable = 0
        for _, craftableItem in ipairs(craftableItems) do
            if craftableItem.label == item.name then
                item.craftable = craftableItem.count
                break
            end
        end
    end
    addLog(logs, "INFO: Данные ME-сети обновлены", "INFO")
end

-- Функция для отрисовки кнопок
local function drawButtons()
    local btnWidth = 12
    local btnHeight = 3
    local btnX = WIDTH - btnWidth - 5
    local btnPadding = 2

    local btns = {
        {name = "Крафт всех", action = "craftAll", enabled = true},
        {name = "Удалить", action = "delete", enabled = selectedItem ~= nil},
        {name = "Изменить", action = "edit", enabled = selectedItem ~= nil},
        {name = isCrafting and "Остановить" or "Автокрафт", action = "toggleCraft", enabled = true},
        {name = "Добавить", action = "add", enabled = true},
    }

    -- Очищаем только область, где находятся кнопки.
    local buttonsAreaY = 10
    local buttonsAreaHeight = (#btns * (btnHeight + btnPadding)) + (2 * (btnHeight + btnPadding)) -- Включает стрелки и сортировку
    uoc.fillRect(btnX, buttonsAreaY, btnWidth, buttonsAreaHeight, COLORS.background)

    for i, btn in ipairs(btns) do
        local btnY = buttonsAreaY + (i - 1) * (btnHeight + btnPadding)
        local bgColor = COLORS.buttonBg
        local textColor = COLORS.foreground
        local subBtnText = nil

        if not btn.enabled then
            textColor = COLORS.subText
        elseif buttonHover == btn.action then
            bgColor = COLORS.buttonHover
        end

        if btn.action == "toggleCraft" then
            subBtnText = isCrafting and "ACTIVE" or "IDLE"
            uoc.animatedButton(btnX, btnY, btnWidth, btnHeight, btn.name, bgColor, textColor, COLORS.border, subBtnText, COLORS.subText)
        else
            uoc.animatedButton(btnX, btnY, btnWidth, btnHeight, btn.name, bgColor, textColor, COLORS.border, nil, nil)
        end
    end

    -- Стрелки для переключения страниц
    local arrowBtnW = 4
    local arrowBtnH = 3
    local arrowBtnY = buttonsAreaY + (#btns * (btnHeight + btnPadding))

    local prevArrowBtnX = btnX
    local nextArrowBtnX = btnX + arrowBtnW + 1

    local prevEnabled = currentPage > 1
    local nextEnabled = currentPage < getMaxPages()

    local prevBg = COLORS.buttonBg
    local prevTxtColor = COLORS.foreground
    if not prevEnabled then prevTxtColor = COLORS.subText end
    if buttonHover == "prevPage" and prevEnabled then prevBg = COLORS.buttonHover end
    uoc.animatedButton(prevArrowBtnX, arrowBtnY, arrowBtnW, arrowBtnH, "<", prevBg, prevTxtColor, COLORS.border, nil, nil)

    local nextBg = COLORS.buttonBg
    local nextTxtColor = COLORS.foreground
    if not nextEnabled then nextTxtColor = COLORS.subText end
    if buttonHover == "nextPage" and nextEnabled then nextBg = COLORS.buttonHover end
    uoc.animatedButton(nextArrowBtnX, arrowBtnY, arrowBtnW, arrowBtnH, ">", nextBg, nextTxtColor, COLORS.border, nil, nil)

    -- Кнопка сортировки
    local sortBtnY = arrowBtnY + arrowBtnH + 2
    local sortBtnW = 12
    local sortName = string.sub(settings.sortCriteria, 1, 1):upper() .. string.sub(settings.sortCriteria, 2)
    local sortSubText = settings.sortAscending and "ASC" or "DESC"
    local sortBg = COLORS.buttonBg
    if buttonHover == "sort" then sortBg = COLORS.buttonHover end
    uoc.animatedButton(btnX, sortBtnY, sortBtnW, arrowBtnH, sortName, sortBg, COLORS.foreground, COLORS.border, sortSubText, COLORS.subText)
end

-- Функция для отрисовки таблицы элементов
local function drawItems()
    local perPage = getItemsPerPage()
    local filteredAndSortedItems = getFilteredAndSortedItems()
    local startIndex = (currentPage - 1) * perPage + 1
    local endIndex = math.min(startIndex + perPage - 1, #filteredAndSortedItems)

    local columnWidths = {
        name = math.floor((WIDTH - 20) * 0.3),
        category = math.floor((WIDTH - 20) * 0.2),
        current = math.floor((WIDTH - 20) * 0.15),
        count = math.floor((WIDTH - 20) * 0.15),
        craftSize = math.floor((WIDTH - 20) * 0.2),
    }
    local itemsStartY = 10 -- Начальная Y-координата для списка (ниже заголовка)
    local itemsAreaWidth = WIDTH - 20
    local itemsAreaHeight = HEIGHT - 10 - itemsStartY - 1 -- Минус строка заголовков таблицы

    -- Очищаем только область таблицы
    uoc.fillRect(2, itemsStartY - 1, itemsAreaWidth, itemsAreaHeight + 1, COLORS.background) -- +1 для заголовка

    -- Отрисовка заголовков столбцов
    local currentX = 2
    uoc.fillRect(currentX, itemsStartY - 1, itemsAreaWidth, 1, COLORS.buttonBg) -- Фон для заголовков
    
    local function drawHeaderCell(text, width)
        local trimmedText = unicode.sub(text, 1, width)
        uoc.drawText(currentX, itemsStartY - 1, trimmedText, COLORS.foreground)
        currentX = currentX + width
    end
    
    drawHeaderCell("Название", columnWidths.name)
    drawHeaderCell("Категория", columnWidths.category)
    drawHeaderCell("Наличие", columnWidths.current)
    drawHeaderCell("Цель", columnWidths.count)
    drawHeaderCell("Размер", columnWidths.craftSize)


    for i = startIndex, endIndex do
        local item = filteredAndSortedItems[i]
        local rowY = itemsStartY + (i - startIndex)
        local bgColor = COLORS.background
        local textColor = COLORS.foreground

        -- Проверяем, является ли текущий элемент выбранным
        -- Сравниваем с индексом в dataItems
        local currentDataItemIndex = nil
        for k, v in ipairs(dataItems) do
            if v == item then
                currentDataItemIndex = k
                break
            end
        end
        if selectedItem == currentDataItemIndex then
            bgColor = COLORS.selectedRow
        end

        uoc.fillRect(2, rowY, itemsAreaWidth, 1, bgColor) -- Заливаем фон строки

        currentX = 2 -- Сбрасываем X для каждой новой строки
        local function drawCell(text, width, alignRight)
            -- Убедимся, что текст не выходит за границы ячейки
            local trimmedText = unicode.sub(tostring(text or ""), 1, width)
            local pad = width - unicode.len(trimmedText)
            local drawX = currentX
            if alignRight then
                drawX = currentX + pad
            end
            uoc.drawText(drawX, rowY, trimmedText, textColor)
            currentX = currentX + width
        end

        drawCell(item.name, columnWidths.name)
        drawCell(item.category, columnWidths.category)
        drawCell(item.current, columnWidths.current, true) -- Выравнивание по правому краю для чисел
        drawCell(item.count, columnWidths.count, true)
        drawCell(item.craftSize, columnWidths.craftSize, true)
    end
    -- Добавляем рамку вокруг таблицы
    uoc.drawRect(1, itemsStartY - 2, itemsAreaWidth + 2, itemsAreaHeight + 2, COLORS.border, nil)
end

-- Функция для отрисовки логов
local function drawLogs()
    local logAreaY = HEIGHT - 8
    local logAreaHeight = 5
    -- Отрисовка логов теперь использует улучшенную функцию из библиотеки
    uoc.drawLogs(2, logAreaY, logs, logAreaHeight, COLORS.foreground, logOffset, COLORS.background)
    -- Добавляем рамку для логов
    uoc.drawRect(1, logAreaY - 1, WIDTH - 2, logAreaHeight + 2, COLORS.border, nil)
end

-- Функция для отрисовки панели поиска
local function drawSearch()
    local searchBarY = HEIGHT - 4
    local searchBarX = 2
    local searchBarWidth = WIDTH - 20
    
    -- Рисуем рамку вокруг поля поиска
    uoc.drawRect(searchBarX - 1, searchBarY - 1, searchBarWidth + 2, 3, COLORS.border, COLORS.background)

    local cursorChar = searchActive and "_" or ""
    uoc.drawText(searchBarX, searchBarY, "Поиск: " .. search .. cursorChar, COLORS.foreground)

    -- Кнопка очистки поиска
    local clearBtnX = searchBarX + searchBarWidth - 3
    uoc.animatedButton(clearBtnX, searchBarY, 3, 1, "[X]", COLORS.buttonBg, COLORS.foreground, COLORS.border, nil, nil)
end

-- Главная функция отрисовки всего экрана
local function draw()
    g.setBackground(COLORS.background)
    g.clear() -- Полная очистка экрана

    -- Заголовок
    uoc.drawText(2, 2, "Система Автокрафта ME", COLORS.info)
    
    -- Статус и прогресс-бар
    local statusText = "Статус: " .. craftStatus
    local statusColor = (craftStatus:find("Ошибка") and COLORS.error) or (isCrafting and COLORS.ok) or COLORS.info
    uoc.drawText(2, 3, statusText, statusColor)

    if uoc.progressBar then
        uoc.progressBar(2, 5, WIDTH - 20, isCrafting and 0.9 or 0, COLORS.progressBg, COLORS.progressBar, COLORS.border)
    end

    drawButtons()
    drawItems()
    drawLogs()
    drawSearch()

    -- Информация о странице
    local pageInfo = string.format("Страница %d/%d", currentPage, getMaxPages())
    uoc.drawText(2, HEIGHT - 10, pageInfo, COLORS.foreground)

    g.present() -- Отображаем все изменения на экране
end

-- Функции CRUD (создание, чтение, обновление, удаление)

-- Функция для получения ввода от пользователя
local function promptForInput(promptText, defaultValue)
    changeitem = true -- Активируем режим ввода
    draw() -- Очищаем экран перед запросом
    uoc.drawText(2, HEIGHT - 2, promptText .. (defaultValue ~= nil and " [" .. tostring(defaultValue) .. "]" or ""), COLORS.info)
    g.present()

    local input = ""
    local cursorX = 2 + unicode.len(promptText .. (defaultValue ~= nil and " [" .. tostring(defaultValue) .. "]" or "")) + 2 -- Начальная позиция курсора
    
    -- Временная функция для очистки строки ввода
    local function clearPromptLine()
        uoc.fillRect(2, HEIGHT - 2, WIDTH - 4, 1, COLORS.background)
        g.present()
    end

    while true do
        local _, _, key, _, _, unicodeChar = event.pull("key_down")
        if key == 28 then -- Enter
            clearPromptLine()
            changeitem = false
            return input == "" and defaultValue or input
        elseif key == 14 then -- Backspace
            if unicode.len(input) > 0 then
                input = unicode.sub(input, 1, unicode.len(input) - 1)
                uoc.fillRect(cursorX, HEIGHT - 2, 1, 1, COLORS.background) -- Стираем последний символ
                g.present()
            end
        elseif unicodeChar and unicodeChar >= 32 and unicodeChar <= 126 then -- Только печатные символы
            input = input .. unicode.char(unicodeChar)
            uoc.drawText(cursorX + unicode.len(input) - 1, HEIGHT - 2, unicode.char(unicodeChar), COLORS.foreground)
            g.present()
        end
        -- Рисуем курсор
        uoc.drawText(cursorX + unicode.len(input), HEIGHT - 2, "_", COLORS.foreground)
        g.present()
        os.sleep(0.05) -- Небольшая задержка для курсора
        uoc.fillRect(cursorX + unicode.len(input), HEIGHT - 2, 1, 1, COLORS.background) -- Стираем курсор
        g.present()
    end
end

-- Добавление нового элемента
local function addItem()
    local newItem = {
        name = "",
        category = "",
        count = 0,
        craftSize = 0,
        current = 0,
        craftable = 0,
    }

    addLog(logs, "INFO: Запуск добавления нового предмета", "INFO")
    newItem.name = promptForInput("Введите название предмета (например, Silicon):")
    if not newItem.name or newItem.name == "" then addLog(logs, "WARNING: Добавление предмета отменено.", "WARNING"); draw(); return end
    
    newItem.category = promptForInput("Введите категорию (например, Component):")
    if not newItem.category then newItem.category = "" end
    
    newItem.count = tonumber(promptForInput("Введите желаемое количество (число):", 0)) or 0
    if not type(newItem.count) == "number" or newItem.count < 0 then addLog(logs, "ERROR: Неверное количество. Добавление отменено.", "ERROR"); draw(); return end
    
    newItem.craftSize = tonumber(promptForInput("Введите размер крафта (число):", 1)) or 1
    if not type(newItem.craftSize) == "number" or newItem.craftSize <= 0 then addLog(logs, "ERROR: Неверный размер крафта. Добавление отменено.", "ERROR"); draw(); return end
    
    table.insert(dataItems, newItem)
    save()
    addLog(logs, "INFO: Добавлен новый предмет: " .. newItem.name, "INFO")
    reload()
    draw()
end

-- Редактирование элемента
local function editItem()
    if not selectedItem then addLog(logs, "WARNING: Не выбран предмет для редактирования.", "WARNING"); return end
    local item = dataItems[selectedItem]

    addLog(logs, "INFO: Редактирование предмета: " .. item.name, "INFO")
    
    local newName = promptForInput("Введите новое название предмета:", item.name)
    if newName and newName ~= "" then item.name = newName end

    local newCategory = promptForInput("Введите новую категорию:", item.category)
    if newCategory then item.category = newCategory end

    local newCount = tonumber(promptForInput("Введите новое желаемое количество:", item.count))
    if type(newCount) == "number" and newCount >= 0 then item.count = newCount else addLog(logs, "WARNING: Неверное количество. Изменения не применены.", "WARNING") end
    
    local newCraftSize = tonumber(promptForInput("Введите новый размер крафта:", item.craftSize))
    if type(newCraftSize) == "number" and newCraftSize > 0 then item.craftSize = newCraftSize else addLog(logs, "WARNING: Неверный размер крафта. Изменения не применены.", "WARNING") end

    save()
    addLog(logs, "INFO: Предмет изменен: " .. item.name, "INFO")
    reload()
    draw()
end

-- Удаление элемента с подтверждением
local function removeItem()
    if not selectedItem then addLog(logs, "WARNING: Не выбран предмет для удаления.", "WARNING"); return end
    local itemToRemove = dataItems[selectedItem]
    local confirmation = promptForInput("Удалить " .. itemToRemove.name .. "? (y/n)", "n")
    if string.lower(confirmation) == "y" then
        table.remove(dataItems, selectedItem)
        selectedItem = nil
        save()
        addLog(logs, "INFO: Предмет удален: " .. itemToRemove.name, "INFO")
        reload()
        draw()
    else
        addLog(logs, "INFO: Удаление предмета отменено.", "INFO")
        draw()
    end
end

-- Функции крафта

-- Попытка скрафтить один предмет
function tryCraftItem(item)
    if item.current < item.count then
        local needed = item.count - item.current
        local craftAmount = math.min(needed, item.craftSize)
        if craftAmount <= 0 then return false end

        addLog(logs, "INFO: Запрос на крафт " .. craftAmount .. "x " .. item.name, "INFO")
        local success, reason = pcall(me.craft, item.name, craftAmount) -- Используем pcall для me.craft
        if success then
            addLog(logs, "ОК: Скрафчено " .. craftAmount .. "x " .. item.name, "OK")
            craftStatus = "Крафтится: " .. item.name .. " x" .. craftAmount
            reload() -- Обновляем данные после успешного крафта
            return true
        else
            addLog(logs, "ERROR: Не удалось скрафтить " .. item.name .. ": " .. tostring(reason), "ERROR")
            craftStatus = "Ошибка крафта: " .. item.name .. " (" .. tostring(reason) .. ")"
            return false
        end
    end
    return false
end

-- Запуск автокрафта
function doCraft()
    if isCrafting then return end
    isCrafting = true
    craftStatus = "Запущено"
    addLog(logs, "INFO: Автокрафт запущен", "INFO")
    -- Не вызываем draw() здесь, autoCraftLoop сам вызовет его при необходимости
end

-- Остановка автокрафта
function stopCraft()
    isCrafting = false
    craftStatus = "Остановлено"
    addLog(logs, "INFO: Автокрафт остановлен", "INFO")
    -- Не вызываем draw() здесь, autoCraftLoop сам вызовет его при необходимости
end

-- Крафт всех недостающих предметов
function craftAll()
    addLog(logs, "INFO: Запрос на крафт всех недостающих предметов", "INFO")
    reload() -- Сначала обновляем данные
    local anyCrafted = false
    for _, item in ipairs(dataItems) do
        if item.current < item.count then
            local needed = item.count - item.current
            if needed > 0 then
                local success, reason = pcall(me.craft, item.name, needed)
                if success then
                    addLog(logs, "ОК: Скрафчено " .. needed .. "x " .. item.name, "OK")
                    anyCrafted = true
                else
                    addLog(logs, "ERROR: Не удалось скрафтить " .. item.name .. ": " .. tostring(reason), "ERROR")
                end
            end
        end
    end
    if anyCrafted then
        addLog(logs, "INFO: Все доступные крафты выполнены.", "INFO")
    else
        addLog(logs, "INFO: Ничего не требовалось крафтить или все крафты невозможны.", "INFO")
    end
    reload() -- Обновляем данные после попытки крафта всех
    draw()
end

-- Главный цикл автокрафта
local function autoCraftLoop()
    while true do
        local needsFullRedraw = false -- Флаг для определения, нужна ли полная перерисовка

        -- Проверяем, изменился ли статус крафта (для перерисовки кнопки)
        if lastCraftingStatus ~= isCrafting then
            lastCraftingStatus = isCrafting
            needsFullRedraw = true
        end

        -- Проверяем, изменился ли выбранный элемент (для перерисовки строки)
        local currentSelectedItemIndex = nil
        if selectedItem then -- Если selectedItem не nil (индекс в dataItems)
            local filteredItems = getFilteredAndSortedItems()
            for i, item in ipairs(filteredItems) do
                -- Находим позицию выбранного item в отфильтрованном списке
                if dataItems[selectedItem] == item then
                    currentSelectedItemIndex = i
                    break
                end
            end
        end
        if lastSelectedItemIndex ~= currentSelectedItemIndex then
            lastSelectedItemIndex = currentSelectedItemIndex
            needsFullRedraw = true
        end

        -- Проверяем, изменился ли текст поиска (для перерисовки таблицы)
        if lastSearchValue ~= search then
            lastSearchValue = search
            currentPage = 1 -- Сбрасываем страницу при изменении поиска
            needsFullRedraw = true
        end

        if isCrafting then
            local now = computer.uptime()
            if now >= nextCraftUpdate then
                -- Принудительное обновление данных ME для режима крафта
                addLog(logs, "INFO: Проверка статуса крафта и обновление данных ME.", "INFO")
                local ok, err = pcall(reload)
                if not ok then
                    addLog(logs, "ERROR: Ошибка в reload (из autoCraftLoop): " .. tostring(err), "ERROR")
                    craftStatus = "Ошибка: обновление данных"
                end
                nextCraftUpdate = now + 30 -- Обновляем ME каждые 30 секунд

                local oldCraftStatus = craftStatus
                local craftMadeThisCycle = false
                -- Проходим по всем элементам и пытаемся скрафтить недостающие
                for i, item in ipairs(dataItems) do
                    if not craftMadeThisCycle then -- Если уже скрафтили что-то в этом цикле, ждем следующего
                        if tryCraftItem(item) then
                            craftMadeThisCycle = true
                            break -- Крафтим по одному за цикл, чтобы дать время ME
                        end
                    end
                end
                save()
                
                -- Если статус крафта изменился или был выполнен крафт, нужна полная перерисовка
                if oldCraftStatus ~= craftStatus or craftMadeThisCycle then
                    needsFullRedraw = true
                end
            end
        else
            -- Если автокрафт не активен, но пришло время обновить данные ME-сети
            local now = computer.uptime()
            if now >= nextCraftUpdate then
                addLog(logs, "INFO: Обновление данных ME-сети (фоновое).", "INFO")
                local ok, err = pcall(reload)
                if not ok then
                    addLog(logs, "ERROR: Ошибка в reload (фоновое): " .. tostring(err), "ERROR")
                    craftStatus = "Ошибка: обновление данных"
                end
                needsFullRedraw = true -- Обновление данных ME всегда требует полной перерисовки, так как меняется таблица
                nextCraftUpdate = now + 30
            end
        end

        if needsFullRedraw then
            draw() -- Полная перерисовка
        else
            -- Частичная перерисовка, если полная не нужна
            -- Обновляем только те элементы, которые могут меняться без полного перерисовывания
            drawLogs() -- Логи могут обновляться независимо
            -- Обновляем статус и прогресс-бар
            local statusText = "Статус: " .. craftStatus
            local statusColor = (craftStatus:find("Ошибка") and COLORS.error) or (isCrafting and COLORS.ok) or COLORS.info
            uoc.drawText(2, 3, statusText, statusColor)
            if uoc.progressBar then
                uoc.progressBar(2, 5, WIDTH - 20, isCrafting and 0.9 or 0, COLORS.progressBg, COLORS.progressBar, COLORS.border)
            end
            g.present() -- Отображаем частичные изменения
        end
        os.sleep(0.1) -- Небольшая задержка для цикла
    end
end

-- Обработчики событий
event.listen("key_down", function(_, _, key, _, _, unicodeChar)
    if changeitem then -- Если в режиме ввода, передаем управление promptForInput
        -- promptForInput сама обрабатывает ввод и возвращает результат
        return
    end

    local needsRedraw = false 

    if searchActive then
        if key == 28 then -- Enter
            searchActive = false
            needsRedraw = true
        elseif key == 14 then -- Backspace
            if unicode.len(search) > 0 then
                search = unicode.sub(search, 1, unicode.len(search) - 1)
                currentPage = 1
                selectedItem = nil
                needsRedraw = true
            end
        elseif unicodeChar then
            search = search .. unicode.char(unicodeChar)
            currentPage = 1
            selectedItem = nil
            needsRedraw = true
        end
    else
        -- Навигация по элементам списка (стрелки вверх/вниз)
        local filteredAndSortedItems = getFilteredAndSortedItems()
        local currentSelectedIndex = nil
        if selectedItem then -- Если selectedItem не nil (индекс в dataItems)
            for i, item in ipairs(filteredAndSortedItems) do
                if dataItems[selectedItem] == item then
                    currentSelectedIndex = i
                    break
                end
            end
        end

        if key == 200 then -- Up arrow
            if #filteredAndSortedItems > 0 then
                if currentSelectedIndex and currentSelectedIndex > 1 then
                    local newIndexInFiltered = currentSelectedIndex - 1
                    selectedItem = nil
                    for k, v in ipairs(dataItems) do
                        if v == filteredAndSortedItems[newIndexInFiltered] then
                            selectedItem = k
                            break
                        end
                    end
                elseif currentPage > 1 then
                    currentPage = currentPage - 1
                    -- Выбираем последний элемент на новой странице
                    local perPage = getItemsPerPage()
                    local newStartIndex = (currentPage - 1) * perPage + 1
                    local newIndexInFiltered = math.min(newStartIndex + perPage - 1, #filteredAndSortedItems)
                    selectedItem = nil
                    for k, v in ipairs(dataItems) do
                        if v == filteredAndSortedItems[newIndexInFiltered] then
                            selectedItem = k
                            break
                        end
                    end
                end
                needsRedraw = true
            end
        elseif key == 208 then -- Down arrow
            if #filteredAndSortedItems > 0 then
                if currentSelectedIndex and currentSelectedIndex < #filteredAndSortedItems then
                    local newIndexInFiltered = currentSelectedIndex + 1
                    selectedItem = nil
                    for k, v in ipairs(dataItems) do
                        if v == filteredAndSortedItems[newIndexInFiltered] then
                            selectedItem = k
                            break
                        end
                    end
                elseif currentPage < getMaxPages() then
                    currentPage = currentPage + 1
                    -- Выбираем первый элемент на новой странице
                    local perPage = getItemsPerPage()
                    local newStartIndex = (currentPage - 1) * perPage + 1
                    selectedItem = nil
                    for k, v in ipairs(dataItems) do
                        if v == filteredAndSortedItems[newStartIndex] then
                            selectedItem = k
                            break
                        end
                    end
                end
                needsRedraw = true
            end
        elseif key == 203 then -- Left arrow (для страниц)
            if currentPage > 1 then
                currentPage = currentPage - 1
                selectedItem = nil
                needsRedraw = true
            end
        elseif key == 205 then -- Right arrow (для страниц)
            if currentPage < getMaxPages() then
                currentPage = currentPage + 1
                selectedItem = nil
                needsRedraw = true
            end
        elseif key == 200 then -- Up arrow for logs (если не активен поиск и не происходит навигация по таблице)
            if not searchActive and logOffset < #logs - 5 then
                logOffset = logOffset + 1
                needsRedraw = true
            end
        elseif key == 208 then -- Down arrow for logs (если не активен поиск и не происходит навигация по таблице)
            if not searchActive and logOffset > 0 then
                logOffset = logOffset - 1
                needsRedraw = true
            end
        end
    end
    
    if needsRedraw then
        draw()
    end
end)

event.listen("mouse_move", function(_, _, x, y)
    if changeitem then return end -- Не реагируем на наведение, если в режиме ввода
    local newButtonHover = updateButtonHover(x, y)
    if newButtonHover ~= buttonHover then
        buttonHover = newButtonHover
        drawButtons() -- Перерисовываем только кнопки
        g.present()
    end
end)

event.listen("touch", function(_, _, x, y, _, _)
    if changeitem then return end -- Не реагируем на клик, если в режиме ввода
    local needsFullRedraw = false -- Флаг для определения, нужна ли полная перерисовка

    local btnWidth = 12
    local btnHeight = 3
    local btnX = WIDTH - btnWidth - 5
    local btnPadding = 2
    local btns = {
        {name = "Крафт всех", action = "craftAll"},
        {name = "Удалить", action = "delete"},
        {name = "Изменить", action = "edit"},
        {name = isCrafting and "Остановить" or "Автокрафт", action = "toggleCraft"},
        {name = "Добавить", action = "add"},
    }

    -- Обработка кликов по основным кнопкам
    for i, btn in ipairs(btns) do
        local btnY = 10 + (i - 1) * (btnHeight + btnPadding)
        if x >= btnX and x <= btnX + btnWidth - 1 and y >= btnY and y <= btnY + btnHeight - 1 then
            if btn.action == "delete" then removeItem()
            elseif btn.action == "edit" then editItem()
            elseif btn.action == "toggleCraft" then if isCrafting then stopCraft() else doCraft() end
            elseif btn.action == "add" then addItem()
            elseif btn.action == "craftAll" then craftAll()
            end
            buttonHover = nil -- Сбрасываем наведение после клика
            needsFullRedraw = true
            goto handled_touch_event -- Переходим к концу обработчика
        end
    end

    -- Обработка кликов по стрелкам страниц и кнопке сортировки
    local arrowBtnW = 4
    local arrowBtnH = 3
    local arrowBtnY = 10 + (#btns * (btnHeight + btnPadding))

    local prevArrowBtnX = btnX
    local nextArrowBtnX = btnX + arrowBtnW + 1
    local sortBtnY = arrowBtnY + arrowBtnH + 2
    local sortBtnW = 12

    if x >= prevArrowBtnX and x <= prevArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        if currentPage > 1 then
            currentPage = currentPage - 1
            selectedItem = nil
            needsFullRedraw = true
        end
        buttonHover = nil
        goto handled_touch_event
    elseif x >= nextArrowBtnX and x <= nextArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        local maxPages = getMaxPages()
        if currentPage < maxPages then
            currentPage = currentPage + 1
            selectedItem = nil
            needsFullRedraw = true
        end
        buttonHover = nil
        goto handled_touch_event
    elseif x >= btnX and x <= btnX + sortBtnW - 1 and y >= sortBtnY and y <= sortBtnY + arrowBtnH - 1 then
        local criteriaList = {"name", "category", "current", "count", "craftSize"}
        local currentCriteriaIndex = 1
        for i, v in ipairs(criteriaList) do
            if v == settings.sortCriteria then
                currentCriteriaIndex = i
                break
            end
            if i == #criteriaList and v ~= settings.sortCriteria then
                currentCriteriaIndex = 0
            end
        end
        currentCriteriaIndex = currentCriteriaIndex + 1
        if currentCriteriaIndex > #criteriaList then
            currentCriteriaIndex = 1
            settings.sortAscending = not settings.sortAscending
        else
            settings.sortAscending = true
        end
        settings.sortCriteria = criteriaList[currentCriteriaIndex]
        currentPage = 1
        selectedItem = nil
        save()
        needsFullRedraw = true
        buttonHover = nil
        goto handled_touch_event
    end

    -- Обработка кликов по строке поиска
    if y >= HEIGHT - 4 and y <= HEIGHT - 4 then
        local searchBarX = 2
        local searchBarWidth = WIDTH - 20
        local clearBtnX = searchBarX + searchBarWidth - 3

        if x >= clearBtnX and x <= clearBtnX + 2 and search ~= "" then -- Клик по [X]
            search = ""
            currentPage = 1
            selectedItem = nil
            needsFullRedraw = true
        else -- Клик по полю поиска
            searchActive = true
            needsFullRedraw = true
        end
        buttonHover = nil
        goto handled_touch_event
    end
    
    -- Сброс searchActive если клик не по поиску
    searchActive = false

    -- Обработка кликов по элементам таблицы
    local filteredAndSortedItems = getFilteredAndSortedItems()
    local perPage = getItemsPerPage()
    local startIndex = (currentPage - 1) * perPage + 1
    local itemsStartY = 10
    local itemsEndY = itemsStartY + perPage - 1
  
    if y >= itemsStartY and y <= itemsEndY then
        local idxOnPage = y - itemsStartY
        local actualIndexInFiltered = startIndex + idxOnPage
        if filteredAndSortedItems[actualIndexInFiltered] then
            -- Находим реальный индекс в dataItems
            local newSelectedItem = nil
            for k, v in ipairs(dataItems) do
                if v == filteredAndSortedItems[actualIndexInFiltered] then 
                    newSelectedItem = k
                    break 
                end
            end
            if newSelectedItem ~= selectedItem then
                selectedItem = newSelectedItem
                needsFullRedraw = true
            end
        end
    end
    buttonHover = nil -- Сбрасываем наведение, если мы кликнули не на кнопку

    ::handled_touch_event:: -- Метка для goto
    if needsFullRedraw then
        draw()
    end
end)


-------------------- Старт --------------------
checkComponents()
bindGpu()
WIDTH, HEIGHT = g.maxResolution()
g.setResolution(WIDTH, HEIGHT)
addLog(logs, "INFO: Программа запущена", "INFO")

-- Начальная загрузка и перерисовка
local ok, err = pcall(function()
    load() -- Загружаем данные
    reload() -- Обновляем данные ME
end)
if not ok then
    addLog(logs, "ERROR: Ошибка при начальной загрузке данных: " .. tostring(err), "ERROR")
    -- Программа не завершается, но данные могут быть неактуальными
end
draw() -- Начальная полная отрисовка

-- Запуск основного цикла
local ok, err = pcall(autoCraftLoop)
if not ok then
    addLog(logs, "ERROR: Фатальная ошибка в autoCraftLoop: " .. tostring(err), "ERROR")
    draw() -- Показываем ошибку на экране перед завершением
    while true do os.sleep(1) end -- Оставляем программу висящей, чтобы пользователь мог прочитать лог
end
