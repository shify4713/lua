local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode")
local term = require("term")
local computer = require("computer")
local gpu = component.gpu
local me = component.me_interface

-- Configuration
local DATA_FILE = "/home/BD.txt"
local LIB_PATH = "/lib/oc.lua"
local LIB_URL = "https://www.dropbox.com/s/cgfytt8g174a6vs/libPrecraft.lua?dl=1"
local AUTHORIZED_USERS = {['KReaTlVNuY'] = true, ['4ertik_'] = true}
local COLORS = {
    button = 0x00BFFF, buttonActive = 0x1E90FF, border = 0x44475a, text = 0xF8F8F2,
    bg = 0x23242b, error = 0xFF5555, ok = 0x50FA7B, log = 0x8BE9FD,
    progress_bg = 0x44475a, progress_fg = 0x50FA7B, select = 0x31313A,
    select_active = 0x44B3FF, search_bg = 0x282B36, search_border = 0x00BFFF,
    search_cross = 0xFF5555, search_hint = 0x888888, input_bg = 0x282B36,
    input_border = 0x00BFFF, input_text = 0xF8F8F2
}
local WIDTH, HEIGHT = gpu.getResolution()
local debug = true
local craftStatus = "Waiting..."
local nextCraftUpdate = 0
local isCrafting = false
local logs = {}
local dataItems = {}
local settings = {sortCriteria = "name", sortAscending = true}
local search = ""
local selectedItem = nil
local currentPage = 1
local changeItem = false
local searchActive = false
local logOffset = 0
local lastRequestedItem = nil
local lastRequestTime = 0
local buttonHover = nil
local inputMode = nil
local inputFields = {}
local eventHandlers = {touch = nil, scroll = nil, key_down = nil}

-- Load Library
local function loadLibrary()
    if not fs.exists(LIB_PATH) then
        io.stdout:write("oc.lua not found. Downloading...\n")
        local success, err = shell.execute("wget -f " .. LIB_URL .. " " .. LIB_PATH)
        if not success then error("Failed to download oc.lua: " .. tostring(err)) end
    end
    return require("oc")
end
local oc = loadLibrary()

-- Initialize Data File
local function initDataFile()
    if not fs.exists(DATA_FILE) then
        local data = {items = {}, settings = {sortCriteria = "name", sortAscending = true}}
        local file = io.open(DATA_FILE, "w")
        if file then
            file:write(require("serialization").serialize(data))
            file:close()
            io.stdout:write("Created new BD.txt\n")
        else
            error("Failed to create BD.txt")
        end
    end
end

-- Logging
local function addLog(text, lvl)
    lvl = lvl or "INFO"
    table.insert(logs, string.format("%-7s %s", "[" .. lvl .. "]", text))
    while #logs > 20 do table.remove(logs, 1) end
end

-- Item Filtering and Sorting
local function getFilteredAndSortedItems()
    local filtered = {}
    for _, item in ipairs(dataItems) do
        if search == "" or unicode.lower(item.name or ""):find(unicode.lower(search), 1, true) then
            if not item.category then item.category = "No Category" end
            table.insert(filtered, item)
        end
    end
    table.sort(filtered, function(a, b)
        local valA, valB
        if settings.sortCriteria == "name" then
            valA, valB = unicode.lower(a.name or ""), unicode.lower(b.name or "")
        elseif settings.sortCriteria == "current" then
            valA, valB = tonumber(a.current) or 0, tonumber(b.current) or 0
        elseif settings.sortCriteria == "count" then
            valA, valB = tonumber(a.count) or 0, tonumber(b.count) or 0
        elseif settings.sortCriteria == "craftSize" then
            valA, valB = tonumber(a.craftSize) or 0, tonumber(b.craftSize) or 0
        elseif settings.sortCriteria == "category" then
            valA, valB = unicode.lower(a.category or "No Category"), unicode.lower(b.category or "No Category")
        end
        return settings.sortAscending and valA < valB or valA > valB
    end)
    return filtered
end

local function getItemsPerPage() return HEIGHT - 20 end
local function getMaxPages()
    return math.max(1, math.ceil(#getFilteredAndSortedItems() / getItemsPerPage()))
end
local function clampPage()
    currentPage = math.max(1, math.min(currentPage, getMaxPages()))
end

-- GUI Rendering
local function clear()
    gpu.setBackground(COLORS.bg)
    gpu.fill(1, 1, WIDTH, HEIGHT, " ")
    gpu.setForeground(COLORS.text)
end

local function drawHeader()
    oc.text(2, 2, "&ePreCraft Enhanced")
    gpu.setBackground(COLORS.progress_fg)
    gpu.fill(1, 3, WIDTH, 1, " ")
    gpu.setBackground(COLORS.bg)
    oc.text(2, 4, "Status: " .. craftStatus, (craftStatus:find("Error") and COLORS.error) or COLORS.ok)
    oc.progressBar = oc.progressBar or function(x, y, w, progress)
        gpu.setBackground(COLORS.progress_bg)
        gpu.fill(x, y, w, 1, " ")
        gpu.setBackground(COLORS.progress_fg)
        gpu.fill(x, y, math.floor(w * progress), 1, " ")
    end
    oc.progressBar(2, 5, WIDTH - 20, isCrafting and 0.9 or 0)
    oc.text(2, 6, "Page: " .. currentPage .. "/" .. getMaxPages())
    oc.right(WIDTH - 2, 6, "Total Crafting: " .. #dataItems)
end

local function drawItems()
    local filteredItems = getFilteredAndSortedItems()
    local x, y = 2, 8
    local totalWidth = WIDTH - 25
    local colWidths = {
        name = math.floor(totalWidth * 0.35),
        category = math.floor(totalWidth * 0.15),
        current = math.floor(totalWidth * 0.15),
        target = math.floor(totalWidth * 0.15),
        craftSize = totalWidth - math.floor(totalWidth * 0.35) - math.floor(totalWidth * 0.15) * 3
    }
    gpu.setForeground(COLORS.select_active)
    gpu.set(x, y, "┌" .. string.rep("─", colWidths.name) .. "┬" .. string.rep("─", colWidths.category) .. "┬" .. string.rep("─", colWidths.current) .. "┬" .. string.rep("─", colWidths.target) .. "┬" .. string.rep("─", colWidths.craftSize) .. "┐")
    gpu.set(x, y + 1, "│")
    gpu.setForeground(COLORS.ok)
    gpu.set(x + 1, y + 1, string.format("%-" .. colWidths.name .. "s", "Name"))
    gpu.setForeground(COLORS.select_active)
    gpu.set(x + colWidths.name + 1, y + 1, "│")
    gpu.setForeground(COLORS.ok)
    gpu.set(x + colWidths.name + 2, y + 1, string.format("%-" .. colWidths.category .. "s", "Category"))
    gpu.setForeground(COLORS.select_active)
    gpu.set(x + colWidths.name + colWidths.category + 2, y + 1, "│")
    gpu.setForeground(COLORS.ok)
    gpu.set(x + colWidths.name + colWidths.category + 3, y + 1, string.format("%-" .. colWidths.current .. "s", "Current"))
    gpu.setForeground(COLORS.select_active)
    gpu.set(x + colWidths.name + colWidths.category + colWidths.current + 3, y + 1, "│")
    gpu.setForeground(COLORS.ok)
    gpu.set(x + colWidths.name + colWidths.category + colWidths.current + 4, y + 1, string.format("%-" .. colWidths.target .. "s", "Target"))
    gpu.setForeground(COLORS.select_active)
    gpu.set(x + colWidths.name + colWidths.category + colWidths.current + colWidths.target + 4, y + 1, "│")
    gpu.setForeground(COLORS.ok)
    gpu.set(x + colWidths.name + colWidths.category + colWidths.current + colWidths.target + 5, y + 1, string.format("%-" .. colWidths.craftSize .. "s", "Craft Size"))
    gpu.setForeground(COLORS.select_active)
    gpu.set(x + colWidths.name + colWidths.category + colWidths.current + colWidths.target + colWidths.craftSize + 5, y + 1, "│")
    gpu.set(x, y + 2, "├" .. string.rep("─", colWidths.name) .. "┼" .. string.rep("─", colWidths.category) .. "┼" .. string.rep("─", colWidths.current) .. "┼" .. string.rep("─", colWidths.target) .. "┼" .. string.rep("─", colWidths.craftSize) .. "┤")
    local perPage = getItemsPerPage()
    local startIndex = (currentPage - 1) * perPage + 1
    for i = startIndex, math.min(#filteredItems, startIndex + perPage - 1) do
        local item = filteredItems[i]
        local isSelected = (selectedItem and dataItems[selectedItem] == item)
        local row = y + 2 + (i - startIndex)
        gpu.setBackground(isSelected and COLORS.select_active or COLORS.bg)
        gpu.fill(x, row, totalWidth + 2, 1, " ")
        gpu.setForeground(tonumber(item.current or 0) < tonumber(item.count or 0) and COLORS.error or COLORS.text)
        gpu.set(x, row, "│")
        local nameStr = tostring(item.name or "<??>")
        if unicode.len(nameStr) > colWidths.name then nameStr = unicode.sub(nameStr, 1, colWidths.name - 1) .. "…" end
        gpu.set(x + 1, row, string.format("%-" .. colWidths.name .. "s", nameStr))
        gpu.set(x + colWidths.name + 1, row, "│")
        local categoryStr = tostring(item.category or "No Category")
        if unicode.len(categoryStr) > colWidths.category then categoryStr = unicode.sub(categoryStr, 1, colWidths.category - 1) .. "…" end
        gpu.set(x + colWidths.name + 2, row, string.format("%-" .. colWidths.category .. "s", categoryStr))
        gpu.set(x + colWidths.name + colWidths.category + 2, row, "│")
        local currentStr = tostring(item.current or 0)
        if unicode.len(currentStr) > colWidths.current then currentStr = unicode.sub(currentStr, 1, colWidths.current - 1) .. "…" end
        gpu.set(x + colWidths.name + colWidths.category + 3, row, string.format("%-" .. colWidths.current .. "s", currentStr))
        gpu.set(x + colWidths.name + colWidths.category + colWidths.current + 3, row, "│")
        local targetStr = tostring(item.count or 0)
        if unicode.len(targetStr) > colWidths.target then targetStr = unicode.sub(targetStr, 1, colWidths.target - 1) .. "…" end
        gpu.set(x + colWidths.name + colWidths.category + colWidths.current + 4, row, string.format("%-" .. colWidths.target .. "s", targetStr))
        gpu.set(x + colWidths.name + colWidths.category + colWidths.current + colWidths.target + 4, row, "│")
        local craftSizeStr = tostring(item.craftSize or 0)
        if unicode.len(craftSizeStr) > colWidths.craftSize then craftSizeStr = unicode.sub(craftSizeStr, 1, colWidths.craftSize - 1) .. "…" end
        gpu.set(x + colWidths.name + colWidths.category + colWidths.current + colWidths.target + 5, row, string.format("%-" .. colWidths.craftSize .. "s", craftSizeStr))
        gpu.set(x + colWidths.name + colWidths.category + colWidths.current + colWidths.target + colWidths.craftSize + 5, row, "│")
    end
    gpu.setForeground(COLORS.select_active)
    gpu.set(x, y + perPage + 2, "└" .. string.rep("─", colWidths.name) .. "┴" .. string.rep("─", colWidths.category) .. "┴" .. string.rep("─", colWidths.current) .. "┴" .. string.rep("─", colWidths.target) .. "┴" .. string.rep("─", colWidths.craftSize) .. "┘")
    gpu.setBackground(COLORS.bg)
    gpu.setForeground(COLORS.text)
end

local function drawSearchBar()
    local x, y, w, h = 2, HEIGHT - 10, WIDTH - 20, 3
    gpu.setBackground(COLORS.search_bg)
    gpu.fill(x, y, w, h, " ")
    gpu.setForeground(COLORS.search_border)
    gpu.set(x, y, "┌" .. string.rep("─", w - 2) .. "┐")
    gpu.set(x, y + h - 1, "└" .. string.rep("─", w - 2) .. "┘")
    for i = 1, h - 2 do gpu.set(x, y + i, "│") gpu.set(x + w - 1, y + i, "│") end
    gpu.setForeground(COLORS.search_cross)
    gpu.set(x + w - 3, y + 1, search ~= "" and "×" or " ")
    gpu.setForeground(searchActive and COLORS.ok or COLORS.search_hint)
    local display = search == "" and "Search: enter item name..." or search .. (searchActive and "_" or "")
    if unicode.len(display) > w - 7 then display = unicode.sub(display, unicode.len(display) - (w - 7) + 1) end
    gpu.set(x + 2, y + 1, display)
    gpu.setBackground(COLORS.bg)
    gpu.setForeground(COLORS.text)
end

local function drawLogs()
    local logLines, x, y = 5, 2, HEIGHT - logLines
    gpu.setForeground(COLORS.log)
    for i = 1, logLines do
        local logIndex = #logs - logLines + i - logOffset
        if logIndex > 0 then gpu.set(x, y + i - 1, logs[logIndex] or "") end
    end
    gpu.setForeground(COLORS.text)
end

local function drawButtons()
    local btnWidth, btnHeight, btnX, btnPadding = 12, 3, WIDTH - 12 - 5, 2
    local btns = {
        {name = "Remove", action = "delete"},
        {name = "Edit", action = "edit"},
        {name = isCrafting and "Stop" or "Start", action = "toggleCraft"},
        {name = "Add", action = "add"}
    }
    for i, btn in ipairs(btns) do
        local btnY = 10 + (i - 1) * (btnHeight + btnPadding)
        oc.drawbutton(btnX, btnY, btnWidth, btnHeight, COLORS.text,
            buttonHover == btn.action and COLORS.buttonActive or COLORS.button, btn.name)
    end
    local arrowBtnW, arrowBtnH = 4, 3
    local arrowBtnY = 10 + (#btns * (btnHeight + btnPadding))
    local prevArrowBtnX, nextArrowBtnX = btnX, btnX + arrowBtnW + 1
    oc.drawbutton(prevArrowBtnX, arrowBtnY, arrowBtnW, arrowBtnH,
        currentPage > 1 and COLORS.text or COLORS.search_hint,
        buttonHover == "prevPage" and COLORS.buttonActive or (currentPage > 1 and COLORS.button or COLORS.border), "<-")
    oc.drawbutton(nextArrowBtnX, arrowBtnY, arrowBtnW, arrowBtnH,
        currentPage < getMaxPages() and COLORS.text or COLORS.search_hint,
        buttonHover == "nextPage" and COLORS.buttonActive or (currentPage < getMaxPages() and COLORS.button or COLORS.border), "->")
    local sortBtnY, sortBtnW = arrowBtnY + arrowBtnH + 2, 12
    local sortText = "Sort: " .. (settings.sortCriteria == "name" and "Name" or
        settings.sortCriteria == "current" and "Curr" or settings.sortCriteria == "count" and "Targ" or
        settings.sortCriteria == "craftSize" and "Size" or "Cat") .. (settings.sortAscending and "↑" or "↓")
    if unicode.len(sortText) > sortBtnW then sortText = unicode.sub(sortText, 1, sortBtnW - 1) end
    oc.drawbutton(btnX, sortBtnY, sortBtnW, arrowBtnH, COLORS.text,
        buttonHover == "sort" and COLORS.buttonActive or COLORS.button, sortText)
end

local function draw()
    if changeItem then return end
    clear()
    drawHeader()
    drawItems()
    drawSearchBar()
    drawLogs()
    drawButtons()
end

-- Input Handling
local function promptForInput(label, keyName, isNumeric, defaultValue)
    local currentInput = inputFields[keyName] or defaultValue or ""
    local baseY = HEIGHT - 15
    local fieldsConfig = {
        {label = "Name:", key = "name", x = 2, y = baseY + 3, w = 40},
        {label = "Category:", key = "category", x = 2, y = baseY + 5, w = 40},
        {label = "Target:", key = "count", x = 2, y = baseY + 7, w = 20},
        {label = "Craft Size:", key = "craftSize", x = 2, y = baseY + 9, w = 20}
    }
    local currentFieldConfig = fieldsConfig[1]
    for _, config in ipairs(fieldsConfig) do
        if config.key == keyName then currentFieldConfig = config break end
    end
    local function redrawInputScreen(activeInput)
        clear()
        oc.text(2, baseY, (inputMode == "add") and "Add Item" or "Edit: " .. (dataItems[selectedItem].name or "<?>"), COLORS.ok)
        oc.text(2, baseY + 1, "Place item in ME interface slot 1 (for adding).", COLORS.ok)
        oc.text(2, baseY + 12, "Enter: save/skip, Ctrl+C: cancel", COLORS.text)
        for _, field in ipairs(fieldsConfig) do
            local isActiveField = (field.key == keyName)
            gpu.setBackground(COLORS.input_bg)
            gpu.fill(field.x, field.y, field.w, 3, " ")
            gpu.setForeground(COLORS.input_border)
            gpu.set(field.x, field.y, "┌" .. string.rep("─", field.w - 2) .. "┐")
            gpu.set(field.x, field.y + 2, "└" .. string.rep("─", field.w - 2) .. "┘")
            gpu.set(field.x, field.y + 1, "│")
            gpu.set(field.x + field.w - 1, field.y + 1, "│")
            gpu.setForeground(COLORS.text)
            gpu.set(field.x + 1, field.y, field.label)
            gpu.setBackground(COLORS.input_bg)
            gpu.fill(field.x + 1, field.y + 1, field.w - 2, 1, " ")
            gpu.setForeground(isActiveField and COLORS.ok or COLORS.input_text)
            local displayValue = isActiveField and activeInput .. "_" or inputFields[field.key] or ""
            if displayValue == "" then displayValue = "Enter value..." end
            if unicode.len(displayValue) > field.w - 4 then
                displayValue = unicode.sub(displayValue, unicode.len(displayValue) - (field.w - 4) + 1)
            end
            gpu.set(field.x + 2, field.y + 1, displayValue)
        end
        gpu.setBackground(COLORS.bg)
        gpu.setForeground(COLORS.text)
    end
    redrawInputScreen(currentInput)
    term.setCursor(currentFieldConfig.x + 2 + unicode.len(currentInput), currentFieldConfig.y + 1)
    term.setCursorBlink(true)
    local result = nil
    while true do
        local ev, _, char, code = event.pullMultiple("key_down", "interrupted")
        if ev == "interrupted" then
            term.setCursorBlink(false)
            return nil
        elseif ev == "key_down" then
            if code == 28 then -- Enter
                result = currentInput
                break
            elseif code == 14 and #currentInput > 0 then -- Backspace
                currentInput = unicode.sub(currentInput, 1, -2)
            elseif code == 211 then -- Delete
                currentInput = ""
            elseif char > 0 then
                local charStr = unicode.char(char)
                if unicode.len(charStr) > 0 and not charStr:match("[\x00-\x1F\x7F]") and unicode.len(currentInput) < currentFieldConfig.w - 4 then
                    currentInput = currentInput .. charStr
                end
            end
            redrawInputScreen(currentInput)
            term.setCursor(currentFieldConfig.x + 2 + unicode.len(currentInput), currentFieldConfig.y + 1)
        end
    end
    term.setCursorBlink(false)
    if result == "" then result = defaultValue end
    if isNumeric then
        local numResult = tonumber(result)
        if not numResult then
            addLog("WARN: Invalid number for '" .. label .. "'. Using default: " .. tostring(defaultValue), "WARN")
            return defaultValue
        end
        return numResult
    end
    return result
end

-- Data Management
local function reload()
    local file = io.open(DATA_FILE, "r")
    if not file then error("Failed to open BD.txt") end
    local content = file:read("*all")
    file:close()
    local data = require("serialization").unserialize(content) or {items = {}, settings = {sortCriteria = "name", sortAscending = true}}
    dataItems = data.items or {}
    settings = data.settings or {sortCriteria = "name", sortAscending = true}
    clampPage()
    for _, item in ipairs(dataItems) do
        local qty = 0
        local success, stackList = pcall(me.getItemsInNetwork, {name = item.id, damage = item.dmg})
        if success and stackList then
            for i = 1, stackList.n or 0 do
                local stack = stackList[i]
                if stack and stack.name == item.id and (item.dmg == nil or stack.damage == item.dmg) then
                    qty = qty + (stack.size or 0)
                end
            end
        end
        item.current = qty
    end
    if lastRequestedItem and computer.uptime() - lastRequestTime > 30 then
        addLog("WARN: Timeout for '" .. (lastRequestedItem.name or "<?>") .. "'. Resetting.", "WARN")
        lastRequestedItem = nil
        lastRequestTime = 0
    end
end

local function save()
    local data = {items = dataItems, settings = settings}
    local file = io.open(DATA_FILE, "w")
    if file then
        file:write(require("serialization").serialize(data))
        file:close()
    else
        addLog("ERROR: Failed to save to BD.txt", "ERROR")
    end
end

local function addItem()
    changeItem = true
    inputMode = "add"
    inputFields = {name = "", category = "", count = "0", craftSize = "1"}
    local success, stackList = pcall(me.getItemsInNetwork)
    local itemInSlot = nil
    if success and stackList and stackList.n and stackList.n > 0 then
        itemInSlot = stackList[1]
    end
    inputFields.name = promptForInput("Name:", "name", false, itemInSlot and (itemInSlot.label or itemInSlot.name) or "")
    if inputFields.name == nil then changeItem = false inputMode = nil inputFields = {} draw() return end
    if inputFields.name == "" then inputFields.name = itemInSlot and (itemInSlot.label or itemInSlot.name) or "" end
    inputFields.category = promptForInput("Category:", "category", false, "No Category")
    if inputFields.category == nil then changeItem = false inputMode = nil inputFields = {} draw() return end
    if inputFields.category == "" then inputFields.category = "No Category" end
    inputFields.count = promptForInput("Target:", "count", true, "0")
    if inputFields.count == nil then changeItem = false inputMode = nil inputFields = {} draw() return end
    inputFields.craftSize = promptForInput("Craft Size:", "craftSize", true, "1")
    if inputFields.craftSize == nil then changeItem = false inputMode = nil inputFields = {} draw() return end
    if itemInSlot then
        table.insert(dataItems, {
            name = inputFields.name,
            category = inputFields.category,
            id = itemInSlot.name,
            dmg = itemInSlot.damage,
            count = inputFields.count,
            craftSize = inputFields.craftSize,
            current = 0
        })
        save()
        addLog("INFO: Added item: " .. inputFields.name .. " (Category: " .. inputFields.category .. ")", "INFO")
        currentPage = getMaxPages()
        selectedItem = nil
    else
        addLog("ERROR: No item detected in ME network!", "ERROR")
    end
    changeItem = false
    inputMode = nil
    inputFields = {}
    draw()
end

local function editItem()
    if not selectedItem or not dataItems[selectedItem] then
        addLog("ERROR: No item selected!", "ERROR")
        return
    end
    local item = dataItems[selectedItem]
    changeItem = true
    inputMode = "edit"
    inputFields = {name = item.name, category = item.category, count = tostring(item.count), craftSize = tostring(item.craftSize)}
    inputFields.name = promptForInput("Name:", "name", false, item.name)
    if inputFields.name == nil then changeItem = false inputMode = nil inputFields = {} draw() return end
    inputFields.category = promptForInput("Category:", "category", false, item.category)
    if inputFields.category == nil then changeItem = false inputMode = nil inputFields = {} draw() return end
    inputFields.count = promptForInput("Target:", "count", true, tostring(item.count))
    if inputFields.count == nil then changeItem = false inputMode = nil inputFields = {} draw() return end
    inputFields.craftSize = promptForInput("Craft Size:", "craftSize", true, tostring(item.craftSize))
    if inputFields.craftSize == nil then changeItem = false inputMode = nil inputFields = {} draw() return end
    item.name, item.category, item.count, item.craftSize = inputFields.name, inputFields.category, inputFields.count, inputFields.craftSize
    save()
    addLog("INFO: Edited: " .. item.name .. " (Category: " .. (item.category or "No Category") .. ")", "INFO")
    changeItem = false
    inputMode = nil
    inputFields = {}
    draw()
end

local function removeItem()
    if not selectedItem or not dataItems[selectedItem] then
        addLog("ERROR: No item selected!", "ERROR")
        return
    end
    addLog("WARN: Removed: " .. (dataItems[selectedItem].name or "<??>"), "WARN")
    table.remove(dataItems, selectedItem)
    selectedItem = nil
    clampPage()
    save()
    draw()
end

local function tryCraftItem(item)
    local count, current = tonumber(item.count) or 0, tonumber(item.current) or 0
    if current >= count then return false end
    if lastRequestedItem and lastRequestedItem.name == item.name then
        addLog("INFO: Item '" .. (item.name or "<??>") .. "' recently requested. Waiting.", "INFO")
        craftStatus = "Waiting: " .. (item.name or "<??>")
        return false
    end
    local success, craftables = pcall(me.getCraftables, {name = item.id, damage = item.dmg})
    if not success or not craftables or craftables.n == 0 then
        addLog("ERROR: No craftable recipe for " .. (item.name or "<??>") .. ": " .. tostring(craftables), "ERROR")
        craftStatus = "Error: No recipe"
        return false
    end
    local craftable = craftables[1]
    local success, request = pcall(craftable.request, craftable, item.craftSize)
    if not success or not request then
        addLog("ERROR: Failed to request craft for " .. (item.name or "<??>") .. ": " .. tostring(request), "ERROR")
        craftStatus = "Error: Craft failed"
        return false
    end
    craftStatus = "Crafting: " .. (item.name or "<??>")
    addLog("INFO: Crafting " .. item.craftSize .. "x " .. (item.name or "<??>"), "INFO")
    lastRequestedItem = {name = item.name}
    lastRequestTime = computer.uptime()
    return true
end

local function autoCraftLoop()
    while true do
        if isCrafting and computer.uptime() >= nextCraftUpdate then
            local success, err = pcall(reload)
            if not success then
                addLog("ERROR: Reload error: " .. tostring(err), "ERROR")
                craftStatus = "Error: Data reload"
            else
                local craftMade = false
                for _, item in ipairs(dataItems) do
                    if not craftMade and tryCraftItem(item) then
                        craftMade = true
                        break
                    end
                end
                save()
                nextCraftUpdate = computer.uptime() + 30
            end
            if not changeItem then draw() end
        end
        os.sleep(0.5)
    end
end

-- Event Handlers
local function updateButtonHover(x, y)
    local btnWidth, btnHeight, btnX, btnPadding = 12, 3, WIDTH - 12 - 5, 2
    local btns = {
        {name = "Remove", action = "delete"},
        {name = "Edit", action = "edit"},
        {name = isCrafting and "Stop" or "Start", action = "toggleCraft"},
        {name = "Add", action = "add"}
    }
    for i, btn in ipairs(btns) do
        local btnY = 10 + (i - 1) * (btnHeight + btnPadding)
        if x >= btnX and x <= btnX + btnWidth - 1 and y >= btnY and y <= btnY + btnHeight - 1 then
            return btn.action
        end
    end
    local arrowBtnW, arrowBtnH = 4, 3
    local arrowBtnY = 10 + (#btns * (btnHeight + btnPadding))
    local prevArrowBtnX, nextArrowBtnX = btnX, btnX + arrowBtnW + 1
    local sortBtnY, sortBtnW = arrowBtnY + arrowBtnH + 2, 12
    if x >= prevArrowBtnX and x <= prevArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        return "prevPage"
    elseif x >= nextArrowBtnX and x <= nextArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        return "nextPage"
    elseif x >= btnX and x <= btnX + sortBtnW - 1 and y >= sortBtnY and y <= sortBtnY + arrowBtnH - 1 then
        return "sort"
    end
    return nil
end

local function onTouch(_, _, x, y, _, nick)
    if not AUTHORIZED_USERS[nick] then return end
    if changeItem then return end
    local btnWidth, btnHeight, btnX, btnPadding = 12, 3, WIDTH - 12 - 5, 2
    local btns = {
        {name = "Remove", action = "delete"},
        {name = "Edit", action = "edit"},
        {name = isCrafting and "Stop" or "Start", action = "toggleCraft"},
        {name = "Add", action = "add"}
    }
    for i, btn in ipairs(btns) do
        local btnY = 10 + (i - 1) * (btnHeight + btnPadding)
        if x >= btnX and x <= btnX + btnWidth - 1 and y >= btnY and y <= btnY + btnHeight - 1 then
            if btn.action == "delete" then removeItem()
            elseif btn.action == "edit" then editItem()
            elseif btn.action == "toggleCraft" then
                isCrafting = not isCrafting
                craftStatus = isCrafting and "Autocrafting..." or "Stopped"
                addLog(isCrafting and "INFO: Autocraft started" or "WARN: Autocraft stopped", isCrafting and "INFO" or "WARN")
            elseif btn.action == "add" then addItem()
            end
            buttonHover = nil
            draw()
            return
        end
    end
    local arrowBtnW, arrowBtnH = 4, 3
    local arrowBtnY = 10 + (#btns * (btnHeight + btnPadding))
    local prevArrowBtnX, nextArrowBtnX = btnX, btnX + arrowBtnW + 1
    local sortBtnY, sortBtnW = arrowBtnY + arrowBtnH + 2, 12
    if x >= prevArrowBtnX and x <= prevArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 and currentPage > 1 then
        currentPage = currentPage - 1
        selectedItem = nil
        buttonHover = nil
        draw()
        return
    elseif x >= nextArrowBtnX and x <= nextArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 and currentPage < getMaxPages() then
        currentPage = currentPage + 1
        selectedItem = nil
        buttonHover = nil
        draw()
        return
    elseif x >= btnX and x <= btnX + sortBtnW - 1 and y >= sortBtnY and y <= sortBtnY + arrowBtnH - 1 then
        local criteriaList = {"name", "category", "current", "count", "craftSize"}
        local currentIdx = 1
        for i, v in ipairs(criteriaList) do if v == settings.sortCriteria then currentIdx = i break end end
        currentIdx = currentIdx + 1
        if currentIdx > #criteriaList then
            currentIdx = 1
            settings.sortAscending = not settings.sortAscending
        else
            settings.sortAscending = true
        end
        settings.sortCriteria = criteriaList[currentIdx]
        currentPage = 1
        selectedItem = nil
        buttonHover = nil
        save()
        draw()
        return
    end
    if y >= HEIGHT - 10 and y <= HEIGHT - 8 then
        searchActive = false
        if x >= 2 + (WIDTH - 20) - 3 and x <= 2 + (WIDTH - 20) - 1 and search ~= "" then
            search = ""
            currentPage = 1
            selectedItem = nil
            buttonHover = nil
            draw()
            return
        elseif x >= 2 + 1 and x <= 2 + (WIDTH - 20) - 4 then
            searchActive = true
            buttonHover = nil
            draw()
            return
        end
    else
        searchActive = false
    end
    local filteredItems = getFilteredAndSortedItems()
    local perPage = getItemsPerPage()
    local startIndex = (currentPage - 1) * perPage + 1
    local itemsStartY, itemsEndY = 10, 10 + perPage - 1
    if y >= itemsStartY and y <= itemsEndY then
        local idxOnPage = y - itemsStartY
        local actualIndex = startIndex + idxOnPage
        if filteredItems[actualIndex] then
            for k, v in ipairs(dataItems) do
                if v == filteredItems[actualIndex] then
                    selectedItem = k
                    break
                end
            end
        end
        buttonHover = nil
        draw()
        return
    end
    buttonHover = nil
    draw()
end

local function onScroll(_, _, _, _, direction, nick)
    if not AUTHORIZED_USERS[nick] or changeItem then return end
    if direction == 1 and currentPage > 1 then
        currentPage = currentPage - 1
        selectedItem = nil
    elseif direction == -1 and currentPage < getMaxPages() then
        currentPage = currentPage + 1
        selectedItem = nil
    end
    draw()
end

local function onKeyDown(_, _, char, code, nick)
    if not AUTHORIZED_USERS[nick] or changeItem then return end
    local filteredItems = getFilteredAndSortedItems()
    local perPage = getItemsPerPage()
    if searchActive then
        if code == 14 then search = unicode.sub(search, 1, -2)
        elseif code == 211 then search = ""
        elseif code == 28 then searchActive = false
        elseif char > 0 then
            local charStr = unicode.char(char)
            if unicode.len(charStr) > 0 and not charStr:match("[\x00-\x1F\x7F]") and unicode.len(search) < WIDTH - 25 then
                search = search .. charStr
            end
        end
        currentPage = 1
        selectedItem = nil
        buttonHover = nil
    else
        if code == 200 then -- Up
            local startIndex = (currentPage - 1) * perPage + 1
            local visibleItems = {}
            for i = startIndex, math.min(#filteredItems, startIndex + perPage - 1) do
                table.insert(visibleItems, filteredItems[i])
            end
            local currentSelectedIdx = nil
            if selectedItem then
                for i, v in ipairs(visibleItems) do
                    if v == dataItems[selectedItem] then currentSelectedIdx = i break end
                end
            end
            if #visibleItems == 0 then
                selectedItem = nil
            elseif currentSelectedIdx and currentSelectedIdx > 1 then
                for k, v in ipairs(dataItems) do
                    if v == visibleItems[currentSelectedIdx - 1] then selectedItem = k break end
                end
            elseif #visibleItems > 0 then
                for k, v in ipairs(dataItems) do
                    if v == visibleItems[#visibleItems] then selectedItem = k break end
                end
            end
        elseif code == 208 then -- Down
            local startIndex = (currentPage - 1) * perPage + 1
            local visibleItems = {}
            for i = startIndex, math.min(#filteredItems, startIndex + perPage - 1) do
                table.insert(visibleItems, filteredItems[i])
            end
            local currentSelectedIdx = nil
            if selectedItem then
                for i, v in ipairs(visibleItems) do
                    if v == dataItems[selectedItem] then currentSelectedIdx = i break end
                end
            end
            if #visibleItems == 0 then
                selectedItem = nil
            elseif currentSelectedIdx and currentSelectedIdx < #visibleItems then
                for k, v in ipairs(dataItems) do
                    if v == visibleItems[currentSelectedIdx + 1] then selectedItem = k break end
                end
            elseif #visibleItems > 0 then
                for k, v in ipairs(dataItems) do
                    if v == visibleItems[1] then selectedItem = k break end
                end
            end
        elseif code == 203 then -- Left
            if currentPage > 1 then currentPage = currentPage - 1 selectedItem = nil end
        elseif code == 205 then -- Right
            if currentPage < getMaxPages() then currentPage = currentPage + 1 selectedItem = nil end
        elseif code == 200 and event.pull("mod_down", _, 42) then -- Shift + Up
            logOffset = math.min(logOffset + 1, math.max(0, #logs - 5))
        elseif code == 208 and event.pull("mod_down", _, 42) then -- Shift + Down
            logOffset = math.max(logOffset - 1, 0)
        end
    end
    draw()
end

-- Initialization and Main Loop
local function init()
    if debug then gpu.setResolution(160, 50) WIDTH, HEIGHT = 160, 50 end
    initDataFile()
    addLog("INFO: Program started", "INFO")
    reload()
    eventHandlers.touch = event.listen("touch", onTouch)
    eventHandlers.scroll = event.listen("scroll", onScroll)
    eventHandlers.key_down = event.listen("key_down", onKeyDown)
    for eventName, handler in pairs(eventHandlers) do
        if not handler then
            addLog("ERROR: Failed to register " .. eventName .. " handler", "ERROR")
        else
            addLog("INFO: Registered " .. eventName .. " handler", "INFO")
        end
    end
    draw()
end

local function main()
    local success, err = pcall(function()
        init()
        autoCraftLoop()
    end)
    if not success then
        addLog("ERROR: Fatal error: " .. tostring(err), "ERROR")
        for _, handler in pairs(eventHandlers) do
            if handler then event.cancel(handler) end
        end
        draw()
        os.sleep(2)
        computer.shutdown(true)
    end
end

main()
