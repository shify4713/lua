local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode")
local term = require("term")
local computer = require("computer")
local g = component.gpu
local me = component.me_interface

-- Пути и библиотека
local DATA_FILE = "/home/BD.txt"
local LIB_PATH = "/lib/ultimateOC.lua"
local LIB_URL = "https://raw.githubusercontent.com/shify4713/lua/refs/heads/main/lib-gemeni"

-- Проверка доступности компонентов
local function checkComponents()
    if not component.isAvailable("gpu") then
        io.stderr:write("Ошибка: GPU недоступен\n")
        os.exit(1)
    end
    if not component.isAvailable("me_interface") then
        io.stderr:write("Ошибка: ME-интерфейс недоступен\n")
        os.exit(1)
    end
end

-- Проверяем наличие библиотеки
if not fs.exists(LIB_PATH) then
    io.stdout:write("ultimateOC.lua не найден. Скачивание...\n")
    local success, err = shell.execute("wget -f " .. LIB_URL .. " " .. LIB_PATH)
    if not success then
        io.stderr:write("Не удалось скачать ultimateOC.lua: ", tostring(err), "\n")
        os.exit(1)
    end
end
local ok, uoc = pcall(require, "ultimateOC")
if not ok then
    io.stderr:write("Не удалось загрузить ultimateOC.lua: ", tostring(uoc), "\n")
    os.exit(1)
end

-- Проверяем файл данных
if not fs.exists(DATA_FILE) then
    uoc.savef(DATA_FILE, {items = {}, settings = {sortCriteria = "name", sortAscending = true}})
end

-------------------- Настройки --------------------
local COLORS = {
    button = 0x00BFFF,
    buttonActive = 0x1E90FF,
    border = 0x44475a,
    text = 0xF8F8F2,
    shadow = 0x282A36,
    bg = 0x23242b,
    error = 0xFF5555,
    ok = 0x50FA7B,
    log = 0x8BE9FD,
    progress_bg = 0x44475a,
    progress_fg = 0x50FA7B,
    select = 0x31313A,
    select_active = 0x44B3FF,
    search_bg = 0x282B36,
    search_border = 0x00BFFF,
    search_cross = 0xFF5555,
    search_hint = 0x888888,
    bar_shadow = 0x181920,
    warning = 0xFFB86C,
}
local WIDTH, HEIGHT = 110, 40
local craftStatus = "Ожидание..."
local nextCraftUpdate = 0
local isCrafting = false
local logs = {}
local dataItems = {}
local settings = {sortCriteria = "name", sortAscending = true}
local search = ""
local selectedItem = nil
local currentPage = 1
local changeitem = false
local searchActive = false
local logOffset = 0
local lastRequestedItem = nil
local lastRequestTime = 0
local lastDrawnState = {} -- Для оптимизации перерисовки

-------------------- Логгирование --------------------
local function addLog(logs, text, lvl)
    lvl = lvl or "INFO"
    local t = string.format("[%s] %s", lvl, text)
    table.insert(logs, t)
    while #logs > 50 do table.remove(logs, 1) end
end

-------------------- Вспомогательные функции --------------------
local function getFilteredAndSortedItems()
    local filtered = {}
    for i, item in ipairs(dataItems) do
        if search == "" or unicode.lower(item.name or ""):find(unicode.lower(search), 1, true) then
            if not item.category then item.category = "Без категории" end
            table.insert(filtered, item)
        end
    end
    table.sort(filtered, function(a, b)
        local valA, valB
        if settings.sortCriteria == "name" then
            valA = unicode.lower(a.name or "")
            valB = unicode.lower(b.name or "")
        elseif settings.sortCriteria == "current" then
            valA = tonumber(a.current) or 0
            valB = tonumber(b.current) or 0
        elseif settings.sortCriteria == "count" then
            valA = tonumber(a.count) or 0
            valB = tonumber(b.count) or 0
        elseif settings.sortCriteria == "craftSize" then
            valA = tonumber(a.craftSize) or 0
            valB = tonumber(b.craftSize) or 0
        elseif settings.sortCriteria == "category" then
            valA = unicode.lower(a.category or "Без категории")
            valB = unicode.lower(b.category or "Без категории")
        end
        if settings.sortAscending then
            return valA < valB
        else
            return valA > valB
        end
    end)
    return filtered
end

local function getItemsPerPage()
    return HEIGHT - 24 - 7
end

local function getMaxPages()
    local filteredItems = getFilteredAndSortedItems()
    local perPage = getItemsPerPage()
    return math.max(1, math.ceil(#filteredItems / perPage))
end

local function clampPage()
    local maxPages = getMaxPages()
    currentPage = math.max(1, math.min(currentPage, maxPages))
end

-------------------- Визуал --------------------
local function clear()
    g.setBackground(COLORS.bg)
    g.fill(1, 1, WIDTH, HEIGHT, " ")
    g.setForeground(COLORS.text)
end

local function shadowRect(x, y, w, h)
    g.setBackground(COLORS.bar_shadow)
    g.fill(x + 1, y + h, w, 1, " ")
    g.fill(x + w, y, 1, h, " ")
    g.setBackground(COLORS.bg)
end

local function drawHeader()
    if lastDrawnState.header == craftStatus then return end
    uoc.drawText(3, 3, "Ultimate AutoCraft", COLORS.ok, true)
    g.setBackground(COLORS.progress_fg)
    g.fill(2, 4, WIDTH - 2, 1, " ")
    shadowRect(2, 4, WIDTH - 2, 1)
    g.setBackground(COLORS.bg)
    uoc.drawText(WIDTH - 34, 3, "Статус: " .. craftStatus,
        (craftStatus:find("Ошибка") and COLORS.error) or COLORS.ok)
    uoc.progressBar(3, 5, WIDTH - 6, isCrafting and 0.9 or 0)
    local maxPages = getMaxPages()
    uoc.drawText(3, 6, "Страница: " .. currentPage .. "/" .. maxPages, COLORS.text)
    lastDrawnState.header = craftStatus
end

local function drawLogs()
    if lastDrawnState.logs == logOffset then return end
    uoc.drawLogs(3, HEIGHT - 9, logs, 4, COLORS.log, logOffset)
    lastDrawnState.logs = logOffset
end

local function drawItems()
    local filteredAndSortedItems = getFilteredAndSortedItems()
    local stateKey = table.concat({currentPage, selectedItem or 0, search}, "|")
    if lastDrawnState.items == stateKey then return end

    local x, y = 2, 8
    local totalWidth = WIDTH - 4
    local col_name = math.floor(totalWidth * 0.35)
    local col_category = math.floor(totalWidth * 0.15)
    local col_now = math.floor(totalWidth * 0.15)
    local col_hold = math.floor(totalWidth * 0.15)
    local col_once = totalWidth - col_name - col_category - col_now - col_hold

    g.setForeground(COLORS.select_active)
    g.set(x, y, "┌" .. string.rep("─", col_name) .. "┬" .. string.rep("─", col_category) .. "┬" .. string.rep("─", col_now) .. "┬" .. string.rep("─", col_hold) .. "┬" .. string.rep("─", col_once) .. "┐")
    g.set(x, y + 1, "│")
    g.setForeground(COLORS.ok)
    g.set(x + 1, y + 1, string.format("%-" .. col_name .. "s", " Название"))
    g.setForeground(COLORS.select_active)
    g.set(x + col_name + 1, y + 1, "│")
    g.setForeground(COLORS.ok)
    g.set(x + col_name + 2, y + 1, string.format("%-" .. col_category .. "s", " Категория"))
    g.setForeground(COLORS.select_active)
    g.set(x + col_name + col_category + 2, y + 1, "│")
    g.setForeground(COLORS.ok)
    g.set(x + col_name + col_category + 3, y + 1, string.format("%-" .. col_now .. "s", " В наличии"))
    g.setForeground(COLORS.select_active)
    g.set(x + col_name + col_category + col_now + 3, y + 1, "│")
    g.setForeground(COLORS.ok)
    g.set(x + col_name + col_category + col_now + 4, y + 1, string.format("%-" .. col_hold .. "s", " Держать"))
    g.setForeground(COLORS.select_active)
    g.set(x + col_name + col_category + col_now + col_hold + 4, y + 1, "│")
    g.setForeground(COLORS.ok)
    g.set(x + col_name + col_category + col_now + col_hold + 5, y + 1, string.format("%-" .. col_once .. "s", " За раз"))
    g.setForeground(COLORS.select_active)
    g.set(x + col_name + col_category + col_now + col_hold + col_once + 5, y + 1, "│")
    g.set(x, y + 2, "├" .. string.rep("─", col_name) .. "┼" .. string.rep("─", col_category) .. "┼" .. string.rep("─", col_now) .. "┼" .. string.rep("─", col_hold) .. "┼" .. string.rep("─", col_once) .. "┤")

    local perPage = getItemsPerPage()
    local startIndex = (currentPage - 1) * perPage + 1
    for i = startIndex, math.min(#filteredAndSortedItems, startIndex + perPage - 1) do
        local it = filteredAndSortedItems[i]
        local isSel = (selectedItem and dataItems[selectedItem] and it == dataItems[selectedItem])
        local row = y + 2 + (i - startIndex) + 1
        g.setBackground(isSel and COLORS.select_active or COLORS.bg)
        g.fill(x, row, totalWidth + 2, 1, " ")
        g.setForeground(tonumber(it.current or 0) < tonumber(it.count or 0) and COLORS.warning or COLORS.text)
        g.set(x, row, "│")
        local nameStr = tostring(it.name or "<??>")
        if unicode.len(nameStr) > col_name then
            nameStr = unicode.sub(nameStr, 1, col_name - 1) .. "…"
        end
        g.set(x + 1, row, string.format("%-" .. col_name .. "s", nameStr))
        g.set(x + col_name + 1, row, "│")
        local categoryStr = tostring(it.category or "Без категории")
        if unicode.len(categoryStr) > col_category then
            categoryStr = unicode.sub(categoryStr, 1, col_category - 1) .. "…"
        end
        g.set(x + col_name + 2, row, string.format("%-" .. col_category .. "s", categoryStr))
        g.set(x + col_name + col_category + 2, row, "│")
        local current_val = tonumber(it.current) or 0
        local current_str = tostring(current_val)
        if unicode.len(current_str) > col_now then
            current_str = unicode.sub(current_str, 1, col_now - 1) .. "…"
        end
        g.set(x + col_name + col_category + 3, row, string.format("%-" .. col_now .. "s", current_str))
        g.set(x + col_name + col_category + col_now + 3, row, "│")
        local hold_val = tonumber(it.count) or 0
        local hold_str = tostring(hold_val)
        if unicode.len(hold_str) > col_hold then
            hold_str = unicode.sub(hold_str, 1, col_hold - 1) .. "…"
        end
        g.set(x + col_name + col_category + col_now + 4, row, string.format("%-" .. col_hold .. "s", hold_str))
        g.set(x + col_name + col_category + col_now + col_hold + 4, row, "│")
        local craftSize_val = tonumber(it.craftSize) or 0
        local craftSize_str = tostring(craftSize_val)
        if unicode.len(craftSize_str) > col_once then
            craftSize_str = unicode.sub(craftSize_str, 1, col_once - 1) .. "…"
        end
        g.set(x + col_name + col_category + col_now + col_hold + 5, row, string.format("%-" .. col_once .. "s", craftSize_str))
        g.set(x + col_name + col_category + col_now + col_hold + col_once + 5, row, "│")
    end
    for i = math.min(#filteredAndSortedItems, startIndex + perPage - 1) + 1, startIndex + perPage - 1 do
        local row = y + 2 + (i - startIndex) + 1
        g.setBackground(COLORS.bg)
        g.fill(x, row, totalWidth + 2, 1, " ")
    end
    local lastRow = y + perPage + 3
    g.setForeground(COLORS.select_active)
    g.set(x, lastRow, "└" .. string.rep("─", col_name) .. "┴" .. string.rep("─", col_category) .. "┴" .. string.rep("─", col_now) .. "┴" .. string.rep("─", col_hold) .. "┴" .. string.rep("─", col_once) .. "┘")
    g.setForeground(COLORS.text)
    lastDrawnState.items = stateKey
end

local function drawSearchBar()
    if lastDrawnState.search == search .. tostring(searchActive) then return end
    local x, y, w, h = 3, HEIGHT - 17, WIDTH - 6, 3
    uoc.roundRect(x, y, w, h, COLORS.search_border, COLORS.search_bg)
    g.setBackground(COLORS.search_bg)
    g.fill(x + 1, y + 1, w - 2, h - 2, " ")
    g.setForeground(COLORS.search_cross)
    g.set(x + w - 3, y + 1, (search ~= "" and "×" or " "))
    g.setForeground(searchActive and COLORS.ok or COLORS.search_hint)
    local display = search
    if display == "" then display = "Поиск: введите часть названия..." end
    if searchActive then display = display .. "_" end
    local maxlen = w - 7
    if unicode.len(display) > maxlen then
        display = unicode.sub(display, unicode.len(display) - maxlen + 2)
    end
    g.set(x + 2, y + 1, display)
    g.setBackground(COLORS.bg)
    g.setForeground(COLORS.text)
    lastDrawnState.search = search .. tostring(searchActive)
end

local function drawButtons()
    local btnState = tostring(isCrafting) .. table.concat({settings.sortCriteria, tostring(settings.sortAscending)}, "|")
    if lastDrawnState.buttons == btnState then return end
    local btns = {
        {name = "Удалить", x = WIDTH - 60, action = "delete", hover = false},
        {name = "Изменить", x = WIDTH - 45, action = "edit", hover = false},
        {name = isCrafting and "Остановить" or "Автокрафт", x = WIDTH - 30, action = "toggleCraft", hover = false},
        {name = "Добавить", x = WIDTH - 15, action = "add", hover = false},
        {name = "Крафт всех", x = WIDTH - 75, action = "craftAll", hover = false},
    }
    for i, v in ipairs(btns) do
        uoc.animatedButton(v.x, HEIGHT - 4, 12, 3, v.name, v.hover, COLORS.button, COLORS.buttonActive, COLORS.text)
    end
    local arrowBtnW = 4
    local arrowBtnH = 3
    local arrowBtnY = HEIGHT - 4
    local arrowBtnPadding = 1
    local prevArrowBtnX = 2
    local nextArrowBtnX = prevArrowBtnX + arrowBtnW + arrowBtnPadding
    local sortBtnX = nextArrowBtnX + arrowBtnW + arrowBtnPadding
    local sortBtnW = 14
    local maxPages = getMaxPages()
    local prevEnabled = (currentPage > 1)
    uoc.animatedButton(prevArrowBtnX, arrowBtnY, arrowBtnW, arrowBtnH, "<-", false,
        prevEnabled and COLORS.button or COLORS.border,
        prevEnabled and COLORS.buttonActive or COLORS.border,
        prevEnabled and COLORS.text or COLORS.search_hint)
    local nextEnabled = (currentPage < maxPages)
    uoc.animatedButton(nextArrowBtnX, arrowBtnY, arrowBtnW, arrowBtnH, "->", false,
        nextEnabled and COLORS.button or COLORS.border,
        nextEnabled and COLORS.buttonActive or COLORS.border,
        nextEnabled and COLORS.text or COLORS.search_hint)
    local sortBtnMainText = "Сортировать"
    local sortIndicatorText = ""
    if settings.sortCriteria == "name" then
        sortIndicatorText = "Название"
    elseif settings.sortCriteria == "current" then
        sortIndicatorText = "В наличии"
    elseif settings.sortCriteria == "count" then
        sortIndicatorText = "Держать"
    elseif settings.sortCriteria == "craftSize" then
        sortIndicatorText = "За раз"
    elseif settings.sortCriteria == "category" then
        sortIndicatorText = "Категория"
    end
    sortIndicatorText = sortIndicatorText .. (settings.sortAscending and " ^" or " v")
    uoc.animatedButton(sortBtnX, arrowBtnY, sortBtnW, arrowBtnH,
        sortBtnMainText, false, COLORS.button, COLORS.buttonActive, COLORS.text,
        sortIndicatorText, COLORS.text)
    lastDrawnState.buttons = btnState
end

local function draw()
    clear()
    drawHeader()
    drawItems()
    drawSearchBar()
    drawLogs()
    drawButtons()
end

-------------------- IO и действия --------------------
local function reload()
    local ok, res = pcall(uoc.loadf, DATA_FILE)
    if not ok then
        addLog(logs, "ERROR: Ошибка загрузки BD.txt: " .. tostring(res))
        dataItems = {}
        settings = {sortCriteria = "name", sortAscending = true}
    else
        res = res or {items = {}, settings = {sortCriteria = "name", sortAscending = true}}
        dataItems = res.items or {}
        settings = res.settings or {sortCriteria = "name", sortAscending = true}
    end
    clampPage()
    for _, item in ipairs(dataItems) do
        local qty = 0
        local stackList = {}
        local ok, res = pcall(me.getItemsInNetwork, {id = item.id, damage = item.dmg})
        if ok then stackList = res or {} end
        if stackList and stackList.n and stackList.n > 0 then
            for _, stack in ipairs(stackList) do
                if stack.name == item.id and (item.dmg == nil or stack.damage == item.dmg) then
                    qty = qty + (stack.size or stack.qty or 0)
                end
            end
        else
            local ok2, d = pcall(me.getItemDetail, {id = item.id, dmg = item.dmg})
            if ok2 and d then
                qty = qty + (d.qty or d.size or 0)
            end
        end
        local craftingJobs_ok, craftingJobs = pcall(me.getCraftingJobs)
        if craftingJobs_ok and craftingJobs and craftingJobs.n then
            for _, job in ipairs(craftingJobs) do
                if job.output and job.output.id == item.id and
                   (item.dmg == nil or job.output.damage == item.dmg) then
                    qty = qty + (job.output.size or job.output.qty or 0)
                    if lastRequestedItem and lastRequestedItem.id == item.id and
                       (lastRequestedItem.dmg == nil or lastRequestedItem.dmg == item.dmg) then
                        addLog(logs, "DEBUG: Предмет '" .. (item.name or "<??>") .. "' в активных крафтах. Сброс lastRequestedItem.")
                        lastRequestedItem = nil
                        lastRequestTime = 0
                    end
                end
            end
        end
        item.current = qty
    end
    if lastRequestedItem and computer.uptime() - lastRequestTime > 30 then
        addLog(logs, "WARN: Таймаут ожидания для '" .. (lastRequestedItem.id or "<??>") .. "'. Сброс lastRequestedItem.")
        lastRequestedItem = nil
        lastRequestTime = 0
    end
end

local function save()
    local ok, err = pcall(uoc.savef, DATA_FILE, {items = dataItems, settings = settings})
    if not ok then addLog(logs, "ERROR: Ошибка сохранения: " .. tostring(err)) end
end

local function resetSelection()
    search = ""
    currentPage = 1
    selectedItem = nil
end

local function addItem()
    changeitem = true
    clear()
    uoc.drawText(10, HEIGHT - 8, "Вставьте предмет в 1-й слот ME интерфейса и введите параметры.", COLORS.ok)
    uoc.drawText(10, HEIGHT - 7, "Название: ", COLORS.text)
    term.setCursor(20, HEIGHT - 7)
    local name = tostring(io.read())
    uoc.drawText(10, HEIGHT - 6, "Категория: ", COLORS.text)
    term.setCursor(20, HEIGHT - 6)
    local category = tostring(io.read())
    uoc.drawText(10, HEIGHT - 5, "Держать (число): ", COLORS.text)
    term.setCursor(29, HEIGHT - 5)
    local count = tonumber(io.read()) or 0
    uoc.drawText(10, HEIGHT - 4, "Крафт за раз (число): ", COLORS.text)
    term.setCursor(32, HEIGHT - 4)
    local craftSize = tonumber(io.read()) or 1
    local stack = nil
    local ok, res = pcall(me.getStackInSlot, 1)
    if ok then stack = res end
    if stack then
        table.insert(dataItems, {
            name = name,
            category = category ~= "" and category or "Без категории",
            id = stack.id,
            dmg = stack.dmg,
            count = count,
            craftSize = craftSize
        })
        save()
        addLog(logs, "INFO: Добавлен предмет: " .. name .. " (Категория: " .. (category ~= "" and category or "Без категории") .. ")")
        currentPage = getMaxPages()
        selectedItem = nil
    else
        addLog(logs, "ERROR: Нет предмета в слоте 1!")
    end
    changeitem = false
    draw()
end

local function editItem()
    if not selectedItem then return addLog(logs, "ERROR: Не выбран предмет!") end
    local item = dataItems[selectedItem]
    changeitem = true
    clear()
    uoc.drawText(10, HEIGHT - 8, "Изменение: " .. (item.name or "<??>"), COLORS.ok)
    uoc.drawText(10, HEIGHT - 7, "Новое имя (Enter пропустить): ", COLORS.text)
    term.setCursor(40, HEIGHT - 7)
    local name = tostring(io.read())
    uoc.drawText(10, HEIGHT - 6, "Новая категория (Enter пропустить): ", COLORS.text)
    term.setCursor(40, HEIGHT - 6)
    local category = tostring(io.read())
    uoc.drawText(10, HEIGHT - 5, "Новое держать (число, Enter пропустить): ", COLORS.text)
    term.setCursor(54, HEIGHT - 5)
    local countstr = tostring(io.read())
    local count = tonumber(countstr)
    uoc.drawText(10, HEIGHT - 4, "Новый крафт за раз (число, Enter пропустить): ", COLORS.text)
    term.setCursor(55, HEIGHT - 4)
    local csstr = tostring(io.read())
    local cs = tonumber(csstr)
    if name and name ~= "" then item.name = name end
    if category and category ~= "" then item.category = category end
    if countstr ~= "" and count then item.count = count end
    if csstr ~= "" and cs then item.craftSize = cs end
    save()
    addLog(logs, "INFO: Изменено: " .. item.name .. " (Категория: " .. (item.category or "Без категории") .. ")")
    changeitem = false
    draw()
end

local function removeItem()
    if not selectedItem then return addLog(logs, "ERROR: Не выбран предмет!") end
    addLog(logs, "WARN: Удалён: " .. (dataItems[selectedItem].name or "<??>"))
    table.remove(dataItems, selectedItem)
    selectedItem = nil
    clampPage()
    save()
    draw()
end

local function doCraft()
    isCrafting = true
    craftStatus = "Автокрафт..."
    save()
    addLog(logs, "INFO: Запущен автокрафт")
    draw()
end

local function stopCraft()
    isCrafting = false
    craftStatus = "Остановлено"
    addLog(logs, "WARN: Остановлен автокрафт")
    draw()
end

local function craftAll()
    isCrafting = true
    craftStatus = "Крафт всех..."
    addLog(logs, "INFO: Запущен крафт всех предметов")
    local craftMade = false
    for i, item in ipairs(dataItems) do
        if tryCraftItem(item) then
            craftMade = true
        end
    end
    if not craftMade then
        craftStatus = "Все предметы в норме"
        addLog(logs, "INFO: Нет предметов для крафта")
    end
    draw()
end

local function tryCraftItem(itemToCraft)
    local count = tonumber(itemToCraft.count) or 0
    local current = tonumber(itemToCraft.current) or 0
    if current >= count then
        addLog(logs, "DEBUG: Предмет '" .. (itemToCraft.name or "<??>") .. "' уже в достаточном количестве (" .. current .. " >= " .. count .. ").")
        return false
    end
    addLog(logs, "DEBUG: Попытка крафта: " .. (itemToCraft.name or "<??>") .. " (Текущее: " .. current .. ", Нужно: " .. count .. ")")
    if lastRequestedItem and lastRequestedItem.id == itemToCraft.id and
       (itemToCraft.dmg == nil or lastRequestedItem.dmg == itemToCraft.dmg) then
        addLog(logs, "INFO: Предмет '" .. (itemToCraft.name or "<??>") .. "' недавно запрошен. Ожидание.")
        craftStatus = "Ожидание: " .. (itemToCraft.name or "<??>")
        return false
    end
    local cpus_ok, cpus = pcall(me.getCpus)
    if not cpus_ok then
        addLog(logs, "ERROR: Ошибка получения CPU: " .. tostring(cpus))
        craftStatus = "Ошибка: ME CPU"
        return false
    end
    cpus = cpus or {}
    local freeCpu = nil
    for _, cpu in ipairs(cpus) do
        if not cpu.busy then freeCpu = cpu.name break end
    end
    if freeCpu then
        addLog(logs, "DEBUG: Найден свободный CPU: " .. tostring(freeCpu))
        local craftables_ok, craftables = pcall(me.getCraftables, {name = itemToCraft.id, damage = itemToCraft.dmg})
        if not craftables_ok then
            addLog(logs, "ERROR: Ошибка получения рецептов: " .. tostring(craftables))
            craftStatus = "Ошибка: ME Рецепты"
            return false
        end
        craftables = craftables or {n = 0}
        if craftables.n and craftables.n >= 1 then
            addLog(logs, "DEBUG: Найден рецепт для: " .. (itemToCraft.name or "<??>"))
            local actualAE2RecipeOutput = (craftables[1].output and craftables[1].output.size) or 1
            if actualAE2RecipeOutput == 0 then actualAE2RecipeOutput = 1 end
            local quantityToRequest = tonumber(itemToCraft.craftSize) or 1
            if quantityToRequest == 0 then quantityToRequest = 1 end
            local estimatedActualOutputFromAE2 = math.ceil(quantityToRequest / actualAE2RecipeOutput) * actualAE2RecipeOutput
            if current + estimatedActualOutputFromAE2 >= count then
                addLog(logs, "INFO: Предмет '" .. (itemToCraft.name or "<??>") .. "' достигнет цели (" .. estimatedActualOutputFromAE2 .. "x).")
                craftStatus = "Достаточно: " .. (itemToCraft.name or "<??>")
                return false
            end
            if quantityToRequest > 0 then
                local succ, req = pcall(function() return craftables[1].request(quantityToRequest, false, freeCpu) end)
                if succ and req then
                    local actualCommittedAmount = req.size or req.qty or quantityToRequest
                    craftStatus = "Крафт: " .. (itemToCraft.name or "<??>")
                    addLog(logs, "INFO: Запрос крафта " .. quantityToRequest .. "x " .. (itemToCraft.name or "<??>") .. " на CPU " .. tostring(freeCpu))
                    lastRequestedItem = {id = itemToCraft.id, dmg = itemToCraft.dmg, expectedOutput = actualCommittedAmount}
                    lastRequestTime = computer.uptime()
                    return true
                else
                    craftStatus = "Ошибка: крафт отклонен"
                    addLog(logs, "ERROR: Не удалось крафтить " .. (itemToCraft.name or "<??>") .. ": " .. tostring(req))
                    return false
                end
            else
                addLog(logs, "DEBUG: Количество для крафта <= 0 для: " .. (itemToCraft.name or "<??>"))
                return false
            end
        else
            craftStatus = "Ошибка: нет рецепта " .. (itemToCraft.name or "<??>")
            addLog(logs, "ERROR: Нет рецепта для " .. (itemToCraft.name or "<??>"))
            return false
        end
    else
        craftStatus = "Ошибка: нет свободных CPU"
        addLog(logs, "ERROR: Нет свободных CPU")
        return false
    end
end

local function autoCraftLoop()
    addLog(logs, "DEBUG: Запуск autoCraftLoop")
    while true do
        if isCrafting then
            local now = computer.uptime()
            if now >= nextCraftUpdate then
                addLog(logs, "DEBUG: Цикл автокрафта")
                local ok, err = pcall(reload)
                if not ok then
                    addLog(logs, "ERROR: Ошибка в reload: " .. tostring(err))
                    craftStatus = "Ошибка: обновление данных"
                else
                    local craftMadeThisCycle = false
                    for i, item in ipairs(dataItems) do
                        if not craftMadeThisCycle then
                            if tryCraftItem(item) then
                                craftMadeThisCycle = true
                                break
                            end
                        end
                    end
                    save()
                    nextCraftUpdate = now + 30
                    addLog(logs, "DEBUG: Конец цикла автокрафта. Крафт: " .. tostring(craftMadeThisCycle))
                end
            end
        end
        draw()
        os.sleep(0.2)
    end
end

-------------------- События --------------------
local function updateButtonHover(x, y)
    local btns = {
        {name = "Удалить", x = WIDTH - 60, action = "delete", hover = false},
        {name = "Изменить", x = WIDTH - 45, action = "edit", hover = false},
        {name = isCrafting and "Остановить" or "Автокрафт", x = WIDTH - 30, action = "toggleCraft", hover = false},
        {name = "Добавить", x = WIDTH - 15, action = "add", hover = false},
        {name = "Крафт всех", x = WIDTH - 75, action = "craftAll", hover = false},
    }
    local arrowBtnW = 4
    local arrowBtnH = 3
    local arrowBtnY = HEIGHT - 4
    local arrowBtnPadding = 1
    local prevArrowBtnX = 2
    local nextArrowBtnX = prevArrowBtnX + arrowBtnW + arrowBtnPadding
    local sortBtnX = nextArrowBtnX + arrowBtnW + arrowBtnPadding
    local sortBtnW = 14
    for i, btn in ipairs(btns) do
        local btnY = HEIGHT - 4
        local btnW = 12
        local btnH = 3
        if x >= btn.x and x <= btn.x + btnW - 1 and y >= btnY and y <= btnY + btnH - 1 then
            btns[i].hover = true
        end
    end
    if x >= prevArrowBtnX and x <= prevArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        return true, "prevPage"
    elseif x >= nextArrowBtnX and x <= nextArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        return true, "nextPage"
    elseif x >= sortBtnX and x <= sortBtnX + sortBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        return true, "sort"
    end
    return false, nil
end

event.listen("touch", function(_, _, x, y, _, _)
    if changeitem then return end
    local btns = {
        {name = "Удалить", x = WIDTH - 75, action = "delete"},
        {name = "Изменить", x = WIDTH - 60, action = "edit"},
        {name = isCrafting and "Остановить" or "Автокрафт", x = WIDTH - 45, action = "toggleCraft"},
        {name = "Добавить", x = WIDTH - 30, action = "add"},
        {name = "Крафт всех", x = WIDTH - 15, action = "craftAll"},
    }
    for i, btn in ipairs(btns) do
        local btnY = HEIGHT - 4
        local btnW = 12
        local btnH = 3
        if x >= btn.x and x <= btn.x + btnW - 1 and y >= btnY and y <= btnY + btnH - 1 then
            addLog(logs, "DEBUG: Кнопка '" .. btn.name .. "' нажата")
            if btn.action == "delete" then removeItem()
            elseif btn.action == "edit" then editItem()
            elseif btn.action == "toggleCraft" then if isCrafting then stopCraft() else doCraft() end
            elseif btn.action == "add" then addItem()
            elseif btn.action == "craftAll" then craftAll()
            end
            draw()
            return
        end
    end
    local arrowBtnW = 4
    local arrowBtnH = 3
    local arrowBtnY = HEIGHT - 4
    local arrowBtnPadding = 1
    local prevArrowBtnX = 2
    local nextArrowBtnX = prevArrowBtnX + arrowBtnW + arrowBtnPadding
    local sortBtnX = nextArrowBtnX + arrowBtnW + arrowBtnPadding
    local sortBtnW = 14
    if x >= prevArrowBtnX and x <= prevArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        addLog(logs, "DEBUG: Кнопка '<-' нажата")
        if currentPage > 1 then
            currentPage = currentPage - 1
            selectedItem = nil
            draw()
        end
        return
    elseif x >= nextArrowBtnX and x <= nextArrowBtnX + arrowBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        addLog(logs, "DEBUG: Кнопка '->' нажата")
        local maxPages = getMaxPages()
        if currentPage < maxPages then
            currentPage = currentPage + 1
            selectedItem = nil
            draw()
        end
        return
    elseif x >= sortBtnX and x <= sortBtnX + sortBtnW - 1 and y >= arrowBtnY and y <= arrowBtnY + arrowBtnH - 1 then
        addLog(logs, "DEBUG: Кнопка 'Сортировать' нажата")
        local criteriaList = {"name", "category", "current", "count", "craftSize"}
        local currentCriteriaIndex = 1
        for i, v in ipairs(criteriaList) do
            if v == settings.sortCriteria then
                currentCriteriaIndex = i
                break
            end
            if i == #criteriaList and v ~= settings.sortCriteria then
                currentCriteriaIndex = 0
            end
        end
        currentCriteriaIndex = currentCriteriaIndex + 1
        if currentCriteriaIndex > #criteriaList then
            currentCriteriaIndex = 1
            settings.sortAscending = not settings.sortAscending
        else
            settings.sortAscending = true
        end
        settings.sortCriteria = criteriaList[currentCriteriaIndex]
        currentPage = 1
        selectedItem = nil
        save()
        draw()
        return
    end
    if y >= HEIGHT - 17 and y <= HEIGHT - 15 then
        searchActive = false
        if x >= 3 + (WIDTH - 6) - 3 and x <= 3 + (WIDTH - 6) - 1 and search ~= "" then
            search = ""
            currentPage = 1
            selectedItem = nil
            draw()
            return
        end
        if x >= 3 + 1 and x <= 3 + (WIDTH - 6) - 4 then
            searchActive = true
            draw()
            return
        end
    else
        searchActive = false
    end
    local filteredAndSortedItems = getFilteredAndSortedItems()
    local perPage = getItemsPerPage()
    local startIndex = (currentPage - 1) * perPage + 1
    local itemsStartY = 11
    local itemsEndY = itemsStartY + perPage - 1
    if y >= itemsStartY and y <= itemsEndY then
        local idxOnPage = (y - itemsStartY)
        local actualIndexInFiltered = startIndex + idxOnPage
        if filteredAndSortedItems[actualIndexInFiltered] then
            for k, v in ipairs(dataItems) do
                if v == filteredAndSortedItems[actualIndexInFiltered] then selectedItem = k break end
            end
        end
        draw()
        return
    end
    draw()
end)

event.listen("key_down", function(_, _, key, _, _)
    if changeitem then return end
    local filteredAndSortedItems = getFilteredAndSortedItems()
    local perPage = getItemsPerPage()
    local maxPages = getMaxPages()
    if searchActive then
        addLog(logs, "DEBUG: Ввод в поиске, клавиша: " .. key)
        if key == 14 then
            search = search:sub(1, -2)
        elseif key == 211 then
            search = ""
        elseif key == 28 then
            searchActive = false
        elseif key >= 32 and key < 128 then
            if unicode.len(search) < WIDTH - 15 then
                search = search .. unicode.char(key)
            end
        end
        currentPage = 1
        selectedItem = nil
    else
        addLog(logs, "DEBUG: Нажата клавиша: " .. key)
        if key == 200 then
            local currentSelectedItemInFiltered = nil
            local startIndex = (currentPage - 1) * perPage + 1
            local visibleItems = {}
            for i = startIndex, math.min(#filteredAndSortedItems, startIndex + perPage - 1) do
                table.insert(visibleItems, filteredAndSortedItems[i])
            end
            if selectedItem then
                for i, v in ipairs(visibleItems) do
                    if v == dataItems[selectedItem] then
                        currentSelectedItemInFiltered = i
                        break
                    end
                end
            end
            if #visibleItems == 0 then selectedItem = nil
            elseif currentSelectedItemInFiltered and currentSelectedItemInFiltered > 1 then
                selectedItem = nil
                for k, v in ipairs(dataItems) do
                    if v == visibleItems[currentSelectedItemInFiltered - 1] then selectedItem = k break end
                end
            elseif #visibleItems > 0 then
                selectedItem = nil
                for k, v in ipairs(dataItems) do
                    if v == visibleItems[#visibleItems] then selectedItem = k break end
                end
            end
        elseif key == 208 then
            local currentSelectedItemInFiltered = nil
            local startIndex = (currentPage - 1) * perPage + 1
            local visibleItems = {}
            for i = startIndex, math.min(#filteredAndSortedItems, startIndex + perPage - 1) do
                table.insert(visibleItems, filteredAndSortedItems[i])
            end
            if selectedItem then
                for i, v in ipairs(visibleItems) do
                    if v == dataItems[selectedItem] then
                        currentSelectedItemInFiltered = i
                        break
                    end
                end
            end
            if #visibleItems == 0 then selectedItem = nil
            elseif currentSelectedItemInFiltered and currentSelectedItemInFiltered < #visibleItems then
                selectedItem = nil
                for k, v in ipairs(dataItems) do
                    if v == visibleItems[currentSelectedItemInFiltered + 1] then selectedItem = k break end
                end
            elseif #visibleItems > 0 then
                selectedItem = nil
                for k, v in ipairs(dataItems) do
                    if v == visibleItems[1] then selectedItem = k break end
                end
            end
        elseif key == 203 then
            if currentPage > 1 then
                currentPage = currentPage - 1
                selectedItem = nil
            end
        elseif key == 205 then
            if currentPage < maxPages then
                currentPage = currentPage + 1
                selectedItem = nil
            end
        elseif key == 200 and not searchActive then -- Page Up для прокрутки логов
            logOffset = math.min(logOffset + 1, #logs - 4)
        elseif key == 208 and not searchActive then -- Page Down для прокрутки логов
            logOffset = math.max(logOffset - 1, 0)
        end
    end
    draw()
end)

-------------------- Старт --------------------
checkComponents()
g.setResolution(WIDTH, HEIGHT)
addLog(logs, "DEBUG: Программа запущена")
local ok, err = pcall(reload)
if not ok then
    addLog(logs, "ERROR: Ошибка при начальной загрузке: " .. tostring(err))
    draw()
    while true do os.sleep(1) end
end
draw()
local ok, err = pcall(autoCraftLoop)
if not ok then
    addLog(logs, "ERROR: Фатальная ошибка в autoCraftLoop: " .. tostring(err))
    draw()
    while true do os.sleep(1) end
end
