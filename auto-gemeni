local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode")
local term = require("term")
local computer = require("computer") -- Added for uptime
local g = component.gpu
local me = component.me_interface

-- Пути и библиотека
local DATA_FILE = "/home/BD.txt"
local LIB_PATH = "/lib/ultimateOC.lua"
local LIB_URL = "https://raw.githubusercontent.com/shify4713/lua/refs/heads/main/lib-gemeni"

-- Загрузка библиотеки ultimateOC
local uoc = {}
local ultimateOC_success, ultimateOC_err = pcall(function()
    uoc = dofile(LIB_PATH)
end)

if not ultimateOC_success then
    io.stderr:write("Ошибка при загрузке ultimateOC.lua: " .. tostring(ultimateOC_err) .. "\\n")
    os.exit(1)
end

-- Глобальные переменные
local logs = {}
local dataItems = {}
local selectedItem = nil
local WIDTH, HEIGHT
local currentPage = 1
local itemsPerPage = 5 -- Количество элементов на странице
local searchActive = false
local searchTerm = ""
local searchInputBuffer = ""
local lastSearchTerm = ""
local buttonHover = nil
local logOffset = 0 -- Смещение для прокрутки логов

-- Helper function to add logs
local function addLog(message, logType)
    logType = logType or "INFO"
    local timestamp = os.date("%H:%M:%S") -- Using os.date for a simple timestamp
    local formattedMessage = string.format("[%s][%s] %s", logType, timestamp, message)
    table.insert(logs, formattedMessage)
    term.write(formattedMessage .. "\n") -- Print to terminal
    -- Keep logs array from growing indefinitely
    if #logs > 50 then -- Example: keep last 50 log entries
        table.remove(logs, 1)
    end
end

-- Проверка доступности компонентов
local function checkComponents()
    if not component.isAvailable("gpu") then
        io.stderr:write("Ошибка: GPU недоступен\\n")
        os.exit(1)
    end
    if not component.isAvailable("screen") then
        io.stderr:write("Ошибка: Экран недоступен\\n")
        os.exit(1)
    end
    if not component.isAvailable("me_interface") then
        io.stderr:write("Ошибка: ME-интерфейс недоступен\\n")
        os.exit(1)
    end
    addLog("Все необходимые компоненты доступны", "INFO")
end

-- Привязка GPU к экрану
local function bindGpu()
    local screen = component.list("screen")()
    if not screen then
        io.stderr:write("Ошибка: Не найден экран для привязки GPU\\n")
        os.exit(1)
    end
    local success, err = pcall(g.bind, screen)
    if not success then
        io.stderr:write("Ошибка: Не удалось привязать GPU к экрану: " .. tostring(err) .. "\\n")
        os.exit(1)
    end
    addLog("GPU успешно привязан к экрану", "INFO")
end

-- Функция для получения информации о предмете из ME-интерфейса
local function getItemInfo(name)
    local items = me.getItemsInNetwork()
    for _, item in ipairs(items) do
        if item.name == name then
            return item
        end
    end
    return nil
end

-- Функция для получения рецептов для предмета
local function getRecipes(name)
    local item = getItemInfo(name)
    if item then
        local recipes = me.getRecipesFor(item)
        if recipes and #recipes > 0 then
            return recipes
        end
    end
    return nil
end

-- Функция для очистки экрана
local function clearScreen()
    g.setBackground(0x000000)
    g.fill(1, 1, WIDTH, HEIGHT, " ")
end

-- Функция для сохранения данных
local function savef()
    uoc.savef(DATA_FILE, dataItems)
    addLog("Данные сохранены", "INFO")
end

-- Функция для загрузки данных
local function loadf()
    local loadedData = uoc.loadf(DATA_FILE)
    if loadedData then
        dataItems = loadedData
        addLog("Данные загружены", "INFO")
    else
        dataItems = {}
        addLog("Файл данных не найден или пуст, созданы новые данные", "WARN")
    end
end

-- Функция для удаления элемента
local function deleteItem(index)
    if index and dataItems[index] then
        table.remove(dataItems, index)
        selectedItem = nil
        savef()
        addLog("Элемент удален: " .. (index or "N/A"), "INFO")
        -- Adjust currentPage if necessary
        local maxPages = math.max(1, math.ceil(#dataItems / itemsPerPage))
        if currentPage > maxPages then
            currentPage = maxPages
        end
    end
end

-- Функция для редактирования элемента
local function editItem(index, newName, newCount)
    if index and dataItems[index] then
        dataItems[index].name = newName
        dataItems[index].count = newCount
        savef()
        addLog("Элемент отредактирован: " .. newName .. ", " .. newCount, "INFO")
    end
end

-- Функция для добавления нового элемента
local function addItem(name, count)
    local item = { name = name, count = count }
    table.insert(dataItems, item)
    savef()
    addLog("Элемент добавлен: " .. name .. ", " .. count, "INFO")
end

-- Функция для проверки и автокрафта
local function autoCraft(itemToCraft)
    addLog("Начат автокрафт для: " .. itemToCraft.name .. " (x" .. itemToCraft.count .. ")", "INFO")
    local success, err = pcall(function()
        local itemInfo = getItemInfo(itemToCraft.name)
        if not itemInfo then
            addLog("Предмет " .. itemToCraft.name .. " не найден в ME-сети.", "ERROR")
            return
        end

        local currentCount = itemInfo.size or 0
        local neededCount = itemToCraft.count

        if currentCount < neededCount then
            local craftAmount = neededCount - currentCount
            addLog("Требуется скрафтить " .. craftAmount .. " " .. itemToCraft.name, "INFO")
            local result, reason = me.craft(itemInfo, craftAmount)
            if result then
                addLog("Успешно запущен крафт " .. craftAmount .. " " .. itemToCraft.name, "SUCCESS")
            else
                addLog("Не удалось запустить крафт " .. itemToCraft.name .. ": " .. tostring(reason), "ERROR")
            end
        else
            addLog(itemToCraft.name .. " (x" .. currentCount .. ") уже достаточно в системе.", "INFO")
        end
    end)
    if not success then
        addLog("Ошибка автокрафта для " .. itemToCraft.name .. ": " .. tostring(err), "ERROR")
    end
end

-- Функция для обновления данных об элементах (получения текущего количества)
local function updateItemCounts()
    addLog("Обновление количества предметов...", "INFO")
    for i, item in ipairs(dataItems) do
        local itemInfo = getItemInfo(item.name)
        if itemInfo then
            dataItems[i].currentCount = itemInfo.size
        else
            dataItems[i].currentCount = 0
        end
    end
    addLog("Количество предметов обновлено.", "INFO")
end

-- Перезагрузка данных (для кнопки "Перезагрузить данные")
local function reload()
    loadf()
    updateItemCounts()
    addLog("Данные перезагружены и обновлены.", "INFO")
end

-- Основной цикл автокрафта
local function autoCraftLoop()
    addLog("Запуск цикла автокрафта...", "INFO")
    while true do
        updateItemCounts()
        for _, item in ipairs(dataItems) do
            if item.currentCount < item.count then
                autoCraft(item)
                os.sleep(1) -- Небольшая пауза между крафтами
            end
        end
        draw() -- Обновить UI после цикла крафта
        os.sleep(60) -- Проверять каждые 60 секунд
    end
end


-- Функция для отрисовки интерфейса
local function draw()
    clearScreen()

    local btnColor = 0x6A0DAD -- Пурпурный
    local btnHoverColor = 0x9932CC -- Более светлый пурпурный
    local textColor = 0xFFFFFF -- Белый
    local inputBgColor = 0x333333 -- Темно-серый
    local inputBorderColor = 0xAAAAAA -- Светло-серый
    local selectedColor = 0x00BFFF -- Ярко-голубой
    local headerColor = 0x8BE9FD -- Светло-голубой
    local logColor = 0x8BE9FD

    -- Заголовок
    uoc.drawText(math.floor(WIDTH / 2 - unicode.len("Ultimate AE2 Auto-Crafter") / 2), 1, "Ultimate AE2 Auto-Crafter", headerColor, true)
    uoc.drawText(math.floor(WIDTH / 2 - unicode.len("by SHIFY") / 2), 2, "by SHIFY", headerColor)

    -- Область кнопок (справа)
    local buttonX = WIDTH - 20
    local buttonWidth = 18
    local buttonHeight = 3
    local startY = 4

    local buttons = {
        {text = "Добавить", func = function()
            addLog("Режим добавления элемента...", "INFO")
            local name = term.read("Имя предмета: ")
            local count = tonumber(term.read("Кол-во: "))
            if name and count then
                addItem(name, count)
                draw()
            else
                addLog("Отменено или неверный ввод.", "WARN")
            end
        end},
        {text = "Удалить", func = function()
            if selectedItem then
                deleteItem(selectedItem)
                draw()
            else
                addLog("Сначала выберите элемент для удаления.", "WARN")
            end
        end},
        {text = "Изменить", func = function()
            if selectedItem then
                addLog("Режим редактирования элемента: " .. dataItems[selectedItem].name, "INFO")
                local newName = term.read("Новое имя (" .. dataItems[selectedItem].name .. "): ")
                local newCount = tonumber(term.read("Новое кол-во (" .. dataItems[selectedItem].count .. "): "))
                editItem(selectedItem, newName ~= "" and newName or dataItems[selectedItem].name, newCount or dataItems[selectedItem].count)
                draw()
            else
                addLog("Сначала выберите элемент для редактирования.", "WARN")
            end
        end},
        {text = "Крафт", func = function()
            if selectedItem then
                autoCraft(dataItems[selectedItem])
                draw()
            else
                addLog("Сначала выберите элемент для крафта.", "WARN")
            end
        end},
        {text = "Перезагрузить данные", func = function()
            reload()
            draw()
        end},
        {text = "Выход", func = function()
            addLog("Завершение программы.", "INFO")
            clearScreen()
            os.exit()
        end}
    }

    local currentButtonY = startY
    for i, btn in ipairs(buttons) do
        local isHovered = buttonHover == i
        uoc.animatedButton(buttonX, currentButtonY, buttonWidth, buttonHeight, btn.text, isHovered, btnColor, btnHoverColor, textColor)
        currentButtonY = currentButtonY + buttonHeight + 1
    end

    -- Область поиска (слева, ниже заголовка)
    local searchX = 1
    local searchY = 4
    local searchWidth = WIDTH - buttonWidth - 2 -- Оставить место для кнопок и отступов
    local searchHeight = 3

    -- Поле поиска
    g.setForeground(inputBorderColor)
    g.setBackground(inputBgColor)
    g.fill(searchX, searchY, searchWidth, searchHeight, " ")
    uoc.drawText(searchX + 1, searchY + 1, "Поиск: " .. (searchActive and (searchInputBuffer .. "_") or searchTerm), textColor)

    -- Область списка элементов
    local listX = searchX
    local listY = searchY + searchHeight + 1
    local listWidth = searchWidth
    local listHeight = HEIGHT - listY - 6 -- Оставить место для пагинации и логов

    -- Заголовки таблицы
    local headerY = listY
    g.setBackground(0x000000)
    g.setForeground(headerColor)
    uoc.drawText(listX + 1, headerY, "Имя предмета", headerColor, true)
    uoc.drawText(listX + math.floor(listWidth * 0.5), headerY, "Требуется", headerColor, true)
    uoc.drawText(listX + math.floor(listWidth * 0.75), headerY, "В наличии", headerColor, true)

    local itemDisplayY = headerY + 1
    local filteredItems = {}
    if searchTerm ~= "" then
        for _, item in ipairs(dataItems) do
            if unicode.lower(item.name):find(unicode.lower(searchTerm)) then
                table.insert(filteredItems, item)
            end
        end
    else
        filteredItems = dataItems
    end

    local maxPages = math.max(1, math.ceil(#filteredItems / itemsPerPage))
    local startIndex = (currentPage - 1) * itemsPerPage + 1
    local endIndex = math.min(startIndex + itemsPerPage - 1, #filteredItems)
    local visibleItems = {}
    for i = startIndex, endIndex do
        table.insert(visibleItems, filteredItems[i])
    end

    for i, item in ipairs(visibleItems) do
        local displayY = itemDisplayY + i - 1
        local isSelected = false
        if selectedItem then
            -- Проверить, является ли текущий отображаемый элемент выбранным
            -- Это сложнее, так как selectedItem - это индекс в dataItems, а visibleItems - подмножество/фильтрованные
            -- Лучше искать по значению item.name
            local originalIndex = nil
            for k, v in ipairs(dataItems) do
                if v == item then
                    originalIndex = k
                    break
                end
            end
            if originalIndex == selectedItem then
                isSelected = true
            end
        end


        g.setBackground(isSelected and selectedColor or 0x000000)
        g.setForeground(textColor)
        g.fill(listX, displayY, listWidth, 1, " ") -- Очистить строку перед рисованием

        uoc.drawText(listX + 1, displayY, item.name, textColor)
        uoc.drawText(listX + math.floor(listWidth * 0.5), displayY, tostring(item.count), textColor)
        local currentCountText = tostring(item.currentCount or "N/A")
        if item.currentCount and item.currentCount < item.count then
            g.setForeground(0xFF0000) -- Красный, если количество недостаточно
        else
            g.setForeground(0x00FF00) -- Зеленый, если количество достаточно
        end
        uoc.drawText(listX + math.floor(listWidth * 0.75), displayY, currentCountText, g.foregroundColor()) -- Передаем текущий цвет
    end

    -- Пагинация
    local paginationY = listY + listHeight + 1
    local pageText = string.format("Страница %d/%d", currentPage, maxPages)
    uoc.drawText(math.floor(WIDTH / 2 - unicode.len(pageText) / 2), paginationY, pageText, textColor)

    -- Область логов (снизу)
    local logY = HEIGHT - 4
    local logHeight = 5
    g.setBackground(0x1A1A1A) -- Темно-серый фон для логов
    g.fill(1, logY, WIDTH, logHeight, " ")
    uoc.drawLogs(1, logY, logs, logHeight, logColor, logOffset) -- Используем uoc.drawLogs

    g.set(1, 1, "") -- Reset cursor position
end

-- Обработчик событий
event.listen("mouse_click", function(x, y, button)
    if button == 1 then -- Left click
        -- Check buttons
        local buttonX = WIDTH - 20
        local buttonWidth = 18
        local buttonHeight = 3
        local startY = 4

        local buttons = {
            {text = "Добавить"},
            {text = "Удалить"},
            {text = "Изменить"},
            {text = "Крафт"},
            {text = "Перезагрузить данные"},
            {text = "Выход"}
        }

        local currentButtonY = startY
        for i, btn in ipairs(buttons) do
            if x >= buttonX and x < buttonX + buttonWidth and
               y >= currentButtonY and y < currentButtonY + buttonHeight then
                -- Check which button was clicked and call its function
                local func = ({
                    [1] = function()
                        addLog("Режим добавления элемента...", "INFO")
                        searchActive = false
                        searchTerm = ""
                        searchInputBuffer = ""
                        draw()
                        local name = term.read("Имя предмета: ")
                        if name == "" then addLog("Имя не может быть пустым. Отменено.", "WARN"); draw(); return end
                        local count_str = term.read("Кол-во: ")
                        local count = tonumber(count_str)
                        if not count or count <= 0 then addLog("Неверное количество. Отменено.", "WARN"); draw(); return end
                        addItem(name, count)
                        draw()
                    end,
                    [2] = function()
                        if selectedItem then
                            deleteItem(selectedItem)
                            draw()
                        else
                            addLog("Сначала выберите элемент для удаления.", "WARN")
                        end
                    end,
                    [3] = function()
                        if selectedItem then
                            addLog("Режим редактирования элемента: " .. dataItems[selectedItem].name, "INFO")
                            searchActive = false
                            searchTerm = ""
                            searchInputBuffer = ""
                            draw()
                            local currentName = dataItems[selectedItem].name
                            local currentCount = dataItems[selectedItem].count

                            local newName = term.read("Новое имя (" .. currentName .. ", Enter для пропуска): ")
                            newName = (newName == "" or newName == nil) and currentName or newName

                            local newCount_str = term.read("Новое кол-во (" .. currentCount .. ", Enter для пропуска): ")
                            local newCount = tonumber(newCount_str)
                            newCount = (newCount_str == "" or newCount_str == nil) and currentCount or newCount

                            if newName ~= currentName or newCount ~= currentCount then
                                editItem(selectedItem, newName, newCount)
                            else
                                addLog("Изменений нет. Отменено.", "INFO")
                            end
                            draw()
                        else
                            addLog("Сначала выберите элемент для редактирования.", "WARN")
                        end
                    end,
                    [4] = function()
                        if selectedItem then
                            autoCraft(dataItems[selectedItem])
                            draw()
                        else
                            addLog("Сначала выберите элемент для крафта.", "WARN")
                        end
                    end,
                    [5] = function()
                        reload()
                        draw()
                    end,
                    [6] = function()
                        addLog("Завершение программы.", "INFO")
                        clearScreen()
                        os.exit()
                    end,
                })[i]
                if func then func() end
                return
            end
            currentButtonY = currentButtonY + buttonHeight + 1
        end

        -- Check search area
        local searchX = 1
        local searchY = 4
        local searchWidth = WIDTH - buttonWidth - 2
        local searchHeight = 3
        if x >= searchX and x < searchX + searchWidth and
           y >= searchY and y < searchY + searchHeight then
            searchActive = true
            searchInputBuffer = searchTerm -- Start buffering from current search term
            addLog("Поле поиска активировано. Введите текст...", "INFO")
        else
            if searchActive then -- Deactivate search only if it was active and clicked outside
                searchActive = false
                searchTerm = searchInputBuffer
                addLog("Поиск: '" .. searchTerm .. "'", "INFO")
                currentPage = 1 -- Reset page on search
                selectedItem = nil -- Deselect item on search
            end
        end

        -- Check list area for item selection
        local listX = searchX
        local listY = searchY + searchHeight + 1
        local listWidth = searchWidth
        local itemDisplayY = listY + 1 -- Adjust for header
        local actualListHeight = HEIGHT - listY - 6 -- Total space for items

        if x >= listX and x < listX + listWidth and
           y >= itemDisplayY and y < itemDisplayY + itemsPerPage then
            local clickedRelativeY = y - itemDisplayY
            local clickedVisibleIndex = clickedRelativeY + 1
            if clickedVisibleIndex >= 1 and clickedVisibleIndex <= #visibleItems then
                local clickedItem = visibleItems[clickedVisibleIndex]
                -- Find the original index of the clicked item in dataItems
                for k, v in ipairs(dataItems) do
                    if v == clickedItem then
                        selectedItem = k
                        addLog("Выбран элемент: " .. v.name, "INFO")
                        break
                    end
                end
            end
        end

        draw() -- Redraw after click
    end
end)

event.listen("mouse_drag", function(x, y, button, dragX, dragY)
    -- Same hover logic as mouse_move, maybe unnecessary but good for consistency
    local buttonX = WIDTH - 20
    local buttonWidth = 18
    local buttonHeight = 3
    local startY = 4
    local currentButtonY = startY
    buttonHover = nil
    for i = 1, #buttons do -- buttons table from global scope or re-defined
        if x >= buttonX and x < buttonX + buttonWidth and
           y >= currentButtonY and y < currentButtonY + buttonHeight then
            buttonHover = i
            break
        end
        currentButtonY = currentButtonY + buttonHeight + 1
    end
    draw()
end)


event.listen("mouse_move", function(x, y)
    local buttonX = WIDTH - 20
    local buttonWidth = 18
    local buttonHeight = 3
    local startY = 4
    local currentButtonY = startY
    local newButtonHover = nil
    local buttons_def = { -- Re-define buttons for hover check to avoid scope issues
        {text = "Добавить"},
        {text = "Удалить"},
        {text = "Изменить"},
        {text = "Крафт"},
        {text = "Перезагрузить данные"},
        {text = "Выход"}
    }
    for i, btn in ipairs(buttons_def) do
        if x >= buttonX and x < buttonX + buttonWidth and
           y >= currentButtonY and y < currentButtonY + buttonHeight then
            newButtonHover = i
            break
        end
        currentButtonY = currentButtonY + buttonHeight + 1
    end
    if newButtonHover ~= buttonHover then
        buttonHover = newButtonHover
        draw() -- Only redraw if hover state changed
    end
end)

event.listen("key_down", function(_, _, key, char)
    if searchActive then
        if key == 28 then -- Enter
            searchActive = false
            searchTerm = searchInputBuffer
            addLog("Поиск: '" .. searchTerm .. "'", "INFO")
            currentPage = 1 -- Reset page on search
            selectedItem = nil -- Deselect item on search
        elseif key == 14 then -- Backspace
            searchInputBuffer = unicode.sub(searchInputBuffer, 1, unicode.len(searchInputBuffer) - 1)
        elseif char and unicode.len(char) == 1 then -- Any single character
            searchInputBuffer = searchInputBuffer .. char
        end
        draw()
    else
        if key == 200 then -- Up arrow
            if selectedItem then
                selectedItem = math.max(1, selectedItem - 1)
                -- Adjust page if necessary
                local itemPage = math.ceil(selectedItem / itemsPerPage)
                if itemPage < currentPage then
                    currentPage = itemPage
                end
            else -- If no item is selected, select the last item on the current page
                local maxItemsOnPage = math.min(itemsPerPage, #dataItems - (currentPage - 1) * itemsPerPage)
                if maxItemsOnPage > 0 then
                    selectedItem = (currentPage - 1) * itemsPerPage + maxItemsOnPage
                end
            end
        elseif key == 208 then -- Down arrow
            if selectedItem then
                selectedItem = math.min(#dataItems, selectedItem + 1)
                -- Adjust page if necessary
                local itemPage = math.ceil(selectedItem / itemsPerPage)
                if itemPage > currentPage then
                    currentPage = itemPage
                end
            else -- If no item is selected, select the first item on the current page
                if #dataItems > 0 then
                    selectedItem = (currentPage - 1) * itemsPerPage + 1
                end
            end
        elseif key == 203 then -- Left arrow
            if currentPage > 1 then
                currentPage = currentPage - 1
                selectedItem = nil
            end
        elseif key == 205 then -- Right arrow
            local maxPages = math.max(1, math.ceil(#dataItems / itemsPerPage))
            if currentPage < maxPages then
                currentPage = currentPage + 1
                selectedItem = nil
            end
        elseif key == 200 and not searchActive then -- Up arrow for logs (this seems duplicated, check logic)
            logOffset = math.min(logOffset + 1, math.max(0, #logs - 5))
        elseif key == 208 and not searchActive then -- Down arrow for logs (this seems duplicated, check logic)
            logOffset = math.max(logOffset - 1, 0)
        end
    end
    buttonHover = nil
    draw()
end)

-------------------- Старт --------------------
checkComponents()
bindGpu()
WIDTH, HEIGHT = g.maxResolution()
g.setResolution(WIDTH, HEIGHT)
addLog("Программа запущена", "INFO") -- Corrected call
local ok, err = pcall(reload)
if not ok then
    addLog("Ошибка при начальной загрузке: " .. tostring(err), "ERROR") -- Corrected call
    draw()
    while true do os.sleep(1) end
end
draw()
local ok, err = pcall(autoCraftLoop)
if not ok then
    addLog("Фатальная ошибка в autoCraftLoop: " .. tostring(err), "ERROR") -- Corrected call
    draw()
    while true do os.sleep(1) end
end
