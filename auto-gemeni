local component = require("component")
local fs = require("filesystem")
local shell = require("shell")
local event = require("event")
local unicode = require("unicode")
local term = require("term")
local computer = require("computer")
local g = component.gpu
local me = component.me_interface

-- Пути и библиотека
local DATA_FILE = "/home/BD.txt"
local LIB_PATH = "/lib/ultimateOC.lua"
local LIB_URL = "https://raw.githubusercontent.com/shify4713/lua/refs/heads/main/lib-gemeni"

-- Глобальные переменные
local M -- Таблица для функций из ultimateOC.lua (будет инициализирована позже)
local WIDTH, HEIGHT
local dataItems = {} -- массив для хранения данных о предметах
local logs = {} -- массив для логов
local selectedItem = nil -- индекс выбранного элемента в dataItems (индекс в dataItems, не в filteredItems)
local currentPage = 1
local itemsPerPage = 10
local maxPages = 1
local logOffset = 0 -- Смещение для прокрутки логов
local filterText = ""
local searchActive = false
local buttonHover = nil -- Переменная для отслеживания наведения курсора на кнопку
local sortOrder = "asc" -- "asc" или "desc"
local sortColumn = "name" -- "name", "available", "craft"

local editMode = false
local currentEditField = nil -- 'name', 'editItemQuantity', 'editCraftQuantity'
local editItemName = ""
local editItemQuantity = "0" -- Будет обновляться из ME
local editCraftQuantity = "0"

-- **Оригинальная концепция addLog:** Принимает 'logs' как первый аргумент.
local function addLog(logTable, text, lvl)
    lvl = lvl or "INFO"
    local now = os.date("!*t", os.time()+3*3600) -- МСК (для единообразия)
    local t = string.format("[%02d:%02d:%02d][%s] %s", now.hour, now.min, now.sec, lvl, text)
    table.insert(logTable, t)
    while #logTable > 50 do table.remove(logTable, 1) end
    -- Обновляем logOffset, чтобы избежать выхода за пределы массива, когда логи удаляются
    logOffset = math.min(logOffset, math.max(0, #logs - 3)) -- 3 - количество видимых логов
end

-- Проверка доступности компонентов
local function checkComponents()
    if not component.isAvailable("gpu") then
        io.stderr:write("Ошибка: GPU недоступен\n")
        os.exit(1)
    end
    if not component.isAvailable("screen") then
        io.stderr:write("Ошибка: Экран недоступен\n")
        os.exit(1)
    end
    if not component.isAvailable("me_interface") then
        io.stderr:write("Ошибка: ME-интерфейс недоступен\n")
        os.exit(1)
    end
end

-- Привязка GPU к экрану
local function bindGpu()
    local screen = component.list("screen")()
    if not screen then
        io.stderr:write("Ошибка: Не найден экран для привязки GPU\n")
        os.exit(1)
    end
    -- Убедимся, что 'g' не nil перед попыткой привязки
    if not g then
        io.stderr:write("Ошибка: GPU компонент не инициализирован перед привязкой. Проверьте установку GPU.\n")
        os.exit(1)
    end
    local success, err = pcall(g.bind, screen)
    if not success then
        io.stderr:write("Ошибка: Не удалось привязать GPU к экрану: " .. tostring(err) .. "\n")
        os.exit(1)
    end
end

-- Загрузка или скачивание ultimateOC.lua
local function loadLibrary()
    if not fs.exists(LIB_PATH) then
        addLog(logs, "Библиотека ultimateOC.lua не найдена. Скачивание...", "INFO")
        local ok, err = shell.execute("wget -f " .. LIB_URL .. " " .. LIB_PATH)
        if not ok then
            addLog(logs, "Не удалось скачать библиотеку ultimateOC.lua: " .. tostring(err), "ERROR")
            os.exit(1)
        end
        addLog(logs, "Библиотека ultimateOC.lua успешно скачана.", "INFO")
    end
    package.loaded.ultimateOC = nil -- Очищаем кэш, если библиотека была загружена ранее
    M = require("ultimateOC") -- Инициализируем M
    if not M then
        addLog(logs, "Не удалось загрузить библиотеку ultimateOC.lua. Проверьте файл.", "ERROR")
        os.exit(1)
    end
    addLog(logs, "Библиотека ultimateOC.lua успешно загружена.", "INFO")
    
    -- В этой концепции мы не переопределяем addLog, а просто используем M.addLog напрямую
    -- в тех местах, где это необходимо.
    -- Это потому, что M.addLog теперь соответствует сигнатуре локальной addLog.
end

-- Функция сохранения данных
local function saveData()
    local ok, err = pcall(M.savef, DATA_FILE, dataItems)
    if not ok then
        addLog(logs, "Ошибка при сохранении данных: " .. tostring(err), "ERROR")
    else
        addLog(logs, "Данные успешно сохранены.", "INFO")
    end
end

-- Функция загрузки данных
local function loadData()
    local ok, tbl = pcall(M.loadf, DATA_FILE)
    if ok then
        dataItems = tbl or {}
        addLog(logs, "Данные успешно загружены.", "INFO")
    else
        addLog(logs, "Ошибка при загрузке данных: " .. tostring(tbl) .. ". Инициализация пустых данных.", "ERROR")
        dataItems = {}
    end
end

-- Обновление данных о наличии предметов
local function updateItemCounts()
    addLog(logs, "Обновление количества предметов...", "INFO")
    local items = me.getItemsInME()
    for _, itemData in ipairs(dataItems) do
        local found = false
        for _, meItem in ipairs(items) do
            if meItem.name == itemData.name then
                itemData.available = meItem.size
                found = true
                break
            end
        end
        if not found then
            itemData.available = 0
        end
    end
    addLog(logs, "Количество предметов обновлено.", "INFO")
end

-- Сортировка предметов
local function sortItems()
    table.sort(dataItems, function(a, b)
        local valA, valB
        if sortColumn == "name" then
            valA = unicode.lower(a.name)
            valB = unicode.lower(b.name)
        elseif sortColumn == "available" then
            valA = a.available
            valB = b.available
        elseif sortColumn == "craft" then
            valA = a.craft
            valB = b.craft
        end

        if sortOrder == "asc" then
            return valA < valB
        else
            return valA > valB
        end
    end)
end

-- Перезагрузка данных и интерфейса
local function reload()
    loadData()
    updateItemCounts()
    sortItems()
    local filtered = M.filterItems(dataItems, filterText)
    maxPages = math.max(1, math.ceil(#filtered / itemsPerPage))
    currentPage = math.min(currentPage, maxPages) -- Убедиться, что текущая страница в пределах нового диапазона
    selectedItem = nil -- Сброс выбранного элемента при перезагрузке
    addLog(logs, "Данные перезагружены и обновлены.", "INFO")
end

-- Главная функция отрисовки
local function draw()
    -- **ВАЖНОЕ ИЗМЕНЕНИЕ:** Проверка g на nil в начале функции отрисовки
    if not g then
        io.stderr:write("Ошибка отрисовки: GPU компонент недоступен (g is nil). Проверьте установку GPU.\n")
        -- В данном случае, просто выходим из функции, чтобы избежать ошибки.
        -- Программа не будет крашиться, но и отрисовки не будет.
        return
    end

    g.setBackground(0x282A36)
    g.setForeground(0xF8F8F2)
    g.clear() -- Очищаем весь экран

    local startX = 1
    local startY = 1

    -- Заголовок
    M.drawText(startX, startY, "ME-Интерфейс Мониторинг и Автокрафт", 0x50FA7B)
    startY = startY + 2

    -- Поле поиска
    M.drawText(startX, startY, "Поиск: ", 0xBD93F9)
    M.drawField(startX + unicode.len("Поиск: "), startY, WIDTH - (startX + unicode.len("Поиск: ")), filterText, searchActive, 0x44475A, 0xF8F8F2)
    startY = startY + 2

    -- Заголовки таблицы
    local col1Width = math.floor(WIDTH * 0.4)
    local col2Width = math.floor(WIDTH * 0.3)
    local col3Width = WIDTH - col1Width - col2Width - 2 -- 2 для рамок (1 для первой колонки, 1 для второй)

    M.drawText(startX, startY, "Название", 0xFFB86C)
    -- Используем правильное Y для кнопок сортировки (на 1 меньше чем текст "Название", чтобы кнопка была по центру)
    local sortButtonsY = startY - 1
    M.drawButton(startX + col1Width + 1, sortButtonsY, col2Width, 2, "В наличии " .. (sortColumn == "available" and (sortOrder == "asc" and "▲" or "▼") or ""), 0x6272A4, 0xF8F8F2, buttonHover == "sortAvailable")
    M.drawButton(startX + col1Width + col2Width + 2, sortButtonsY, col3Width, 2, "Крафт " .. (sortColumn == "craft" and (sortOrder == "asc" and "▲" or "▼") or ""), 0x6272A4, 0xF8F8F2, buttonHover == "sortCraft")
    startY = startY + 1

    -- Разделитель
    g.set(startX, startY, string.rep("-", WIDTH), 0x6272A4)
    startY = startY + 1

    -- Список предметов
    local filteredItems = M.filterItems(dataItems, filterText)

    -- Обновляем maxPages после фильтрации
    maxPages = math.max(1, math.ceil(#filteredItems / itemsPerPage))
    currentPage = math.min(currentPage, maxPages) -- Убедиться, что текущая страница в пределах нового диапазона

    local visibleItems = M.scrollArray(filteredItems, currentPage, itemsPerPage)
    local itemY = startY
    for i, item in ipairs(visibleItems) do
        local bgColor = 0x282A36
        -- Проверяем, является ли текущий item выбранным
        local isSelected = false
        if selectedItem and dataItems[selectedItem] == item then
            isSelected = true
        end
        if isSelected then
            bgColor = 0x44475A -- Цвет для выбранного элемента
        end
        g.setBackground(bgColor)
        M.drawText(startX, itemY, M.truncateText(item.name, col1Width - 1), 0xF8F8F2)
        M.drawText(startX + col1Width + 1, itemY, tostring(item.available), 0xFF79C6)
        M.drawText(startX + col1Width + col2Width + 2, itemY, tostring(item.craft), 0x50FA7B)
        itemY = itemY + 1
    end
    g.setBackground(0x282A36) -- Сброс фона после отрисовки списка

    -- Пагинация
    startY = HEIGHT - 9 -- Отступ снизу для пагинации и кнопок
    M.drawButton(startX, startY, 8, 2, "<", 0xBD93F9, 0xF8F8F2, buttonHover == "prevPage")
    M.drawText(startX + 10, startY + 1, string.format("Страница %d/%d", currentPage, maxPages), 0xF8F8F2)
    M.drawButton(startX + 10 + unicode.len(string.format("Страница %d/%d", currentPage, maxPages)) + 2, startY, 8, 2, ">", 0xBD93F9, 0xF8F8F2, buttonHover == "nextPage")

    -- Кнопки действий
    local buttonY = HEIGHT - 6
    M.drawButton(startX, buttonY, 15, 2, "Добавить", 0x6272A4, 0xF8F8F2, buttonHover == "add")
    M.drawButton(startX + 16, buttonY, 15, 2, "Изменить", 0x6272A4, 0xF8F8F2, buttonHover == "edit")
    M.drawButton(startX + 32, buttonY, 15, 2, "Удалить", 0x6272A4, 0xF8F8F2, buttonHover == "delete")
    M.drawButton(startX + 48, buttonY, 15, 2, "Обновить", 0x6272A4, 0xF8F8F2, buttonHover == "refresh")
    M.drawButton(startX + 64, buttonY, 15, 2, "Сохранить", 0x6272A4, 0xF8F8F2, buttonHover == "save")

    -- Логи
    -- drawLogs теперь принимает offset
    M.drawLogs(startX, HEIGHT - 3, logs, 3, 0x8BE9FD, logOffset)

    -- Режим редактирования/добавления
    if editMode then
        g.setBackground(0x282A36)
        g.setForeground(0xF8F8F2)
        g.clear(1, 1, WIDTH, HEIGHT) -- Очищаем весь экран

        M.drawText(math.floor(WIDTH / 2 - unicode.len("Редактирование предмета") / 2), 2, "Редактирование предмета", 0xFF79C6)

        local fieldX = 5
        local fieldY = 5
        local fieldWidth = WIDTH - 10

        M.drawText(fieldX, fieldY, "Название предмета:", 0xF8F8F2)
        -- Передача currentEditField == 'name' для активации поля
        M.drawField(fieldX, fieldY + 1, fieldWidth, editItemName, currentEditField == 'name', 0x44475A, 0xF8F8F2)
        fieldY = fieldY + 3

        M.drawText(fieldX, fieldY, "Количество в наличии (будет обновлено):", 0xF8F8F2)
        -- Поле editItemQuantity неактивно для прямого ввода, но показывается
        M.drawField(fieldX, fieldY + 1, fieldWidth, editItemQuantity, false, 0x44475A, 0xF8F8F2) -- false для неактивного ввода
        fieldY = fieldY + 3

        M.drawText(fieldX, fieldY, "Количество для крафта:", 0xF8F8F2)
        -- Передача currentEditField == 'editCraftQuantity' для активации поля
        M.drawField(fieldX, fieldY + 1, fieldWidth, editCraftQuantity, currentEditField == 'editCraftQuantity', 0x44475A, 0xF8F8F2)
        fieldY = fieldY + 3

        M.drawButton(math.floor(WIDTH / 2 - 10), fieldY + 2, 10, 2, "Принять", 0x50FA7B, 0xF8F8F2, buttonHover == "acceptEdit")
        M.drawButton(math.floor(WIDTH / 2 + 1), fieldY + 2, 10, 2, "Отмена", 0xFF5555, 0xF8F8F2, buttonHover == "cancelEdit")
    end

    g.set(1, 1, "") -- Обновляем экран
end

-- Автокрафт луп
local function autoCraftLoop()
    while true do
        updateItemCounts() -- Обновляем наличие в начале цикла
        for _, itemData in ipairs(dataItems) do
            if itemData.available < itemData.craft then
                local needed = itemData.craft - itemData.available
                addLog(logs, "Требуется крафт " .. tostring(needed) .. " " .. itemData.name, "INFO")
                local ok, err = pcall(me.craftItem, itemData.name, needed)
                if not ok then
                    addLog(logs, "Ошибка при крафте " .. itemData.name .. ": " .. tostring(err), "ERROR")
                else
                    addLog(logs, "Заказано " .. tostring(needed) .. " " .. itemData.name .. " для крафта.", "INFO")
                end
            end
        end
        draw() -- Отрисовка после каждого цикла автокрафта
        os.sleep(10) -- Проверка каждые 10 секунд
    end
end

-- Обработчики событий
local function on_mouse_click(x, y, button, isTouch)
    if editMode then
        local fieldX = 5
        local fieldY = 5
        local fieldWidth = WIDTH - 10

        -- Клик по полю "Название предмета"
        if M.isInside(x, y, fieldX, fieldY + 1, fieldWidth, 1) then
            currentEditField = 'name'
        -- Клик по полю "Количество в наличии" (не редактируется пользователем напрямую)
        elseif M.isInside(x, y, fieldX, fieldY + 4, fieldWidth, 1) then
            currentEditField = nil -- Не активируем, просто для отслеживания
        -- Клик по полю "Количество для крафта"
        elseif M.isInside(x, y, fieldX, fieldY + 7, fieldWidth, 1) then
            currentEditField = 'editCraftQuantity'
        else -- Клик вне полей ввода
            currentEditField = nil
        end

        -- Кнопка "Принять"
        if M.isInside(x, y, math.floor(WIDTH / 2 - 10), fieldY + 7 + 2, 10, 2) then
            local parsedCraftQuantity = tonumber(editCraftQuantity)

            if not editItemName or unicode.len(editItemName) == 0 then
                addLog(logs, "Название предмета не может быть пустым.", "ERROR")
                currentEditField = 'name'
                draw()
                return
            end
            if not parsedCraftQuantity or parsedCraftQuantity < 0 then
                addLog(logs, "Количество для крафта должно быть числом >= 0.", "ERROR")
                currentEditField = 'editCraftQuantity'
                draw()
                return
            end

            if selectedItem then -- Режим редактирования
                dataItems[selectedItem].name = editItemName
                dataItems[selectedItem].craft = parsedCraftQuantity
                addLog(logs, "Предмет '" .. editItemName .. "' изменен.", "INFO")
            else -- Режим добавления
                table.insert(dataItems, {name = editItemName, available = 0, craft = parsedCraftQuantity})
                addLog(logs, "Предмет '" .. editItemName .. "' добавлен.", "INFO")
            end
            saveData()
            reload()
            editMode = false
            currentEditField = nil
        end
        -- Кнопка "Отмена"
        if M.isInside(x, y, math.floor(WIDTH / 2 + 1), fieldY + 7 + 2, 10, 2) then
            editMode = false
            currentEditField = nil
            addLog(logs, "Отмена редактирования/добавления.", "INFO")
        end
    else -- Главный экран
        -- Кнопки сортировки (используем sortButtonsY из draw функции)
        local col1Width = math.floor(WIDTH * 0.4)
        local col2Width = math.floor(WIDTH * 0.3)
        local sortButtonsY = 5 -- Y-координата заголовков таблицы (см. draw)

        -- Сортировка по "В наличии"
        if M.isInside(x, y, startX + col1Width + 1, sortButtonsY, col2Width, 2) then
            if sortColumn == "available" then
                sortOrder = (sortOrder == "asc" and "desc" or "asc")
            else
                sortColumn = "available"
                sortOrder = "asc"
            end
            sortItems()
            draw()
            return
        end
        -- Сортировка по "Крафт"
        if M.isInside(x, y, startX + col1Width + col2Width + 2, sortButtonsY, WIDTH - col1Width - col2Width - 2, 2) then
            if sortColumn == "craft" then
                sortOrder = (sortOrder == "asc" and "desc" or "asc")
            else
                sortColumn = "craft"
                sortOrder = "asc"
            end
            sortItems()
            draw()
            return
        end

        -- Кнопки пагинации
        local pagY = HEIGHT - 9
        if M.isInside(x, y, startX, pagY, 8, 2) then -- Кнопка "<"
            if currentPage > 1 then
                currentPage = currentPage - 1
                selectedItem = nil
                draw()
            end
        elseif M.isInside(x, y, startX + 10 + unicode.len(string.format("Страница %d/%d", currentPage, maxPages)) + 2, pagY, 8, 2) then -- Кнопка ">"
            if currentPage < maxPages then
                currentPage = currentPage + 1
                selectedItem = nil
                draw()
            end
        end

        -- Кнопки действий
        local buttonY = HEIGHT - 6
        if M.isInside(x, y, startX, buttonY, 15, 2) then -- Добавить
            editMode = true
            selectedItem = nil -- Режим добавления
            editItemName = ""
            editItemQuantity = "0" -- Добавляемый предмет пока не в ME
            editCraftQuantity = "0"
            currentEditField = 'name'
            addLog(logs, "Режим добавления предмета.", "INFO")
        elseif M.isInside(x, y, startX + 16, buttonY, 15, 2) then -- Изменить
            if selectedItem then
                editMode = true
                editItemName = dataItems[selectedItem].name
                editItemQuantity = tostring(dataItems[selectedItem].available)
                editCraftQuantity = tostring(dataItems[selectedItem].craft)
                currentEditField = 'name'
                addLog(logs, "Режим редактирования предмета '" .. editItemName .. "'.", "INFO")
            else
                addLog(logs, "Выберите предмет для изменения.", "WARN")
            end
        elseif M.isInside(x, y, startX + 32, buttonY, 15, 2) then -- Удалить
            if selectedItem then
                addLog(logs, "Удален предмет '" .. dataItems[selectedItem].name .. "'.", "INFO")
                table.remove(dataItems, selectedItem)
                selectedItem = nil
                saveData()
                reload()
            else
                addLog(logs, "Выберите предмет для удаления.", "WARN")
            end
        elseif M.isInside(x, y, startX + 48, buttonY, 15, 2) then -- Обновить
            reload()
        elseif M.isInside(x, y, startX + 64, buttonY, 15, 2) then -- Сохранить
            saveData()
        end

        -- Выбор элемента в списке
        local startListY = 7 -- Начальная Y-координата списка
        local filteredItems = M.filterItems(dataItems, filterText)
        local visibleItems = M.scrollArray(filteredItems, currentPage, itemsPerPage)
        for i, item in ipairs(visibleItems) do
            if M.isInside(x, y, 1, startListY + i - 1, WIDTH, 1) then
                -- Находим глобальный индекс выбранного элемента
                selectedItem = nil
                for k, v in ipairs(dataItems) do
                    if v == item then
                        selectedItem = k
                        break
                    end
                end
                draw()
                return
            end
        end
    end
    buttonHover = nil -- Сброс наведения после клика
    draw()
end

local function on_mouse_drag(x, y, button, isTouch)
    -- Не используется в данном интерфейсе
end

local function on_mouse_scroll(x, y, scroll)
    if not searchActive and not editMode then
        -- Скролл логов
        local maxLogOffset = math.max(0, #logs - 3) -- 3 видимые строки логов
        if scroll > 0 then -- scroll up (по экрану) -> logs вниз (уменьшаем offset)
            logOffset = math.max(logOffset - 1, 0)
        else -- scroll down (по экрану) -> logs вверх (увеличиваем offset)
            logOffset = math.min(logOffset + 1, maxLogOffset)
        end
    end
    draw()
end

local function on_key(key, is_pressed)
    if not is_pressed then return end

    if editMode then
        -- В режиме редактирования
        if key == 28 then -- ENTER
            if currentEditField == 'name' then
                currentEditField = 'editCraftQuantity' -- Переход к полю для крафта
            elseif currentEditField == 'editCraftQuantity' then
                -- Попытка сохранения, как при нажатии кнопки "Принять"
                local parsedCraftQuantity = tonumber(editCraftQuantity)

                if not editItemName or unicode.len(editItemName) == 0 then
                    addLog(logs, "Название предмета не может быть пустым.", "ERROR")
                    currentEditField = 'name'
                    draw()
                    return
                end
                if not parsedCraftQuantity or parsedCraftQuantity < 0 then
                    addLog(logs, "Количество для крафта должно быть числом >= 0.", "ERROR")
                    currentEditField = 'editCraftQuantity'
                    draw()
                    return
                end

                if selectedItem then
                    dataItems[selectedItem].name = editItemName
                    dataItems[selectedItem].craft = parsedCraftQuantity
                    addLog(logs, "Предмет '" .. editItemName .. "' изменен.", "INFO")
                else
                    table.insert(dataItems, {name = editItemName, available = 0, craft = parsedCraftQuantity})
                    addLog(logs, "Предмет '" .. editItemName .. "' добавлен.", "INFO")
                end
                saveData()
                reload()
                editMode = false
                currentEditField = nil
            end
        elseif key == 206 then -- BACKSPACE
            if currentEditField == 'name' then
                editItemName = unicode.sub(editItemName, 1, unicode.len(editItemName) - 1)
            elseif currentEditField == 'editCraftQuantity' then
                editCraftQuantity = unicode.sub(editCraftQuantity, 1, unicode.len(editCraftQuantity) - 1)
            end
        elseif key == 1 then -- ESC
            editMode = false
            currentEditField = nil
            addLog(logs, "Отмена редактирования/добавления.", "INFO")
        else
            local char = term.keyboardGetCharacter(key)
            if char and unicode.len(char) > 0 then
                if currentEditField == 'name' then
                    editItemName = editItemName .. char
                elseif currentEditField == 'editCraftQuantity' then
                    if char:match("%d") then -- Только цифры
                        editCraftQuantity = editCraftQuantity .. char
                    end
                end
            end
        end
    else -- Основной режим (не редактирование)
        -- Поле поиска
        if key == 28 then -- ENTER
            searchActive = not searchActive
            if not searchActive then
                reload() -- Перезагрузка после завершения поиска
            end
        elseif key == 206 then -- BACKSPACE
            if searchActive then
                filterText = unicode.sub(filterText, 1, unicode.len(filterText) - 1)
            end
        elseif key == 1 then -- ESC
            if searchActive then
                searchActive = false
                filterText = ""
                reload()
            else
                computer.shutdown()
            end
        elseif searchActive then -- Если поле поиска активно, вводим символы
            local char = term.keyboardGetCharacter(key)
            if char and unicode.len(char) > 0 then
                filterText = filterText .. char
            end
        -- Навигация по списку предметов (если поиск неактивен)
        elseif not searchActive then
            local filteredItems = M.filterItems(dataItems, filterText)
            local visibleItems = M.scrollArray(filteredItems, currentPage, itemsPerPage)

            if key == 200 then -- Up arrow
                if selectedItem then
                    local currentIdxInFiltered = nil
                    for i, v in ipairs(filteredItems) do
                        if v == dataItems[selectedItem] then
                            currentIdxInFiltered = i
                            break
                        end
                    end

                    if currentIdxInFiltered then
                        if currentIdxInFiltered > 1 then
                            selectedItem = nil
                            for k, v in ipairs(dataItems) do
                                if v == filteredItems[currentIdxInFiltered - 1] then
                                    selectedItem = k
                                    break
                                end
                            end
                            -- Проверяем, нужна ли прокрутка страницы
                            local newPage = math.ceil((currentIdxInFiltered -1) / itemsPerPage) -- скорректировано для 0-го индекса
                            if newPage == 0 then newPage = 1 end -- страница не может быть 0
                            if newPage ~= currentPage then
                                currentPage = newPage
                            end
                        end
                    end
                else -- Если ничего не выбрано, выбираем последний на текущей странице или на предыдущей
                    if #visibleItems > 0 then
                        selectedItem = nil
                        for k, v in ipairs(dataItems) do
                            if v == visibleItems[#visibleItems] then
                                selectedItem = k
                                break
                            end
                        end
                    elseif currentPage > 1 then
                        currentPage = currentPage - 1
                        -- Перезагружаем visibleItems для новой страницы
                        visibleItems = M.scrollArray(M.filterItems(dataItems, filterText), currentPage, itemsPerPage)
                        if #visibleItems > 0 then
                            selectedItem = nil
                            for k, v in ipairs(dataItems) do
                                if v == visibleItems[#visibleItems] then
                                    selectedItem = k
                                    break
                                end
                            end
                        end
                    end
                end
            elseif key == 208 then -- Down arrow
                if selectedItem then
                    local currentIdxInFiltered = nil
                    for i, v in ipairs(filteredItems) do
                        if v == dataItems[selectedItem] then
                            currentIdxInFiltered = i
                            break
                        end
                    end

                    if currentIdxInFiltered then
                        if currentIdxInFiltered < #filteredItems then
                            selectedItem = nil
                            for k, v in ipairs(dataItems) do
                                if v == filteredItems[currentIdxInFiltered + 1] then
                                    selectedItem = k
                                    break
                                end
                            end
                            -- Проверяем, нужна ли прокрутка страницы
                            local newPage = math.ceil((currentIdxInFiltered + 1) / itemsPerPage)
                            if newPage ~= currentPage then
                                currentPage = newPage
                            end
                        end
                    end
                else -- Если ничего не выбрано, выбираем первый на текущей странице или на следующей
                    if #visibleItems > 0 then
                        selectedItem = nil
                        for k, v in ipairs(dataItems) do
                            if v == visibleItems[1] then
                                selectedItem = k
                                break
                            end
                        end
                    elseif currentPage < maxPages then
                        currentPage = currentPage + 1
                        -- Перезагружаем visibleItems для новой страницы
                        visibleItems = M.scrollArray(M.filterItems(dataItems, filterText), currentPage, itemsPerPage)
                        if #visibleItems > 0 then
                            selectedItem = nil
                            for k, v in ipairs(dataItems) do
                                if v == visibleItems[1] then
                                    selectedItem = k
                                    break
                                end
                            end
                        end
                    end
                end
            elseif key == 203 then -- Left arrow (переключение страницы)
                if currentPage > 1 then
                    currentPage = currentPage - 1
                    selectedItem = nil
                end
            elseif key == 205 then -- Right arrow (переключение страницы)
                if currentPage < maxPages then
                    currentPage = currentPage + 1
                    selectedItem = nil
                end
            elseif key == 200 then -- Up arrow for logs (ваш оригинальный код)
                logOffset = math.min(logOffset + 1, #logs - 5)
            elseif key == 208 then -- Down arrow for logs (ваш оригинальный код)
                logOffset = math.max(logOffset - 1, 0)
            end
        end
    end
    buttonHover = nil -- Сброс наведения после нажатия клавиши
    draw()
end

local function on_mouse_move(x, y)
    local newHover = nil
    -- Проверяем наведение на кнопки сортировки
    local col1Width = math.floor(WIDTH * 0.4)
    local col2Width = math.floor(WIDTH * 0.3)
    local sortButtonsY = 5
    if M.isInside(x, y, startX + col1Width + 1, sortButtonsY, col2Width, 2) then
        newHover = "sortAvailable"
    elseif M.isInside(x, y, startX + col1Width + col2Width + 2, sortButtonsY, WIDTH - col1Width - col2Width - 2, 2) then
        newHover = "sortCraft"
    end

    -- Кнопки пагинации
    local pagY = HEIGHT - 9
    if M.isInside(x, y, startX, pagY, 8, 2) then
        newHover = "prevPage"
    elseif M.isInside(x, y, startX + 10 + unicode.len(string.format("Страница %d/%d", currentPage, maxPages)) + 2, pagY, 8, 2) then
        newHover = "nextPage"
    end

    -- Кнопки действий
    local buttonY = HEIGHT - 6
    if M.isInside(x, y, startX, buttonY, 15, 2) then
        newHover = "add"
    elseif M.isInside(x, y, startX + 16, buttonY, 15, 2) then
        newHover = "edit"
    elseif M.isInside(x, y, startX + 32, buttonY, 15, 2) then
        newHover = "delete"
    elseif M.isInside(x, y, startX + 48, buttonY, 15, 2) then
        newHover = "refresh"
    elseif M.isInside(x, y, startX + 64, buttonY, 15, 2) then
        newHover = "save"
    end

    -- Кнопки режима редактирования/добавления
    if editMode then
        local fieldY = 5
        if M.isInside(x, y, math.floor(WIDTH / 2 - 10), fieldY + 7 + 2, 10, 2) then
            newHover = "acceptEdit"
        elseif M.isInside(x, y, math.floor(WIDTH / 2 + 1), fieldY + 7 + 2, 10, 2) then
            newHover = "cancelEdit"
        end
    end

    if newHover ~= buttonHover then
        buttonHover = newHover
        draw()
    end
end

-------------------- Старт --------------------
checkComponents()
bindGpu()
WIDTH, HEIGHT = g.maxResolution()
g.setResolution(WIDTH, HEIGHT)
addLog(logs, "INFO: Программа запущена", "INFO")
loadLibrary() -- Здесь M инициализируется

local ok, err = pcall(reload)
if not ok then
    addLog(logs, "ERROR: Ошибка при начальной загрузке: " .. tostring(err), "ERROR")
    draw()
    while true do os.sleep(1) end
end
draw()

local autoCraftCoroutine = coroutine.create(autoCraftLoop)

-- Регистрируем слушатели событий
event.listen("mouse_click", on_mouse_click)
event.listen("mouse_drag", on_mouse_drag)
event.listen("mouse_scroll", on_mouse_scroll)
event.listen("key_down", on_key)
event.listen("mouse_move", on_mouse_move) -- Добавлен слушатель для mouse_move

-- Главный цикл программы, который только возобновляет корутину и ждет событий
while true do
    -- Возобновляем корутину автокрафта
    local status, res = coroutine.resume(autoCraftCoroutine)
    if not status then
        addLog(logs, "Фатальная ошибка в autoCraftLoop: " .. tostring(res), "ERROR")
        autoCraftCoroutine = coroutine.create(autoCraftLoop) -- Создаем новую корутину, чтобы продолжить работу
    end

    -- Ждем событий (таких как mouse_click, key_down и т.д.)
    -- Время ожидания 0.05 позволит autoCraftLoop работать достаточно часто
    event.pull(0.05)
    -- draw() теперь вызывается в обработчиках событий, если есть изменения
    -- и в конце autoCraftLoop
end
